///////////////////////////////////////////////////////////////////////////////////////////////////
///
/// file    mdrv_DPRx.c
/// @author MStar Semiconductor _Inc.
/// @brief  DP Rx driver Function
///////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _MDRV_DPRX_C_
#define _MDRV_DPRX_C_

//-------------------------------------------------------------------------------------------------
//  Include Files
//-------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>
#include <types.h>
#include "dpCommon.h"
#include "mhal_DPRx.h"
#include "mhal_DPRx_phy.h"
#include "mdrv_DPRx.h"
#include "HdcpHandler.h"
#include "msEread.h"

#if (ENABLE_DP_INPUT == 0x1)
//-------------------------------------------------------------------------------------------------
//  Local Defines
//-------------------------------------------------------------------------------------------------
#define DP_DRV_DEBUG_MESSAGE		0

#if (DP_DEBUG_MESSAGE && DP_DRV_DEBUG_MESSAGE)
#define DP_DRV_DPUTSTR(str)			printf(str)
#define DP_DRV_DPRINTF(str, x)		printf(str, x)
#else
#define DP_DRV_DPUTSTR(str)
#define DP_DRV_DPRINTF(str, x)
#endif

//-------------------------------------------------------------------------------------------------
//  Global Variables
//-------------------------------------------------------------------------------------------------
extern BYTE XDATA ucDPFunctionEnableIndex;
extern BYTE XDATA ucDPTPCFunctionEnableIndex;
BYTE XDATA glucAudioPath[DPRx_ID_MAX] = {0};  //To indicate which RxID should update the mask count.

BYTE glubRxDataQueue[DPRx_ID_MAX][DPRx_PROGRAM_DPCD_MAX][DP_AUX_COMMAND_MAX_LENGTH];
BYTE glubRx_XDataQueue[DPRx_ID_MAX][DPRx_XDATAPROGRAM_DPCD_MAX][DPRX_XDataQueue];

DPRx_DecoderINFO XDATA glDPRxDecoderInfo[DPRx_DECODER_ID_MAX];

BOOL XDATA glubTypeCHPDCtrl[DP_TYPE_C_PORT_NUM] = {FALSE};
BOOL XDATA glubTypeCShortHPD[DP_TYPE_C_PORT_NUM] = {FALSE};
BOOL XDATA glubTriggerTypeCHPDFlag[DP_TYPE_C_PORT_NUM] = {FALSE};

#if (DPRX_HDCP14_Repeater_ENABLE == 1)
DPRx_HDCP14AKSVReceived_CB_FUNC pmdrv_DP_HDCP14AKSVReceived = NULL;
DPRx_HDCP14_CHECK_VPRIME_CB_FUNC pmdrv_DPRx_HDCP14CheckVprime = NULL;
#endif

#if(DPRX_HDCP2_ENABLE == 0x1)
DPRx_HDCP2_CB_FUNC pmdrv_DP_HDCP2RxEventProc = NULL;
DPRX_HDCP2_Config_Repeater_CB_FUNC pmdrv_DPRX_HDCP2_Config_Repeater_CB_FUNC = NULL;
BYTE ucHDCPData[DP_HDCP2_RX_QUEUE_SIZE] = {0};
BOOL bHDCP22RepPairEnable[DPRx_ID_MAX] = {0};
#endif

DPRx_INFO XDATA glDPRxInfo[DPRx_ID_MAX];
extern volatile ST_HDCP_HANDLER XDATA g_stHdcpHandler[DEF_HDCP_PORT_NUM];

extern BYTE XDATA glLastRxID;

extern BYTE glTypeC_PhyLaneSwap[DPRx_ID_MAX];

BOOL XDATA glHPEllitePatchEnable[DPRx_ID_MAX] = {0x0};

extern WORD usInfo1;
extern BYTE ubInfo2;


// For OSD DP1.4 Setting
const BYTE EDID_DPRX_PORT0[DP_EDID_MAX_SIZE] =
{
#if 0 // FHD 180, SQC test
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x86,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x22,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
    0x45,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x30,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0xB4,	0x1E,	0x53,	0x11,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x34,
    0x02,	0x03,	0x2F,	0xC1,	0x4C,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x3F,
    0x40,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,	0x02,	0x03,	0x30,
    0xB4,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xE3,	0x05,	0xC0,	0x01,	0xE3,	0x06,	0x00,	0x00,	0x06,
    0xAE,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,
    0x1A,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x91,
#endif

#if 1 // FHD 170, SQC test
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x87,	0xA2,	0x40,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0x85,	0x73,	0x41,	0x78,	0x1A,	0xCF,	0x74,	0xA3,	0x57,	0x4C,	0xB0,	0x23,
    0x09,	0x48,	0x4C,	0x00,	0x00,	0x00,	0x01,	0x01,	0x01,	0xFF,	0x01,	0xFF,	0xFF,	0x01,	0x01,	0x01,
    0x01,	0x01,	0x01,	0x01,	0x01,	0x20,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
    0x45,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x30,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0xB4,	0x1E,	0x53,	0x1E,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x3C,
    0x02,	0x03,	0x36,	0xF1,	0x4F,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x3F,
    0x40,	0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,
    0x02,	0x03,	0x30,	0xB4,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xE3,	0x05,	0xC0,	0x01,	0xE3,	0x06,
    0x0F,	0x00,	0xE3,	0x0F,	0x20,	0x0C,	0x5B,	0xA4,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,
    0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,	0x38,	0x8B,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,
    0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x1D,
#endif

#if 0 // FHD 175, SQC test
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x74,	0x30,	0x00,	0x01,	0x00,	0x00,	0x00,
    0x18,	0x0F,	0x01,	0x03,	0x85,	0x73,	0x41,	0x78,	0x0A,	0xCF,	0x74,	0xA3,	0x57,	0x4C,	0xB0,	0x23,
    0x09,	0x48,	0x4C,	0x00,	0x00,	0x00,	0x01,	0x01,	0x01,	0xFF,	0x01,	0xFF,	0xFF,	0x01,	0x01,	0x01,
    0x01,	0x01,	0x01,	0x01,	0x01,	0x20,	0x01,	0x1D,	0x00,	0x72,	0x51,	0xD0,	0x1E,	0x20,	0x6E,	0x28,
    0x55,	0x00,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x1E,	0x01,	0x1D,	0x80,	0x18,	0x71,	0x1C,	0x16,	0x20,
    0x58,	0x2C,	0x25,	0x00,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x9E,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x53,	0x74,	0x61,	0x72,	0x20,	0x44,	0x65,	0x6D,	0x6F,	0x0A,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x3B,	0x3C,	0x1F,	0x2D,	0x08,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x20,
    0x02,	0x03,	0x36,	0xF1,	0x4F,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x3F,
    0x40,	0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,
    0x02,	0x03,	0x30,	0xB4,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xE3,	0x05,	0xC0,	0x01,	0xE3,	0x06,
    0x0F,	0x00,	0xE3,	0x0F,	0x20,	0x0C,	0x30,	0xA9,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,
    0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,	0x38,	0x8B,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,
    0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x43,
#endif

#if 0 // QHD 100
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x86,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x3A,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x5B,	0x9D,	0x00,	0xA0,	0xA0,	0xA0,	0x29,	0x50,	0x30,	0x20,
    0x35,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x30,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0x64,	0x1E,	0x53,	0x11,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x49,
    0x02,	0x03,	0x35,	0xF1,	0x4E,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x40,
    0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,	0x02,
    0x03,	0x30,	0xB4,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xE3,	0x05,	0xC0,	0x01,	0xE3,	0x06,	0x0F,
    0x00,	0xE3,	0x0F,	0x20,	0x04,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x60,
#endif

#if 0 // 1080P
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3E, 0x93, 0x08, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x15, 0x01, 0x04, 0xA5, 0x33, 0x1D, 0x78, 0x22, 0x1E, 0x55, 0xA0, 0x59, 0x56, 0x9F, 0x27,
    0x0D, 0x50, 0x54, 0xBD, 0x4B, 0x00, 0xD1, 0xC0, 0x81, 0x80, 0x95, 0x0F, 0x95, 0x00, 0xB3, 0x00,
    0x81, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0xFD, 0x1E, 0x11, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x0A, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x56,
    0x53, 0x32, 0x33, 0x30, 0x50, 0x47, 0x4C, 0x57, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x53, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x6E,

    0x02, 0x03, 0x0C, 0xC1, 0x23, 0x09, 0x17, 0x07, 0x83, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60
#endif

#if 0 // 1080P 144
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3E, 0x93, 0x08, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x15, 0x01, 0x04, 0xA5, 0x33, 0x1D, 0x78, 0x22, 0x1E, 0x55, 0xA0, 0x59, 0x56, 0x9F, 0x27,
    0x0D, 0x50, 0x54, 0xBD, 0x4B, 0x00, 0xD1, 0xC0, 0x81, 0x80, 0x95, 0x0F, 0x95, 0x00, 0xB3, 0x00,
    0x81, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x38, 0x8B, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0xFD, 0x1E, 0x11, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x0A, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x56,
    0x53, 0x32, 0x33, 0x30, 0x50, 0x47, 0x4C, 0x57, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x53, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xE7,
    0x02, 0x03, 0x0C, 0xC1, 0x23, 0x09, 0x17, 0x07, 0x83, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
#endif

#if 0 // QHD, 2560x1440
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x36, 0x74, 0x3A, 0x41, 0x01, 0x01, 0x01, 0x01,
    0x31, 0x1A, 0x01, 0x04, 0xB5, 0x37, 0x1F, 0x78, 0x3E, 0xEE, 0x95, 0xA3, 0x54, 0x4C, 0x99, 0x26,
    0x0F, 0x50, 0x54, 0xA5, 0x4B, 0x00, 0x71, 0x4F, 0xA9, 0x40, 0x81, 0x80, 0xD1, 0xC0, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x56, 0x5E, 0x00, 0xA0, 0xA0, 0xA0, 0x29, 0x50, 0x30, 0x20,
    0x35, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x4D, 0x53, 0x54,
    0x41, 0x52, 0x5F, 0x44, 0x45, 0x4D, 0x4F, 0x0A, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4D,
    0x53, 0x54, 0x41, 0x52, 0x5F, 0x44, 0x45, 0x4D, 0x4F, 0x0A, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x5A, 0x19, 0x01, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xB1,
    0x02, 0x03, 0x1C, 0xF1, 0x4F, 0x90, 0x05, 0x04, 0x03, 0x02, 0x07, 0x16, 0x01, 0x06, 0x11, 0x12,
    0x15, 0x13, 0x14, 0x1F, 0x23, 0x09, 0x1F, 0x07, 0x83, 0x01, 0x00, 0x00, 0x02, 0x3A, 0x80, 0x18,
    0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C, 0x45, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1E, 0x7E, 0x39,
    0x00, 0xA0, 0x80, 0x38, 0x1F, 0x40, 0x30, 0x20, 0x3A, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1A,
    0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0x29, 0x37, 0x21, 0x00,
    0x00, 0x1E, 0xBF, 0x16, 0x00, 0xA0, 0x80, 0x38, 0x13, 0x40, 0x30, 0x20, 0x3A, 0x00, 0x29, 0x37,
    0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86
#endif

#if 0 // Test YUV420
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x10,	0xAC,	0xB6,	0x40,	0x53,	0x37,	0x36,	0x35,
    0x2A,	0x1A,	0x01,	0x04,	0xC5,	0x3C,	0x22,	0x78,	0x3A,	0x8A,	0xA0,	0xAC,	0x50,	0x32,	0xB7,	0x25,
    0x0B,	0x50,	0x52,	0x21,	0x08,	0x00,	0x81,	0x00,	0xB3,	0x00,	0xD1,	0x00,	0xA9,	0x40,	0x81,	0x80,
    0xD1,	0xC0,	0x00,	0x00,	0x00,	0x00,	0x08,	0xE8,	0x00,	0x30,	0xF2,	0x70,	0x5A,	0x80,	0xB0,	0x58,
    0x8A,	0x00,	0xBA,	0x89,	0x21,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x44,	0x58,	0x58,
    0x58,	0x52,	0x34,	0x38,	0x34,	0x35,	0x36,	0x37,	0x53,	0x0A,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x44,
    0x45,	0x4C,	0x4C,	0x20,	0x55,	0x50,	0x32,	0x37,	0x31,	0x38,	0x4B,	0x0A,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x1D,	0x4B,	0x1F,	0xB4,	0x6C,	0x01,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x92,
    0x02,	0x03,	0x23,	0xF2,	0x4C,	0x05,	0x84,	0x03,	0x02,	0x01,	0x12,	0x93,	0x14,	0x16,	0x07,	0x61,
    0x90,	0x23,	0x09,	0x07,	0x07,	0x83,	0x01,	0x00,	0x00,	0x65,	0x03,	0x0C,	0x00,	0x10,	0x00,	0xE3,
    0x0F,	0x00,	0x0C,	0x8C,	0x0A,	0xD0,	0x8A,	0x20,	0xE0,	0x2D,	0x10,	0x10,	0x3E,	0x96,	0x00,	0xC4,
    0x8E,	0x21,	0x00,	0x00,	0x18,	0x8C,	0x0A,	0xA0,	0x14,	0x51,	0xF0,	0x16,	0x00,	0x26,	0x7C,	0x43,
    0x00,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x98,	0x01,	0x1D,	0x00,	0xBC,	0x52,	0xD0,	0x1E,	0x20,	0xB8,
    0x28,	0x55,	0x40,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x97
#endif

#if 0 // Freesync FHD 40~70Hz
    0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x05,0xA4,0x30,0x00,0x02,0x00,0x00,0x00,
    0x01,0x18,0x01,0x04,0x80,0x73,0x41,0x78,0x0B,0xCF,0x74,0xA7,0x55,0x46,0x98,0x24,
    0x10,0x49,0x4B,0x21,0x08,0x00,0x81,0x80,0x95,0x00,0x90,0x40,0xA9,0xC0,0xA9,0x40,
    0xB3,0x00,0x61,0x40,0x71,0x40,0x37,0x45,0x80,0x4A,0x71,0x38,0x2D,0x40,0x30,0x20,
    0x35,0x00,0x35,0xAD,0x10,0x00,0x00,0x1E,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x00,0x46,
    0x52,0x45,0x45,0x53,0x59,0x4E,0x43,0x37,0x30,0x2D,0x34,0x30,0x00,0x00,0x00,0xFD,
    0x00,0x28,0x46,0x6B,0x6B,0x1E,0x01,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x01,0x0C,
    0x02,0x03,0x31,0xF3,0x4D,0x01,0x03,0x84,0x05,0x07,0x10,0x12,0x93,0x14,0x16,0x1F,
    0x20,0x22,0x29,0x09,0x07,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x83,0x01,0x00,0x00,
    0x67,0x03,0x0C,0x00,0x10,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x8C,0x0A,0xD0,0x8A,0x20,0xE0,0x2D,0x10,0x10,0x3E,0x96,0x00,0xC4,0x8E,0x21,
    0x00,0x00,0x18,0x02,0x3A,0x80,0x18,0x71,0x38,0x2D,0x40,0x58,0x2C,0x45,0x00,0xC4,
    0x8E,0x21,0x00,0x00,0x1E,0x01,0x1D,0x00,0xBC,0x52,0xD0,0x1E,0x20,0xB8,0x28,0x55,
    0x40,0xC4,0x8E,0x21,0x00,0x00,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07
#endif

#if 0 // DELL P2719HC
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x10, 0xAC, 0x86, 0x41, 0x53, 0x51, 0x30, 0x30,
    0x02, 0x1C, 0x01, 0x04, 0xA5, 0x3C, 0x22, 0x78, 0x3A, 0x48, 0x15, 0xA7, 0x56, 0x52, 0x9C, 0x27,
    0x0F, 0x50, 0x54, 0xA5, 0x4B, 0x00, 0x71, 0x4F, 0x81, 0x80, 0xA9, 0xC0, 0xD1, 0xC0, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0x56, 0x50, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x48, 0x38, 0x43,
    0x4A, 0x32, 0x4E, 0x46, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x44,
    0x45, 0x4C, 0x4C, 0x20, 0x50, 0x32, 0x37, 0x31, 0x39, 0x48, 0x43, 0x0A, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x53, 0x11, 0x01, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0xFB
#endif

#if 0 // 4K // Mstar EDID (3840x2160@60Hz Audio) Reduce Blanking
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x36, 0x74, 0x30, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x2C, 0x12, 0x01, 0x04, 0xA5, 0x00, 0x00, 0x78, 0xFA, 0x9F, 0xA3, 0xA3, 0x56, 0x4B, 0xB0, 0x23,
    0x09, 0x48, 0x4A, 0x21, 0x08, 0x00, 0x81, 0xC0, 0xA9, 0x40, 0xD1, 0xC0, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x34, 0xD0, 0x00, 0xA0, 0xF0, 0x70, 0x3E, 0x80, 0x30, 0x20,
    0x35, 0x00, 0x06, 0x44, 0x21, 0x00, 0x00, 0x1A, 0xD0, 0x39, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40,
    0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4D,
    0x53, 0x74, 0x61, 0x72, 0x20, 0x44, 0x65, 0x6D, 0x6F, 0x0A, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x3B, 0x3C, 0x1F, 0x46, 0x07, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xB9,

    0x02, 0x03, 0x1D, 0xF2, 0x4A, 0x05, 0x84, 0x03, 0x02, 0x01, 0x12, 0x93, 0x14, 0x16, 0x07, 0x23,
    0x0F, 0x7F, 0x07, 0x83, 0x01, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0,
    0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x18, 0x8C,
    0x0A, 0xA0, 0x14, 0x51, 0xF0, 0x16, 0x00, 0x26, 0x7C, 0x43, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00,
    0x99, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 0x21,
    0x00, 0x00, 0x1F, 0x01, 0x1D, 0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4,
    0x8E, 0x21, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEA
#endif

#if 0 // VESA Adaptive Sync EDID sample
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x52,	0x74,	0x23,	0x01,	0x67,	0x45,	0x23,	0x01,
    0xFF,	0x20,	0x01,	0x04,	0xB5,	0x35,	0x1E,	0x78,	0x1F,	0x0D,	0xC9,	0xA0,	0x57,	0x47,	0x98,	0x27,
    0x12,	0x48,	0x4C,	0xFF,	0xFF,	0x80,	0x01,	0x01,	0x01,	0x01,	0x01,	0x01,	0x01,	0x01,	0x01,	0x01,
    0x01,	0x01,	0x01,	0x01,	0x01,	0x01,	0x08,	0xE8,	0x00,	0x30,	0xF2,	0x70,	0x5A,	0x80,	0xB0,	0x58,
    0x8A,	0x00,	0x13,	0x2B,	0x21,	0x00,	0x00,	0x1E,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,
    0x58,	0x2C,	0x45,	0x00,	0x13,	0x2B,	0x21,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x45,
    0x78,	0x61,	0x6D,	0x70,	0x6C,	0x65,	0x20,	0x45,	0x44,	0x49,	0x44,	0x0A,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x2C,	0x91,	0x08,	0xFF,	0xA0,	0x01,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x02,	0xB1,

    0x70,	0x20,	0x79,	0x05,	0x00,	0x20,	0x00,	0x0C,	0x12,	0x34,	0x56,	0x23,	0x01,	0x67,	0x45,	0x23,
    0x01,	0x00,	0x00,	0x00,	0x21,	0x01,	0x1D,	0x13,	0x02,	0x2B,	0x01,	0x00,	0x0F,	0x70,	0x08,	0x00,
    0x00,	0x0A,	0x57,	0x7C,	0x44,	0x98,	0x7C,	0x02,	0x12,	0x88,	0x44,	0x4C,	0x40,	0x5E,	0xB0,	0x60,
    0x19,	0x14,	0x13,	0x78,	0x26,	0x00,	0x09,	0x07,	0x07,	0x03,	0x03,	0x00,	0xE0,	0x7F,	0x00,	0x00,
    0x2B,	0x00,	0x06,	0x27,	0x05,	0x2D,	0x8F,	0x00,	0x05,	0x22,	0x02,	0x14,	0x27,	0xF0,	0x13,	0x84,
    0xFF,	0x0E,	0x4F,	0x00,	0x07,	0x80,	0x1F,	0x00,	0x6F,	0x08,	0x99,	0x00,	0x8B,	0x00,	0x07,	0x00,
    0x23,	0x41,	0x07,	0x76,	0x75,	0x61,	0x60,	0x3F,	0x40,	0x10,	0x2A,	0x00,	0x0C,	0x83,	0xFF,	0x0E,
    0x6F,	0x08,	0x8F,	0x83,	0xFF,	0x09,	0x9F,	0x05,	0x8F,	0x00,	0x00,	0x00,	0x00,	0x00,	0x5E,	0x90,

    0x70,	0x20,	0x79,	0x00,	0x00,	0x24,	0x00,	0x24,	0x02,	0xFF,	0x0E,	0x6F,	0x08,	0x77,	0x02,	0xFF,
    0x0E,	0x6F,	0x08,	0x3B,	0x02,	0xFF,	0x09,	0x9F,	0x05,	0x77,	0x02,	0xFF,	0x09,	0x9F,	0x05,	0x3B,
    0x01,	0x7F,	0x07,	0x37,	0x04,	0x77,	0x01,	0x7F,	0x07,	0x37,	0x04,	0x3B,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x1D,	0x90,
#endif
};

// For OSD DP1.1/1.2 Setting
const BYTE EDID_DPRX_PORT0_NO_HDR[DP_EDID_MAX_SIZE] =
{
#if 1 // FHD 170Hz
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x86,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x22,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
    0x45,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x30,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0xB4,	0x1E,	0x53,	0x11,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x34,
    0x02,	0x03,	0x2E,	0xF1,	0x4F,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x3F,
    0x40,	0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,
    0x02,	0x03,	0x30,	0xB4,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xE3,	0x05,	0xC0,	0x01,	0x5B,	0xA4,
    0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,
    0x38,	0x8B,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,
    0x00,	0x1A,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x3B,
#endif

#if 0 // FHD 175Hz
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x86,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x22,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
    0x45,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x30,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0xB4,	0x1E,	0x53,	0x11,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x34,
    0x02,	0x03,	0x2E,	0xF1,	0x4F,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x3F,
    0x40,	0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,
    0x02,	0x03,	0x30,	0xB4,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xE3,	0x05,	0xC0,	0x01,	0x30,	0xA9,
    0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,
    0x38,	0x8B,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,
    0x00,	0x1A,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x61,
#endif

#if 0 // QHD 100
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x86,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x3A,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x5B,	0x9D,	0x00,	0xA0,	0xA0,	0xA0,	0x29,	0x50,	0x30,	0x20,
    0x35,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x30,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0x64,	0x1E,	0x53,	0x11,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x49,
    0x02,	0x03,	0x31,	0xF1,	0x4E,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x40,
    0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,	0x02,
    0x03,	0x30,	0xB4,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xE3,	0x05,	0xC0,	0x01,	0xE3,	0x0F,	0x20,
    0x04,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x5C,
#endif
};

// For OSD DP1.4 Setting
const BYTE EDID_DPRX_PORT1[DP_EDID_MAX_SIZE] =
{
#if 0 // RFHD 180, SQC test
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x87,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x3A,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
    0x45,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x31,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0xB4,	0x1E,	0x53,	0x1E,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x0D,
    0x02,	0x03,	0x33,	0xC1,	0x4C,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x3F,
    0x40,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,	0x02,	0x03,	0x30,
    0xB4,	0x00,	0x05,	0x61,	0x37,	0x08,	0x2F,	0xE3,	0x05,	0xC0,	0x01,	0xE3,	0x0F,	0x00,	0x00,	0xE3,
    0x06,	0x0F,	0x01,	0x06,	0xAE,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,	0x35,	0x00,	0x09,
    0x25,	0x21,	0x00,	0x00,	0x1A,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xB7,
#endif

#if 1 // FHD 170, SQC test
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x87,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x3A,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
    0x45,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x31,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0xB4,	0x1E,	0x53,	0x1E,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x0D,
    0x02,	0x03,	0x36,	0xF1,	0x4F,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x3F,
    0x40,	0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,
    0x02,	0x03,	0x30,	0xB4,	0x00,	0x05,	0x61,	0x37,	0x08,	0x2F,	0xE3,	0x05,	0xC0,	0x01,	0xE3,	0x0F,
    0x20,	0x0C,	0xE3,	0x06,	0x0F,	0x01,	0x5B,	0xA4,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,
    0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,	0x38,	0x8B,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,
    0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x48,
#endif

#if 0 // FHD 175, SQC test
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x87,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x3A,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
    0x45,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x31,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0xB4,	0x1E,	0x53,	0x1E,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x0D,
    0x02,	0x03,	0x36,	0xF1,	0x4F,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x3F,
    0x40,	0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,
    0x02,	0x03,	0x30,	0xB4,	0x00,	0x05,	0x61,	0x37,	0x08,	0x2F,	0xE3,	0x05,	0xC0,	0x01,	0xE3,	0x0F,
    0x20,	0x0C,	0xE3,	0x06,	0x0F,	0x01,	0x2E,	0xA9,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,
    0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,	0x38,	0x8B,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,
    0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x70,
#endif

#if 0 // QHD 100
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x86,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x3A,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x5B,	0x9D,	0x00,	0xA0,	0xA0,	0xA0,	0x29,	0x50,	0x30,	0x20,
    0x35,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x31,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0x64,	0x1E,	0x53,	0x11,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x48,
    0x02,	0x03,	0x35,	0xF1,	0x4E,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x40,
    0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,	0x02,
    0x03,	0x30,	0xB4,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xE3,	0x05,	0xC0,	0x01,	0xE3,	0x06,	0x0F,
    0x00,	0xE3,	0x0F,	0x20,	0x04,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x60,
#endif

#if 0 // 576P Port 0
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,	0xFF, 0x00,	0x3E, 0x93,	0x08, 0xC0,	0x00, 0x00,	0x00, 0x00,
	0x20, 0x15,	0x01, 0x04,	0xA5, 0x33,	0x1D, 0x78,	0x22, 0x1E,	0x55, 0xA0,	0x59, 0x56,	0x9F, 0x27,
	0x0D, 0x50,	0x54, 0xBD,	0x4B, 0x00,	0xD1, 0xC0,	0x81, 0x80,	0x95, 0x0F,	0x95, 0x00,	0xB3, 0x00,
	0x81, 0xC0,	0x01, 0x01,	0x01, 0x01,	0x8C, 0x0A,	0xD0, 0x90,	0x20, 0x40,	0x31, 0x20,	0x0C, 0x40,
	0x55, 0x00,	0xC4, 0x8E,	0x21, 0x00,	0x00, 0x18,	0x00, 0x00,	0x00, 0xFF,	0x00, 0x0A,	0x20, 0x20,
	0x20, 0x20,	0x20, 0x20,	0x20, 0x20,	0x20, 0x20,	0x20, 0x20,	0x00, 0x00,	0x00, 0xFC,	0x00, 0x56,
	0x53, 0x32,	0x33, 0x30,	0x50, 0x47,	0x4C, 0x57,	0x0A, 0x20,	0x20, 0x20,	0x00, 0x00,	0x00, 0xFD,
	0x00, 0x38,	0x4C, 0x1E,	0x53, 0x11,	0x00, 0x0A,	0x20, 0x20,	0x20, 0x20,	0x20, 0x20,	0x01, 0x98,
	0x02, 0x03,	0x0C, 0xC1,	0x23, 0x09,	0x17, 0x07,	0x83, 0x01,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,
	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,
	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,
	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,
	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,
	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,
	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,
	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x60,
#endif

#if 0 // 1080P
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3E, 0x93, 0x08, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x15, 0x01, 0x04, 0xA5, 0x33, 0x1D, 0x78, 0x22, 0x1E, 0x55, 0xA0, 0x59, 0x56, 0x9F, 0x27,
    0x0D, 0x50, 0x54, 0xBD, 0x4B, 0x00, 0xD1, 0xC0, 0x81, 0x80, 0x95, 0x0F, 0x95, 0x00, 0xB3, 0x00,
    0x81, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0xFD, 0x1E, 0x11, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x0A, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x56,
    0x53, 0x32, 0x33, 0x30, 0x50, 0x47, 0x4C, 0x57, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x53, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x6E,
    0x02, 0x03, 0x0C, 0xC1, 0x23, 0x09, 0x17, 0x07, 0x83, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60
#endif

#if 0 // 1080P 144
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3E, 0x93, 0x08, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x15, 0x01, 0x04, 0xA5, 0x33, 0x1D, 0x78, 0x22, 0x1E, 0x55, 0xA0, 0x59, 0x56, 0x9F, 0x27,
    0x0D, 0x50, 0x54, 0xBD, 0x4B, 0x00, 0xD1, 0xC0, 0x81, 0x80, 0x95, 0x0F, 0x95, 0x00, 0xB3, 0x00,
    0x81, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x38, 0x8B, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0xFD, 0x1E, 0x11, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x0A, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x56,
    0x53, 0x32, 0x33, 0x30, 0x50, 0x47, 0x4C, 0x57, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x53, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xE7,
    0x02, 0x03, 0x0C, 0xC1, 0x23, 0x09, 0x17, 0x07, 0x83, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
#endif

#if 0 // QHD, 2560x1440
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x36, 0x74, 0x3A, 0x41, 0x01, 0x01, 0x01, 0x01,
    0x31, 0x1A, 0x01, 0x04, 0xB5, 0x37, 0x1F, 0x78, 0x3E, 0xEE, 0x95, 0xA3, 0x54, 0x4C, 0x99, 0x26,
    0x0F, 0x50, 0x54, 0xA5, 0x4B, 0x00, 0x71, 0x4F, 0xA9, 0x40, 0x81, 0x80, 0xD1, 0xC0, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x56, 0x5E, 0x00, 0xA0, 0xA0, 0xA0, 0x29, 0x50, 0x30, 0x20,
    0x35, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x4D, 0x53, 0x54,
    0x41, 0x52, 0x5F, 0x44, 0x45, 0x4D, 0x4F, 0x0A, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4D,
    0x53, 0x54, 0x41, 0x52, 0x5F, 0x44, 0x45, 0x4D, 0x4F, 0x0A, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x5A, 0x19, 0x01, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xB1,
    0x02, 0x03, 0x1C, 0xF1, 0x4F, 0x90, 0x05, 0x04, 0x03, 0x02, 0x07, 0x16, 0x01, 0x06, 0x11, 0x12,
    0x15, 0x13, 0x14, 0x1F, 0x23, 0x09, 0x1F, 0x07, 0x83, 0x01, 0x00, 0x00, 0x02, 0x3A, 0x80, 0x18,
    0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C, 0x45, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1E, 0x7E, 0x39,
    0x00, 0xA0, 0x80, 0x38, 0x1F, 0x40, 0x30, 0x20, 0x3A, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1A,
    0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0x29, 0x37, 0x21, 0x00,
    0x00, 0x1E, 0xBF, 0x16, 0x00, 0xA0, 0x80, 0x38, 0x13, 0x40, 0x30, 0x20, 0x3A, 0x00, 0x29, 0x37,
    0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86
#endif

#if 0 // Test YUV420
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x10,	0xAC,	0xB6,	0x40,	0x53,	0x37,	0x36,	0x35,
    0x2A,	0x1A,	0x01,	0x04,	0xC5,	0x3C,	0x22,	0x78,	0x3A,	0x8A,	0xA0,	0xAC,	0x50,	0x32,	0xB7,	0x25,
    0x0B,	0x50,	0x52,	0x21,	0x08,	0x00,	0x81,	0x00,	0xB3,	0x00,	0xD1,	0x00,	0xA9,	0x40,	0x81,	0x80,
    0xD1,	0xC0,	0x00,	0x00,	0x00,	0x00,	0x08,	0xE8,	0x00,	0x30,	0xF2,	0x70,	0x5A,	0x80,	0xB0,	0x58,
    0x8A,	0x00,	0xBA,	0x89,	0x21,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x44,	0x58,	0x58,
    0x58,	0x52,	0x34,	0x38,	0x34,	0x35,	0x36,	0x37,	0x53,	0x0A,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x44,
    0x45,	0x4C,	0x4C,	0x20,	0x55,	0x50,	0x32,	0x37,	0x31,	0x38,	0x4B,	0x0A,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x1D,	0x4B,	0x1F,	0xB4,	0x6C,	0x01,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x92,
    0x02,	0x03,	0x23,	0xF2,	0x4C,	0x05,	0x84,	0x03,	0x02,	0x01,	0x12,	0x93,	0x14,	0x16,	0x07,	0x61,
    0x90,	0x23,	0x09,	0x07,	0x07,	0x83,	0x01,	0x00,	0x00,	0x65,	0x03,	0x0C,	0x00,	0x10,	0x00,	0xE3,
    0x0F,	0x00,	0x0C,	0x8C,	0x0A,	0xD0,	0x8A,	0x20,	0xE0,	0x2D,	0x10,	0x10,	0x3E,	0x96,	0x00,	0xC4,
    0x8E,	0x21,	0x00,	0x00,	0x18,	0x8C,	0x0A,	0xA0,	0x14,	0x51,	0xF0,	0x16,	0x00,	0x26,	0x7C,	0x43,
    0x00,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x98,	0x01,	0x1D,	0x00,	0xBC,	0x52,	0xD0,	0x1E,	0x20,	0xB8,
    0x28,	0x55,	0x40,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x97
#endif

#if 0 // Freesync FHD 40~70Hz
    0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x05,0xA4,0x30,0x00,0x02,0x00,0x00,0x00,
    0x01,0x18,0x01,0x04,0x80,0x73,0x41,0x78,0x0B,0xCF,0x74,0xA7,0x55,0x46,0x98,0x24,
    0x10,0x49,0x4B,0x21,0x08,0x00,0x81,0x80,0x95,0x00,0x90,0x40,0xA9,0xC0,0xA9,0x40,
    0xB3,0x00,0x61,0x40,0x71,0x40,0x37,0x45,0x80,0x4A,0x71,0x38,0x2D,0x40,0x30,0x20,
    0x35,0x00,0x35,0xAD,0x10,0x00,0x00,0x1E,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x00,0x46,
    0x52,0x45,0x45,0x53,0x59,0x4E,0x43,0x37,0x30,0x2D,0x34,0x30,0x00,0x00,0x00,0xFD,
    0x00,0x28,0x46,0x6B,0x6B,0x1E,0x01,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x01,0x0C,
    0x02,0x03,0x31,0xF3,0x4D,0x01,0x03,0x84,0x05,0x07,0x10,0x12,0x93,0x14,0x16,0x1F,
    0x20,0x22,0x29,0x09,0x07,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x83,0x01,0x00,0x00,
    0x67,0x03,0x0C,0x00,0x10,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x8C,0x0A,0xD0,0x8A,0x20,0xE0,0x2D,0x10,0x10,0x3E,0x96,0x00,0xC4,0x8E,0x21,
    0x00,0x00,0x18,0x02,0x3A,0x80,0x18,0x71,0x38,0x2D,0x40,0x58,0x2C,0x45,0x00,0xC4,
    0x8E,0x21,0x00,0x00,0x1E,0x01,0x1D,0x00,0xBC,0x52,0xD0,0x1E,0x20,0xB8,0x28,0x55,
    0x40,0xC4,0x8E,0x21,0x00,0x00,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07
#endif

#if 0 // 4K // Mstar EDID (3840x2160@60Hz Audio) Reduce Blanking
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x36, 0x74, 0x30, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x2C, 0x12, 0x01, 0x04, 0xA5, 0x00, 0x00, 0x78, 0xFA, 0x9F, 0xA3, 0xA3, 0x56, 0x4B, 0xB0, 0x23,
    0x09, 0x48, 0x4A, 0x21, 0x08, 0x00, 0x81, 0xC0, 0xA9, 0x40, 0xD1, 0xC0, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x34, 0xD0, 0x00, 0xA0, 0xF0, 0x70, 0x3E, 0x80, 0x30, 0x20,
    0x35, 0x00, 0x06, 0x44, 0x21, 0x00, 0x00, 0x1A, 0xD0, 0x39, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40,
    0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4D,
    0x53, 0x74, 0x61, 0x72, 0x20, 0x44, 0x65, 0x6D, 0x6F, 0x0A, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x3B, 0x3C, 0x1F, 0x46, 0x07, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xB9,

    0x02, 0x03, 0x1D, 0xF2, 0x4A, 0x05, 0x84, 0x03, 0x02, 0x01, 0x12, 0x93, 0x14, 0x16, 0x07, 0x23,
    0x0F, 0x7F, 0x07, 0x83, 0x01, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0,
    0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x18, 0x8C,
    0x0A, 0xA0, 0x14, 0x51, 0xF0, 0x16, 0x00, 0x26, 0x7C, 0x43, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00,
    0x99, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 0x21,
    0x00, 0x00, 0x1F, 0x01, 0x1D, 0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4,
    0x8E, 0x21, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEA
#endif

#if 0 // 2560x1440@60Hz
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x4C, 0x2D, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    0x2F, 0x1A, 0x01, 0x03, 0x80, 0x3C, 0x22, 0x78, 0x2A, 0x64, 0xAD, 0xA4, 0x54, 0x4D, 0x9A, 0x26,
    0x0F, 0x47, 0x4A, 0xBF, 0xEF, 0x80, 0x71, 0x4F, 0x81, 0x00, 0x81, 0xC0, 0x81, 0x80, 0x95, 0x00,
    0xA9, 0xC0, 0xB3, 0x00, 0x01, 0x01, 0xEB, 0x60, 0x00, 0x78, 0xA0, 0xA0, 0x67, 0x50, 0x08, 0x20,
    0x98, 0x04, 0x56, 0x50, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x30, 0x3C, 0x1E,
    0xDF, 0x19, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x46,
    0x72, 0x65, 0x65, 0x53, 0x79, 0x6E, 0x63, 0x5F, 0x34, 0x38, 0x36, 0x30, 0x00, 0x00, 0x00, 0xFF,
    0x00, 0x48, 0x31, 0x41, 0x4B, 0x35, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0A, 0x20, 0x20, 0x01, 0x72,
    0x02, 0x03, 0x5A, 0xF0, 0x53, 0x5F, 0x10, 0x1F, 0x04, 0x13, 0x05, 0x14, 0x20, 0x21, 0x22, 0x5D,
    0x5E, 0x62, 0x63, 0x64, 0x07, 0x16, 0x03, 0x12, 0x29, 0x09, 0x07, 0x07, 0x15, 0x07, 0x50, 0x3D,
    0x04, 0xC0, 0x83, 0x01, 0x00, 0x00, 0xE2, 0x00, 0x0F, 0x6E, 0x03, 0x0C, 0x00, 0x20, 0x00, 0xB8,
    0x3C, 0x20, 0x00, 0x80, 0x01, 0x02, 0x03, 0x04, 0x67, 0xD8, 0x5D, 0xC4, 0x01, 0x78, 0x80, 0x00,
    0x68, 0x1A, 0x00, 0x00, 0x01, 0x01, 0x30, 0x3C, 0x00, 0xE3, 0x05, 0x03, 0x01, 0xE5, 0x0E, 0x60,
    0x61, 0x65, 0x66, 0xE6, 0x06, 0x05, 0x01, 0xFF, 0xFF, 0x00, 0x01, 0x1D, 0x80, 0xD0, 0x72, 0x1C,
    0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0x50, 0x1D, 0x74, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94
#endif
};

// For OSD DP1.1/1.2 Setting
const BYTE EDID_DPRX_PORT1_NO_HDR[DP_EDID_MAX_SIZE] =
{
#if 1 // FHD 170
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x87,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x3A,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
    0x45,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x31,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0xB4,	0x1E,	0x53,	0x1E,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x0D,
    0x02,	0x03,	0x2E,	0xF1,	0x4F,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x3F,
    0x40,	0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,
    0x02,	0x03,	0x30,	0xB4,	0x00,	0x05,	0x61,	0x37,	0x08,	0x2F,	0xE3,	0x05,	0xC0,	0x01,	0x5B,	0xA4,
    0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,
    0x38,	0x8B,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,
    0x00,	0x1A,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x67,
#endif

#if 0 // FHD 175
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x87,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x3A,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
    0x45,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x31,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0xB4,	0x1E,	0x53,	0x1E,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x0D,
    0x02,	0x03,	0x2E,	0xF1,	0x4F,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x3F,
    0x40,	0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,
    0x02,	0x03,	0x30,	0xB4,	0x00,	0x05,	0x61,	0x37,	0x08,	0x2F,	0xE3,	0x05,	0xC0,	0x01,	0x2E,	0xA9,
    0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,
    0x38,	0x8B,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,
    0x00,	0x1A,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x8F,
#endif

#if 0 // QHD 100
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x86,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x3A,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x5B,	0x9D,	0x00,	0xA0,	0xA0,	0xA0,	0x29,	0x50,	0x30,	0x20,
    0x35,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x31,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0x64,	0x1E,	0x53,	0x11,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x48,
    0x02,	0x03,	0x31,	0xF1,	0x4E,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x40,
    0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,	0x02,
    0x03,	0x30,	0xB4,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xE3,	0x05,	0xC0,	0x01,	0xE3,	0x0F,	0x20,
    0x04,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x5C,
#endif
};

// For OSD DP1.4 Setting
const BYTE EDID_DPRX_PORT2[DP_EDID_MAX_SIZE] =
{
#if 0 // FHD 180, SQC test
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x88,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x22,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
    0x45,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x32,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0xB4,	0x1E,	0x53,	0x1E,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x23,
    0x02,	0x03,	0x2F,	0xC1,	0x4C,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x3F,
    0x40,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,	0x02,	0x03,	0x30,
    0xB4,	0x00,	0x05,	0x61,	0x37,	0x58,	0x2F,	0xE3,	0x05,	0xC0,	0x01,	0xE3,	0x06,	0x0F,	0x00,	0x06,
    0xAE,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,
    0x1A,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x5E,
#endif

#if 1 // FHD 170, SQC test
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x88,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x22,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
    0x45,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x32,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0xB4,	0x1E,	0x53,	0x1E,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x23,
    0x02,	0x03,	0x36,	0xF1,	0x4F,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x3F,
    0x40,	0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,
    0x02,	0x03,	0x30,	0xB4,	0x00,	0x05,	0x61,	0x37,	0x58,	0x2F,	0xE3,	0x05,	0xC0,	0x01,	0xE3,	0x06,
    0x0F,	0x00,	0xE3,	0x0F,	0x20,	0x0C,	0x5B,	0xA4,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,
    0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,	0x38,	0x8B,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,
    0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xF9,
#endif

#if 0 // FHD 175, SQC test
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x88,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x22,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
    0x45,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x32,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0xB4,	0x1E,	0x53,	0x1E,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x23,
    0x02,	0x03,	0x36,	0xF1,	0x4F,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x3F,
    0x40,	0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,
    0x02,	0x03,	0x30,	0xB4,	0x00,	0x05,	0x61,	0x37,	0x58,	0x2F,	0xE3,	0x05,	0xC0,	0x01,	0xE3,	0x06,
    0x0F,	0x00,	0xE3,	0x0F,	0x20,	0x0C,	0x30,	0xA9,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,
    0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,	0x38,	0x8B,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,
    0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x1F,
#endif

#if 0 // QHD 100
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x86,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x3A,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x5B,	0x9D,	0x00,	0xA0,	0xA0,	0xA0,	0x29,	0x50,	0x30,	0x20,
    0x35,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x32,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0x64,	0x1E,	0x53,	0x11,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x47,
    0x02,	0x03,	0x35,	0xF1,	0x4E,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x40,
    0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,	0x02,
    0x03,	0x30,	0xB4,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xE3,	0x05,	0xC0,	0x01,	0xE3,	0x06,	0x0F,
    0x00,	0xE3,	0x0F,	0x20,	0x04,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x60,
#endif

#if 0 // 576P Port 0
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,	0xFF, 0x00,	0x3E, 0x93,	0x08, 0xC0,	0x00, 0x00,	0x00, 0x00,
	0x20, 0x15,	0x01, 0x04,	0xA5, 0x33,	0x1D, 0x78,	0x22, 0x1E,	0x55, 0xA0,	0x59, 0x56,	0x9F, 0x27,
	0x0D, 0x50,	0x54, 0xBD,	0x4B, 0x00,	0xD1, 0xC0,	0x81, 0x80,	0x95, 0x0F,	0x95, 0x00,	0xB3, 0x00,
	0x81, 0xC0,	0x01, 0x01,	0x01, 0x01,	0x8C, 0x0A,	0xD0, 0x90,	0x20, 0x40,	0x31, 0x20,	0x0C, 0x40,
	0x55, 0x00,	0xC4, 0x8E,	0x21, 0x00,	0x00, 0x18,	0x00, 0x00,	0x00, 0xFF,	0x00, 0x0A,	0x20, 0x20,
	0x20, 0x20,	0x20, 0x20,	0x20, 0x20,	0x20, 0x20,	0x20, 0x20,	0x00, 0x00,	0x00, 0xFC,	0x00, 0x56,
	0x53, 0x32,	0x33, 0x30,	0x50, 0x47,	0x4C, 0x57,	0x0A, 0x20,	0x20, 0x20,	0x00, 0x00,	0x00, 0xFD,
	0x00, 0x38,	0x4C, 0x1E,	0x53, 0x11,	0x00, 0x0A,	0x20, 0x20,	0x20, 0x20,	0x20, 0x20,	0x01, 0x98,
	0x02, 0x03,	0x0C, 0xC1,	0x23, 0x09,	0x17, 0x07,	0x83, 0x01,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,
	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,
	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,
	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,
	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,
	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,
	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,
	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x00,	0x00, 0x60,
#endif

#if 0 // 1080P
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3E, 0x93, 0x08, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x15, 0x01, 0x04, 0xA5, 0x33, 0x1D, 0x78, 0x22, 0x1E, 0x55, 0xA0, 0x59, 0x56, 0x9F, 0x27,
    0x0D, 0x50, 0x54, 0xBD, 0x4B, 0x00, 0xD1, 0xC0, 0x81, 0x80, 0x95, 0x0F, 0x95, 0x00, 0xB3, 0x00,
    0x81, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0xFD, 0x1E, 0x11, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x0A, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x56,
    0x53, 0x32, 0x33, 0x30, 0x50, 0x47, 0x4C, 0x57, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x53, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x6E,

    0x02, 0x03, 0x0C, 0xC1, 0x23, 0x09, 0x17, 0x07, 0x83, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60
#endif

#if 0 // 1080P 144
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3E, 0x93, 0x08, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x15, 0x01, 0x04, 0xA5, 0x33, 0x1D, 0x78, 0x22, 0x1E, 0x55, 0xA0, 0x59, 0x56, 0x9F, 0x27,
    0x0D, 0x50, 0x54, 0xBD, 0x4B, 0x00, 0xD1, 0xC0, 0x81, 0x80, 0x95, 0x0F, 0x95, 0x00, 0xB3, 0x00,
    0x81, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x38, 0x8B, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0xFD, 0x1E, 0x11, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x0A, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x56,
    0x53, 0x32, 0x33, 0x30, 0x50, 0x47, 0x4C, 0x57, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x53, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xE7,
    0x02, 0x03, 0x0C, 0xC1, 0x23, 0x09, 0x17, 0x07, 0x83, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
#endif

#if 0 // QHD, 2560x1440
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x36, 0x74, 0x3A, 0x41, 0x01, 0x01, 0x01, 0x01,
    0x31, 0x1A, 0x01, 0x04, 0xB5, 0x37, 0x1F, 0x78, 0x3E, 0xEE, 0x95, 0xA3, 0x54, 0x4C, 0x99, 0x26,
    0x0F, 0x50, 0x54, 0xA5, 0x4B, 0x00, 0x71, 0x4F, 0xA9, 0x40, 0x81, 0x80, 0xD1, 0xC0, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x56, 0x5E, 0x00, 0xA0, 0xA0, 0xA0, 0x29, 0x50, 0x30, 0x20,
    0x35, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x4D, 0x53, 0x54,
    0x41, 0x52, 0x5F, 0x44, 0x45, 0x4D, 0x4F, 0x0A, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4D,
    0x53, 0x54, 0x41, 0x52, 0x5F, 0x44, 0x45, 0x4D, 0x4F, 0x0A, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x5A, 0x19, 0x01, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xB1,
    0x02, 0x03, 0x1C, 0xF1, 0x4F, 0x90, 0x05, 0x04, 0x03, 0x02, 0x07, 0x16, 0x01, 0x06, 0x11, 0x12,
    0x15, 0x13, 0x14, 0x1F, 0x23, 0x09, 0x1F, 0x07, 0x83, 0x01, 0x00, 0x00, 0x02, 0x3A, 0x80, 0x18,
    0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C, 0x45, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1E, 0x7E, 0x39,
    0x00, 0xA0, 0x80, 0x38, 0x1F, 0x40, 0x30, 0x20, 0x3A, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1A,
    0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0x29, 0x37, 0x21, 0x00,
    0x00, 0x1E, 0xBF, 0x16, 0x00, 0xA0, 0x80, 0x38, 0x13, 0x40, 0x30, 0x20, 0x3A, 0x00, 0x29, 0x37,
    0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86
#endif

#if 0 // Test YUV420
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x10,	0xAC,	0xB6,	0x40,	0x53,	0x37,	0x36,	0x35,
    0x2A,	0x1A,	0x01,	0x04,	0xC5,	0x3C,	0x22,	0x78,	0x3A,	0x8A,	0xA0,	0xAC,	0x50,	0x32,	0xB7,	0x25,
    0x0B,	0x50,	0x52,	0x21,	0x08,	0x00,	0x81,	0x00,	0xB3,	0x00,	0xD1,	0x00,	0xA9,	0x40,	0x81,	0x80,
    0xD1,	0xC0,	0x00,	0x00,	0x00,	0x00,	0x08,	0xE8,	0x00,	0x30,	0xF2,	0x70,	0x5A,	0x80,	0xB0,	0x58,
    0x8A,	0x00,	0xBA,	0x89,	0x21,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x44,	0x58,	0x58,
    0x58,	0x52,	0x34,	0x38,	0x34,	0x35,	0x36,	0x37,	0x53,	0x0A,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x44,
    0x45,	0x4C,	0x4C,	0x20,	0x55,	0x50,	0x32,	0x37,	0x31,	0x38,	0x4B,	0x0A,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x1D,	0x4B,	0x1F,	0xB4,	0x6C,	0x01,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x92,
    0x02,	0x03,	0x23,	0xF2,	0x4C,	0x05,	0x84,	0x03,	0x02,	0x01,	0x12,	0x93,	0x14,	0x16,	0x07,	0x61,
    0x90,	0x23,	0x09,	0x07,	0x07,	0x83,	0x01,	0x00,	0x00,	0x65,	0x03,	0x0C,	0x00,	0x10,	0x00,	0xE3,
    0x0F,	0x00,	0x0C,	0x8C,	0x0A,	0xD0,	0x8A,	0x20,	0xE0,	0x2D,	0x10,	0x10,	0x3E,	0x96,	0x00,	0xC4,
    0x8E,	0x21,	0x00,	0x00,	0x18,	0x8C,	0x0A,	0xA0,	0x14,	0x51,	0xF0,	0x16,	0x00,	0x26,	0x7C,	0x43,
    0x00,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x98,	0x01,	0x1D,	0x00,	0xBC,	0x52,	0xD0,	0x1E,	0x20,	0xB8,
    0x28,	0x55,	0x40,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x97
#endif

#if 0 // Freesync FHD 40~70Hz
    0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x05,0xA4,0x30,0x00,0x02,0x00,0x00,0x00,
    0x01,0x18,0x01,0x04,0x80,0x73,0x41,0x78,0x0B,0xCF,0x74,0xA7,0x55,0x46,0x98,0x24,
    0x10,0x49,0x4B,0x21,0x08,0x00,0x81,0x80,0x95,0x00,0x90,0x40,0xA9,0xC0,0xA9,0x40,
    0xB3,0x00,0x61,0x40,0x71,0x40,0x37,0x45,0x80,0x4A,0x71,0x38,0x2D,0x40,0x30,0x20,
    0x35,0x00,0x35,0xAD,0x10,0x00,0x00,0x1E,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x00,0x46,
    0x52,0x45,0x45,0x53,0x59,0x4E,0x43,0x37,0x30,0x2D,0x34,0x30,0x00,0x00,0x00,0xFD,
    0x00,0x28,0x46,0x6B,0x6B,0x1E,0x01,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x01,0x0C,
    0x02,0x03,0x31,0xF3,0x4D,0x01,0x03,0x84,0x05,0x07,0x10,0x12,0x93,0x14,0x16,0x1F,
    0x20,0x22,0x29,0x09,0x07,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x83,0x01,0x00,0x00,
    0x67,0x03,0x0C,0x00,0x10,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x8C,0x0A,0xD0,0x8A,0x20,0xE0,0x2D,0x10,0x10,0x3E,0x96,0x00,0xC4,0x8E,0x21,
    0x00,0x00,0x18,0x02,0x3A,0x80,0x18,0x71,0x38,0x2D,0x40,0x58,0x2C,0x45,0x00,0xC4,
    0x8E,0x21,0x00,0x00,0x1E,0x01,0x1D,0x00,0xBC,0x52,0xD0,0x1E,0x20,0xB8,0x28,0x55,
    0x40,0xC4,0x8E,0x21,0x00,0x00,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07
#endif

#if 0 // 4K // Mstar EDID (3840x2160@60Hz Audio) Reduce Blanking
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x36, 0x74, 0x30, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x2C, 0x12, 0x01, 0x04, 0xA5, 0x00, 0x00, 0x78, 0xFA, 0x9F, 0xA3, 0xA3, 0x56, 0x4B, 0xB0, 0x23,
    0x09, 0x48, 0x4A, 0x21, 0x08, 0x00, 0x81, 0xC0, 0xA9, 0x40, 0xD1, 0xC0, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x34, 0xD0, 0x00, 0xA0, 0xF0, 0x70, 0x3E, 0x80, 0x30, 0x20,
    0x35, 0x00, 0x06, 0x44, 0x21, 0x00, 0x00, 0x1A, 0xD0, 0x39, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40,
    0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4D,
    0x53, 0x74, 0x61, 0x72, 0x20, 0x44, 0x65, 0x6D, 0x6F, 0x0A, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x3B, 0x3C, 0x1F, 0x46, 0x07, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xB9,

    0x02, 0x03, 0x1D, 0xF2, 0x4A, 0x05, 0x84, 0x03, 0x02, 0x01, 0x12, 0x93, 0x14, 0x16, 0x07, 0x23,
    0x0F, 0x7F, 0x07, 0x83, 0x01, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0,
    0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x18, 0x8C,
    0x0A, 0xA0, 0x14, 0x51, 0xF0, 0x16, 0x00, 0x26, 0x7C, 0x43, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00,
    0x99, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 0x21,
    0x00, 0x00, 0x1F, 0x01, 0x1D, 0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4,
    0x8E, 0x21, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEA
#endif
};

// For OSD DP1.1/1.2 Setting
const BYTE EDID_DPRX_PORT2_NO_HDR[DP_EDID_MAX_SIZE] =
{
#if 1 // FHD 170
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x88,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x3A,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
    0x45,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x32,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0xB4,	0x1E,	0x53,	0x1E,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x0B,
    0x02,	0x03,	0x2E,	0xF1,	0x4F,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x3F,
    0x40,	0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,
    0x02,	0x03,	0x30,	0xB4,	0x00,	0x05,	0x61,	0x37,	0x58,	0x2F,	0xE3,	0x05,	0xC0,	0x01,	0x5B,	0xA4,
    0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,
    0x38,	0x8B,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,
    0x00,	0x1A,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x17,
#endif

#if 0 // FHD 175
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x88,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x3A,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x02,	0x3A,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x58,	0x2C,
    0x45,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x32,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0xB4,	0x1E,	0x53,	0x1E,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x0B,
    0x02,	0x03,	0x2E,	0xF1,	0x4F,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x3F,
    0x40,	0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,
    0x02,	0x03,	0x30,	0xB4,	0x00,	0x05,	0x61,	0x37,	0x58,	0x2F,	0xE3,	0x05,	0xC0,	0x01,	0x30,	0xA9,
    0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,	0x00,	0x1A,
    0x38,	0x8B,	0x80,	0x18,	0x71,	0x38,	0x2D,	0x40,	0x30,	0x20,	0x35,	0x00,	0x09,	0x25,	0x21,	0x00,
    0x00,	0x1A,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x3D,
#endif

#if 0 // QHD 100
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x36,	0x8B,	0x86,	0xA2,	0x28,	0x00,	0x00,	0x00,
    0x01,	0x1F,	0x01,	0x04,	0xB5,	0x80,	0x48,	0x78,	0x3A,	0x1E,	0x55,	0xA0,	0x59,	0x56,	0x9F,	0x27,
    0x0D,	0x50,	0x54,	0xBD,	0x4B,	0x00,	0xD1,	0xC0,	0x81,	0x80,	0x95,	0x0F,	0x95,	0x00,	0xB3,	0x00,
    0x81,	0xC0,	0x01,	0x01,	0x01,	0x01,	0x5B,	0x9D,	0x00,	0xA0,	0xA0,	0xA0,	0x29,	0x50,	0x30,	0x20,
    0x35,	0x00,	0xFD,	0x1E,	0x11,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x0A,	0x20,	0x20,
    0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x4D,
    0x54,	0x4B,	0x2D,	0x44,	0x50,	0x3A,	0x50,	0x32,	0x0A,	0x20,	0x20,	0x20,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x30,	0x64,	0x1E,	0x53,	0x11,	0x00,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x47,
    0x02,	0x03,	0x31,	0xF1,	0x4E,	0x01,	0x03,	0x04,	0x05,	0x07,	0x10,	0x12,	0x13,	0x1F,	0x27,	0x40,
    0x20,	0x21,	0x22,	0x23,	0x09,	0x17,	0x07,	0x83,	0x01,	0x00,	0x00,	0x6D,	0x1A,	0x00,	0x00,	0x02,
    0x03,	0x30,	0xB4,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0xE3,	0x05,	0xC0,	0x01,	0xE3,	0x0F,	0x20,
    0x04,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x5C,
#endif
};

//-------------------------------------------------------------------------------------------------
//  Local Functions Prototype
//-------------------------------------------------------------------------------------------------
void ________PROTOTYPE________(void);
void _mdrv_DPRx_MuxSelect(DPRx_ID dprx_id, DPRx_AUX_ID dprx_aux_id);
void _mdrv_DPRx_VSCPayload(DPRx_ID dprx_id, BYTE Payload);
BOOL _mdrv_DPRx_CheckInputTiming(DPRx_ID dprx_id);
void _mdrv_DPRx_NormalModeSetting(DPRx_ID dprx_id);
void _mdrv_DPRx_ShortHPD(DPRx_ID dprx_id);
void _mdrv_DPRx_LongHPD(DPRx_ID dprx_id);
BOOL _mdrv_DPRx_CheckVPLLBigChange(DPRx_ID dprx_id);
void _mdrv_DPRx_HPDPollingEvent(DPRx_ID dprx_id);
BOOL _mdrv_DPRx_StateHandler(DPRx_ID dprx_id);
void _mdrv_DPRx_Regen_Sync(DPRx_ID dprx_id);
void _mdrv_DPRx_StablePolling(DPRx_ID dprx_id);
void _mdrv_DPRx_PollingPacket(DPRx_ID dprx_id);
void _mdrv_DPRx_AudioHandler(DPRx_ID dprx_id);
void _mdrv_DPRx_CableDisconnectReset(DPRx_ID dprx_id);
void _mdrv_DPRx_CheckCableDetection(DPRx_ID dprx_id);
BOOL _mdrv_DPRx_CTSCheck(DPRx_ID dprx_id);
void _mdrv_DPRx_ClearFakeTrainingLockStatus(DPRx_ID dprx_id);
void _mdrv_DPRx_HDCPHandler(DPRx_ID dprx_id);
void _mdrv_DPRx_HDCP14Handler(DPRx_ID dprx_id);
void _mdrv_DPRx_HDCPThreeStepReauth(DPRx_ID dprx_id, DPRx_AUX_ID dprx_aux_id, DPRx_PHY_ID dprx_phy_id);
void _mdrv_DPRx_SetAudioMaskCount(DPRx_ID dprx_id);
BOOL _mdrv_DPRx_GetPacketReceived(DPRx_ID dprx_id, DPRx_DECODER_ID dprx_decoder_id);
#if (DPRX_HDCP2_ENABLE == 0x1)
BOOL _mdrv_DPRx_HDCP2GetRxData(DPRx_ID dprx_id, BYTE ucMessageID, BYTE *pHDCPData);
void _mdrv_DPRx_HDCP2SetTxData(DPRx_ID dprx_id, BYTE ucMessageID, BYTE *pHDCPData);
void _mdrv_DPRx_HDCP2Handler(DPRx_ID dprx_id);
#endif
void _mdrv_DPRx_MSCHIP_ScreenMute(void);
BYTE _mdrv_DPRx_MSCHIP_DPRxID2PortNumber(DPRx_ID dprx_id);
DPRx_AUX_ID _mdrv_DPRx_MSCHIP_DPRxID2AuxID(DPRx_ID dprx_id);
DPRx_DECODER_ID _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(DPRx_ID dprx_id);
DPRx_PHY_ID _mdrv_DPRx_MSCHIP_DPRxID2PhyID(DPRx_ID dprx_id);
DPRx_ID _mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(DPRx_ID dprx_id);
DPRx_ID _mdrv_DPRx_GetOnlineRxID(void);
extern void MuteVideoAndAudio(void);
void _mdrv_DPRx_Timer_variable_Reset(void);

//-------------------------------------------------------------------------------------------------
//  Local Functions
//-------------------------------------------------------------------------------------------------
//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_MuxSelect()
//  [Description]
//					_mdrv_DPRx_MuxSelect
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_MuxSelect(DPRx_ID dprx_id, DPRx_AUX_ID dprx_aux_id)
{
    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    mhal_DPRx_MuxSelect(dprx_id, dprx_aux_id);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_VSCPayload()
//  [Description]
//					_mdrv_DPRx_VSCPayload
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_VSCPayload(DPRx_ID dprx_id, BYTE Payload)
{
    BYTE ucFormat = Payload >> 4;
    BYTE ucPayload = Payload & 0x0F;
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    if(ucFormat == 0)
    {
        switch(ucPayload)
        {
            case 3:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_ADOBERBG;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_MAX;
                break;

            case 6:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_BT2020RGBYCbCr;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_EC;
                break;

            default:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_NONE;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_MAX;
                break;
        }
    }
    else
    {
        switch(ucPayload)
        {
            case 0:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_ITU601;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU601;
                break;

            case 1:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_ITU709;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU709;
                break;

            case 2:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_xvYCC601;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU601;
                break;

            case 3:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_xvYCC709;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU709;
                break;

            case 4:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_sYCC601;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU601;
                break;

            case 5:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_ADOBEYCC601;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU601;
                break;

            case 6:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_BT2020YcCbcCrc;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_EC;
                break;

            case 7:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_BT2020RGBYCbCr;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_EC;
                break;

            default:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_NONE;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_MAX;
                break;
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_CheckInputTiming()
//  [Description]
//					_mdrv_DPRx_CheckInputTiming
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL _mdrv_DPRx_CheckInputTiming(DPRx_ID dprx_id)
{
    BOOL XDATA bCheckFinish = FALSE;
    BOOL XDATA bInterlace = FALSE;
    BYTE XDATA uctemp = 0;
    DWORD XDATA ulPixelClock = 0;
    WORD XDATA usVTotal = 0;
    WORD XDATA usVWidth = 0;
    WORD XDATA usTimingInfo[DPRX_CHECK_TIMING_QUEUE_SIZE] = {0};
    BYTE XDATA ubStableTimes = 0x0;
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;

    // For freesync on, we should use regen timing SW mode
    WORD XDATA usBlank = 0;
    WORD XDATA usWidth = 0;
    WORD XDATA usFrontPorch = 0;
    WORD XDATA usBackPorch = 0;

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
        {
            // When VPLL big change, we need to re-check timing, so we can clear all VPLL big change events before we re-check timing actions.
            mhal_DPRx_ClrVideoBigChgFlag(dprx_decoder_id);
            glDPRxDecoderInfo[dprx_decoder_id].bDPVPLLBIGChange = FALSE;

            for(uctemp = 0; uctemp < DPRX_CHECK_TIMING_COUNTER; uctemp++)
            {
                ulPixelClock = mhal_DPRx_GetTimingPixelClock(dprx_id, dprx_decoder_id);

                bInterlace = mhal_DPRx_GetTimingInformation(dprx_decoder_id, usTimingInfo);

                glDPRxDecoderInfo[dprx_decoder_id].bDPInterlace = bInterlace;
                glDPRxDecoderInfo[dprx_decoder_id].uwDPHtotal = usTimingInfo[0];
                glDPRxDecoderInfo[dprx_decoder_id].uwDPHWidth = usTimingInfo[2];
                glDPRxDecoderInfo[dprx_decoder_id].uwDPVtotal = usTimingInfo[1];
                glDPRxDecoderInfo[dprx_decoder_id].uwDPVWidth = usTimingInfo[3];
                glDPRxDecoderInfo[dprx_decoder_id].uwDPPixel = ulPixelClock;

                if(bInterlace)
                {
                    usVTotal = usTimingInfo[1] << 1;
                    usVWidth = usTimingInfo[3] << 1;
                }
                else
                {
                    usVTotal = usTimingInfo[1];
                    usVWidth = usTimingInfo[3];
                }

                glDPRxDecoderInfo[dprx_decoder_id].uwDPHStart = usTimingInfo[4];
                glDPRxDecoderInfo[dprx_decoder_id].uwDPVStart = usTimingInfo[5];
                glDPRxDecoderInfo[dprx_decoder_id].uwDPHPWS = usTimingInfo[6] & 0x7FFF;
                glDPRxDecoderInfo[dprx_decoder_id].bDPHPol = (usTimingInfo[6] & BIT15)? TRUE : FALSE;
                glDPRxDecoderInfo[dprx_decoder_id].uwDPVPWS = usTimingInfo[7] & 0x7FFF;
                glDPRxDecoderInfo[dprx_decoder_id].bDPVPol = (usTimingInfo[7] & BIT15)? TRUE : FALSE;

                // For freesync on, we should use regen timing SW mode
                // V parameter
                usBlank = glDPRxDecoderInfo[dprx_decoder_id].uwDPVtotal - glDPRxDecoderInfo[dprx_decoder_id].uwDPVWidth;
                usWidth = usBlank / 2;
                usFrontPorch = (usBlank - usWidth) / 2;
                usBackPorch = usBlank - usWidth - usFrontPorch;

                usTimingInfo[0] = usWidth - 0x2; //RD suggest fix hsw = 2(> XC Limitation), If value is too large will impact hw mask hsync behavior when source send vblank is too small
                usTimingInfo[1] = usFrontPorch;
                usTimingInfo[2] = usBackPorch;

                if(usBlank < 0x400)
                {
                    if((glDPRxDecoderInfo[dprx_decoder_id].uwDPHWidth > 3000) || (glDPRxDecoderInfo[dprx_decoder_id].uwDPVWidth > 3000) || (glDPRxDecoderInfo[dprx_decoder_id].uwDPPixel > 300))
                    {
                        usWidth = 0x34;
                    }
                    else
                    {
                        usWidth = 0x2C;
                    }

                    usTimingInfo[3] = usWidth;

                    mhal_DPRx_RegenTimingInformation(dprx_decoder_id, usTimingInfo);
                }

                DP_DRV_DPRINTF("\r\nDP Input : Rx ID %d ", dprx_id);
                DP_DRV_DPRINTF("\r\nDP Input : Rx DecodeID %d ", dprx_decoder_id);
                DP_DRV_DPRINTF("\r\nDP Input : Pixel_Clock %d Mhz", ulPixelClock);
                DP_DRV_DPRINTF("\r\nDP Input : Link Rate  %d ", mhal_DPRx_GetLinkRate(dprx_id));
                DP_DRV_DPRINTF("\r\nDP Input : HTT  %d ", glDPRxDecoderInfo[dprx_decoder_id].uwDPHtotal);
                DP_DRV_DPRINTF("\r\nDP Input : VTT  %d ", glDPRxDecoderInfo[dprx_decoder_id].uwDPVtotal);
                DP_DRV_DPRINTF("\r\nDP Input : HDE  %d ", glDPRxDecoderInfo[dprx_decoder_id].uwDPHWidth);
                DP_DRV_DPRINTF("\r\nDP Input : VDE  %d ", glDPRxDecoderInfo[dprx_decoder_id].uwDPVWidth);

                if((glDPRxDecoderInfo[dprx_decoder_id].uwDPHWidth < DPRX_MAX_VALID_HDE) && (usVWidth < DPRX_MAX_VALID_VDE) &&
                   (glDPRxDecoderInfo[dprx_decoder_id].uwDPHWidth > DPRX_MIN_VALID_HDE) && (usVWidth > DPRX_MIN_VALID_VDE) &&
                   (ulPixelClock > DPRX_MIN_PIX_ClOCK) && (ulPixelClock < DPRX_MAX_PIX_ClOCK) &&
                   (glDPRxDecoderInfo[dprx_decoder_id].uwDPHtotal > glDPRxDecoderInfo[dprx_decoder_id].uwDPHWidth) && (usVTotal > usVWidth))
                {
                    ubStableTimes++;

                    // 1000ms/fps = (1000 / pixel clk * 1000000) * VTT * HTT
					glDPRxDecoderInfo[dprx_decoder_id].ulFrameTime = (DWORD)(glDPRxDecoderInfo[dprx_decoder_id].uwDPVtotal * glDPRxDecoderInfo[dprx_decoder_id].uwDPHtotal) / glDPRxDecoderInfo[dprx_decoder_id].uwDPPixel / 1000 + 1;

                    DP_DRV_DPRINTF("\r\n===> DP timing Pass: %x\r\n", 0);
                }
                else
                {
                    ubStableTimes = 0;

                    DP_DRV_DPRINTF( "\r\n===> DP timing Fail:%x \r\n", 0);
                    break;
                }
            }

            if(ubStableTimes == DPRX_CHECK_TIMING_COUNTER)
            {
                bCheckFinish = TRUE;
            }
        }
    }

    return bCheckFinish;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_NormalModeSetting()
//  [Description]
//					_mdrv_DPRx_NormalModeSetting
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_NormalModeSetting(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    BOOL XDATA FsynEnable = mhal_DPRx_GetDRRFlag(dprx_aux_id);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    if(FsynEnable)
    {
        mhal_DPRx_EnableLastHsyncAssert(dprx_decoder_id, TRUE);
        mhal_DPRx_EnableAutoInterlace(dprx_decoder_id, FALSE);
    }
    else
    {
        mhal_DPRx_EnableLastHsyncAssert(dprx_decoder_id, FALSE);
        mhal_DPRx_EnableAutoInterlace(dprx_decoder_id, TRUE);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_ShortHPD()
//  [Description]
//					_mdrv_DPRx_ShortHPD
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_ShortHPD(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_ID dprx_c_id = _mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id);
    WORD XDATA i = 0;

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    if(glDPRxInfo[dprx_id].bDPHpdState == FALSE)
    {
        return;
    }

    if(dprx_c_id != DPRx_ID_MAX)
    {
        glubTypeCShortHPD[dprx_c_id] = TRUE;
        return;
    }

    if(mhal_DPRx_IsHwHPDControlEnable(dprx_aux_id) == TRUE) // HW mode
    {
        for(i = 0x0; i < 0xA; i++)
        {
            if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
            {
                break;
            }

            mhal_DPRx_DELAY_NOP(300 + i*150);
        }

        if(mhal_DPRx_CheckHPDBusy(dprx_aux_id))
        {
            printf("** --- HPD event busy\r\n");
        }
        else
        {
            mhal_DPRx_HwShortHPDTrigger(dprx_aux_id);
        }
    }
    else // SW mode
    {
        for(i = 0x0; i < 0xA; i++)
        {
            if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
            {
                break;
            }

            mhal_DPRx_DELAY_NOP(300 + i*150);
        }

        mhal_DPRx_HPDControl(dprx_aux_id, FALSE);

        for(i = 0 ; i < (4 * 750); i++)
        {
            mhal_DPRx_DELAY_NOP(5);
        }

        mhal_DPRx_HPDControl(dprx_aux_id, TRUE);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_LongHPD()
//  [Description]
//					_mdrv_DPRx_LongHPD
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_LongHPD(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    WORD XDATA i = 0;

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    if(mhal_DPRx_CheckHPDBusy(dprx_aux_id))
    {
        printf("** --- HPD event busy\r\n");
    }
    else
    {
        for(i = 0x0; i < 0xA; i++)
        {
            if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
            {
                break;
            }

            mhal_DPRx_DELAY_NOP(300 + i*150);
        }

        mdrv_DPRx_HPDControl(dprx_id, FALSE);

        for (i = 0; i < 650; i++)
        {
            mhal_DPRx_DELAY_1ms();
        }

        mdrv_DPRx_HPDControl(dprx_id, TRUE);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_CheckVPLLBigChange()
//  [Description]
//					_mdrv_DPRx_CheckVPLLBigChange
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL _mdrv_DPRx_CheckVPLLBigChange(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;
    BOOL XDATA bVPLLBigChange = FALSE;

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        if(glDPRxDecoderInfo[dprx_decoder_id].bDPVPLLBIGChange)
        {
            if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
            {
                DP_DRV_DPRINTF("glDPRxInfo[dprx_id].bDPVPLLBIGChange = 0x%x\r\n", glDPRxDecoderInfo[dprx_decoder_id].bDPVPLLBIGChange);
                DP_DRV_DPRINTF("mhal_DPRx_CheckVPLLBigChange = 0x%x\r\n", mhal_DPRx_CheckVPLLBigChange(dprx_decoder_id));

                glDPRxDecoderInfo[dprx_decoder_id].bDPVPLLBIGChange = FALSE;
                bVPLLBigChange = TRUE;

                mhal_DPRx_UpdateMVIDValue(dprx_decoder_id);
                mhal_DPRx_ClrVideoBigChgFlag(dprx_decoder_id);

                //Tx send idle pattern, we will set bRxDecodeStable_R = FALSE
                {
                    glDPRxInfo[dprx_id].bRxDecodeStable = FALSE;
                }
            }
        }
    }

    return bVPLLBigChange;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_SetReferenceClock()
//  [Description]
//					_mdrv_DPRx_SetReferenceClock
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_SetReferenceClock(DPRx_ID dprx_id, DPRx_DECODER_ID dprx_decoder_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    BYTE XDATA usLSClock = mhal_DPRx_GetDPCDLinkRate(dprx_aux_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return;
    }

    switch(usLSClock)
    {
        case DP_LINKRATE_RBR:
            mhal_DPRx_SetReferenceClock(dprx_decoder_id, DPRX_RBR_REFERCLOCK);
            break;

        case DP_LINKRATE_HBR:
            mhal_DPRx_SetReferenceClock(dprx_decoder_id, DPRX_HBR_REFERCLOCK);
            break;

        case DP_LINKRATE_HBR2:
            mhal_DPRx_SetReferenceClock(dprx_decoder_id, DPRX_HBR2_REFERCLOCK);
            break;

        case DP_LINKRATE_HBR25:
            mhal_DPRx_SetReferenceClock(dprx_decoder_id, DPRX_HBR25_REFERCLOCK);
            break;

        case DP_LINKRATE_HBR3:
            mhal_DPRx_SetReferenceClock(dprx_decoder_id, DPRX_HBR3_REFERCLOCK);
            break;
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_HPDPollingEvent()
//  [Description]
//					_mdrv_DPRx_HPDPollingEvent
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_HPDPollingEvent(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);
    BOOL XDATA bTrainingFlag = mhal_DPRx_GetTrainingPatternFlag(dprx_id);
    DPRx_ID dprx_c_id = _mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id);
    static BYTE ubTimerOffset[DPRx_ID_MAX] = {0x0};

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    // HDCP Integrity
    if((!bTrainingFlag) && (mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort)) && (mhal_DPRx_GetHDCPIntegrity(dprx_id)))
    {
        if(glDPRxInfo[dprx_id].bDPHDCPIRQ == FALSE)
        {
            glDPRxInfo[dprx_id].bDPHDCPIRQ = TRUE;

            if(glDPRxInfo[dprx_id].uwHDCPCnt < 1000)
            {
                glDPRxInfo[dprx_id].uwHDCPCnt = 1000 + (ubTimerOffset[dprx_id] * 1000);
            }
        }
        else if(glDPRxInfo[dprx_id].uwHDCPCnt == 0)
        {
            DP_DRV_DPRINTF("** ---HDCPIntegrity HPD event %d", dprx_id);

            mhal_DPRx_SetCPIRQ(dprx_aux_id);
            _mdrv_DPRx_ShortHPD(dprx_id);

            glDPRxInfo[dprx_id].bDPHDCPIRQ = FALSE;

            ubTimerOffset[dprx_id]++;
        }
    }
    else
    {
        glDPRxInfo[dprx_id].bDPHDCPIRQ = FALSE;
        glDPRxInfo[dprx_id].uwHDCPCnt = 0;
        ubTimerOffset[dprx_id] = 0x0;
    }

    if(glDPRxInfo[dprx_id].bHDCPLongHPDTrigger == TRUE)
    {
        if(glDPRxInfo[dprx_id].ucHDCPLongHPDTimer == 0)
        {
            if(dprx_c_id != DPRx_ID_MAX)
            {
                glubTriggerTypeCHPDFlag[dprx_c_id] = TRUE;
                glubTypeCHPDCtrl[dprx_c_id] = TRUE;
            }
            else
            {
                mdrv_DPRx_HPDControl(dprx_id, TRUE);
            }

            glDPRxInfo[dprx_id].bHDCPLongHPDTrigger = FALSE;
            DP_DRV_DPUTSTR("****** Long HPD set high********\r\n");
        }
    }

    return;
}
//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_HDCPThreeStepReauth()
//  [Description]
//					_mdrv_DPRx_HDCPThreeStepReauth
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_HDCPThreeStepReauth(DPRx_ID dprx_id, DPRx_AUX_ID dprx_aux_id, DPRx_PHY_ID dprx_phy_id)
{
    DPRx_ID dprx_c_id = _mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    if((mhal_DPRx_CheckDPCDPowerState(dprx_aux_id) == FALSE) && (glDPRxInfo[dprx_id].ucHDCPThreeStepReauth == DPRx_HDCP_STEP3_HPDLONG))
    {
        glDPRxInfo[dprx_id].ucHDCPThreeStepReauth = DPRx_HDCP_STEP0_IDLE;
    }

    if(glDPRxInfo[dprx_id].ucHDCPThreeStepReauthTimer == 0)
    {
        switch(glDPRxInfo[dprx_id].ucHDCPThreeStepReauth)
        {
            case DPRx_HDCP_STEP1_INTEGRITYFAIL:
                if(mhal_DPRx_IsAuxAtOffLine(dprx_aux_id) == FALSE)
                {
                    // 1st short HPD: Force Integrity Fail
                    mhal_DPRx_ForceHDCP13IntegrityFail(dprx_id, TRUE);
                    mhal_DPRx_ForceHDCP22IntegrityFail(dprx_id, TRUE);
                    glDPRxInfo[dprx_id].bForceIntegrityFail = TRUE;
                    glDPRxInfo[dprx_id].uwHDCPCnt = 0xFFFF; // When force Integrity Fail, set HDCP fail check count as MAX value to avoid trigger CP_IRQ cycle
                    mhal_DPRx_HDCPLinkFailReset(dprx_id);
                    mhal_DPRx_HDCP14SoftReset(dprx_id);
                    mhal_DPRx_HDCP22SoftReset(dprx_id);
                    mhal_DPRx_SetCPIRQ(dprx_aux_id);
                    _mdrv_DPRx_ShortHPD(dprx_id);

                    glDPRxInfo[dprx_id].ucHDCPThreeStepReauth = DPRx_HDCP_STEP2_LOSELOCK;
                    glDPRxInfo[dprx_id].ucHDCPThreeStepReauthTimer = DPRX_HDCP_Step2_LoseLock_Timer;
                }
                break;

            case DPRx_HDCP_STEP2_LOSELOCK:
                if(mhal_DPRx_IsAuxAtOffLine(dprx_aux_id) == FALSE)
                {
                    // if not reauth after 1st step
                    // 2nd short HPD: Force Loss lock
                    if((glDPRxInfo[dprx_id].bHDCP22ReauthCheck == FALSE && glDPRxInfo[dprx_id].bHdcp14StartAuth == FALSE)||
                        (glDPRxInfo[dprx_id].bHDCP22ReauthCheck == TRUE && glDPRxInfo[dprx_id].bHdcp22StartAuth == FALSE))
                    {
                        mhal_DPRx_OverWriteDPCD202_203(dprx_id, TRUE, 0x0000);
                        glDPRxInfo[dprx_id].bOverWriteLockStatus = TRUE;
                        _mdrv_DPRx_ShortHPD(dprx_id);

                        glDPRxInfo[dprx_id].ucHDCPThreeStepReauth = DPRx_HDCP_STEP3_HPDLONG;
                        glDPRxInfo[dprx_id].ucHDCPThreeStepReauthTimer = DPRX_HDCP_Step3_HPDLong_Timer;
                    }
                    else
                    {
                        glDPRxInfo[dprx_id].ucHDCPThreeStepReauth = DPRx_HDCP_STEP0_IDLE;
                    }
                }
                break;

            case DPRx_HDCP_STEP3_HPDLONG:
                // if not training lock after 2nd step
                // 3rd pull long HPD
				glDPRxInfo[dprx_id].ucHDCPThreeStepReauth = DPRx_HDCP_STEP0_IDLE;

                if((mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort) == FALSE) ||
                    (glDPRxInfo[dprx_id].bHDCP22ReauthCheck == FALSE && glDPRxInfo[dprx_id].bHdcp14StartAuth == FALSE)||
                        (glDPRxInfo[dprx_id].bHDCP22ReauthCheck == TRUE && glDPRxInfo[dprx_id].bHdcp22StartAuth == FALSE))
                {
                    if(dprx_c_id != DPRx_ID_MAX)
                    {
                        glubTriggerTypeCHPDFlag[dprx_c_id] = TRUE;
                        glubTypeCHPDCtrl[dprx_c_id] = FALSE;
						mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, FALSE);
                        glDPRxInfo[dprx_id].bForceIntegrityFail = FALSE;
                        glDPRxInfo[dprx_id].ucHDCPLongHPDTimer = DPRX_HDCP14_LONGHPD_WDT;
                        glDPRxInfo[dprx_id].bHDCPLongHPDTrigger = TRUE;
                        glDPRxInfo[dprx_id].bDPLoseCDRLockIRQ = FALSE; // Avoid HPD conflict with CDR loss lock event
                    }
                    else
                    {
                        if(mdrv_DPRx_HPDControl(dprx_id, FALSE) == TRUE)
                        {
							mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, FALSE);
                            glDPRxInfo[dprx_id].bForceIntegrityFail = FALSE;
                            glDPRxInfo[dprx_id].ucHDCPLongHPDTimer = DPRX_HDCP14_LONGHPD_WDT;
                            glDPRxInfo[dprx_id].bHDCPLongHPDTrigger = TRUE;
                            glDPRxInfo[dprx_id].bDPLoseCDRLockIRQ = FALSE; // Avoid HPD conflict with CDR loss lock event
                        }
						else
						{
							glDPRxInfo[dprx_id].ucHDCPThreeStepReauth = DPRx_HDCP_STEP3_HPDLONG;
						}
                    }
                }
                break;

            default:
                break;
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_StateHandler()
//  [Description]
//					_mdrv_DPRx_StateHandler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL _mdrv_DPRx_StateHandler(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);
    BOOL XDATA bSignalStable = FALSE;
    BOOL XDATA bCDRLockFlag = mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort);
    DPRx_AudioStream DPRX_AUDIO_SELECT = mhal_DPRx_GetAudioStream(dprx_id);
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;
    //static BYTE ucUnStableTimes[DPRx_DECODER_ID_MAX] = {0};
    BYTE ubPM_DPCD202 = 0x0;
    BYTE ubCheckSquelchTimer = 0x0;
    BOOL bRxPortAtOffline = FALSE;
    DP_HDCP_STATE ubHDCPEncryptionState;
    WORD usMSAChgInterruptEvent = 0x0;

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    _mdrv_DPRx_HPDPollingEvent(dprx_id);
    mhal_DPRx_SQHOverwrite(dprx_id, TRUE);

    switch(glDPRxInfo[dprx_id].ucState)
    {
        case DPRx_STATE_STARTUP:
            DP_DRV_DPRINTF("\r\n** DP CDR lock check %d\r\n", dprx_id);

            glDPRxInfo[dprx_id].ucState = DPRx_STATE_CKECKLOCK;

            for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
            {
                if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
                {
                    glDPRxInfo[dprx_id].bRxDecodeStable = FALSE;
                }
            }
            break;

        case DPRx_STATE_CKECKLOCK:
            if(bCDRLockFlag)
            {
                glDPRxInfo[(BYTE)dprx_id].usFastTrainUnLockCheck = FALSE;

                if(mhal_DPRx_HWFastTrainingBusy_Get(dprx_id) == TRUE)
                {
                    // Fast train lock but data encryption, we have to start HDCP three step reauth
                    ubHDCPEncryptionState = mhal_DPRx_CheckHDCPEncryption(dprx_id);

                    if(ubHDCPEncryptionState != DP_HDCP_NO_ENCRYPTION)
                    {
                        if(((glDPRxInfo[dprx_id].decoderID_Info) & (BIT0 << DPRx_DECODER_ID_MAX)) != (BIT0 << DPRx_DECODER_ID_MAX)) // Check decoder allocate ready
                        {
                            if(glDPRxInfo[dprx_id].ucHDCPThreeStepReauth == DPRx_HDCP_STEP0_IDLE)
                            {
                                printf("******Fast train lock but data encryption, start HDCP three step reauth********\r\n");

                                if(ubHDCPEncryptionState == DP_HDCP_1_4)
                                {
                                    glDPRxInfo[dprx_id].bHDCP22ReauthCheck = FALSE;
                                }
                                else if(ubHDCPEncryptionState == DP_HDCP_2_2)
                                {
                                    glDPRxInfo[dprx_id].bHDCP22ReauthCheck = TRUE;
                                }

                                glDPRxInfo[dprx_id].ucHDCPThreeStepReauth = DPRx_HDCP_STEP1_INTEGRITYFAIL;
                                glDPRxInfo[dprx_id].ucHDCPThreeStepReauthTimer = DPRX_HDCP_Step1_IntegrityFail_Timer;
                            }
                        }

                        glDPRxInfo[dprx_id].DPCheckModeCnt = 0;
                        glDPRxInfo[dprx_id].ucState = DPRx_STATE_MEASURE;

                        DP_DRV_DPRINTF("\r\n** DP fast training lock check but data encryption-> measure! port %d\r\n", dprx_id);
                    }
                    else
                    {
                        glDPRxInfo[dprx_id].DPCheckModeCnt = 0;
                        glDPRxInfo[dprx_id].ucState = DPRx_STATE_MEASURE;

                        DP_DRV_DPRINTF("\r\n** DP fast training lock check -> measure! port %d\r\n", dprx_id);
                    }
                }
                else
                {
                    glDPRxInfo[dprx_id].DPCheckModeCnt = 0;
                    glDPRxInfo[dprx_id].ucState = DPRx_STATE_MEASURE;

                    DP_DRV_DPRINTF("** DP CDR lock check -> measure! port %d", dprx_id);
                }

                for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
                {
                    if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
                    {
                        _mdrv_DPRx_SetReferenceClock(dprx_id, dprx_decoder_id); // VPLL initial must before check input timing

                        glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable = TRUE; // Set bAudioEnable TRUE to run audio handler when lock
                    }
                }
            }
            else // Unlock & no SQ -> trigger short HPD
            {
                if((glDPRxInfo[dprx_id].bDPcableConnent == TRUE) && (glHPEllitePatchEnable[dprx_id] == TRUE)) // For HP Elite book issues patch code, the source would disable main link signal after wake-up training lock
                {
                    ubPM_DPCD202 = mhal_DPRx_GetFakeTrainingDPCD20x(dprx_aux_id, DPCD_00202);

                    if((ubPM_DPCD202 & 0x7) == 0x7) // During offline mode training lock but source disable signal detected, we need to trigger one short HPD
                    {
                        ubCheckSquelchTimer = 10;

                        while(ubCheckSquelchTimer > 0)
                        {
                            if(mhal_DPRx_CheckSquelch(dprx_id) != 0x0)
                            {
                                break;
                            }

                            mhal_DPRx_DELAY_1ms();
                            ubCheckSquelchTimer--;
                        }

                        if(ubCheckSquelchTimer == 0x0)
                        {
                            DP_DRV_DPUTSTR("******HP Elite book issues patch code, Unlock & no SQ -> trigger short HPD********\r\n");
                            bRxPortAtOffline = mhal_DPRx_IsAuxAtOffLine(dprx_aux_id);

                            // Clean fake training lock status, only software reset works, it need at offline mode
                            mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, TRUE);
                            _mdrv_DPRx_ClearFakeTrainingLockStatus(dprx_id);

                            if(bRxPortAtOffline == FALSE)
                            {
                                mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, FALSE);
                            }

                            _mdrv_DPRx_ShortHPD(dprx_id);
                            glHPEllitePatchEnable[dprx_id] = FALSE;
                        }
                        else
                        {
                            if(glDPRxInfo[dprx_id].usFastTrainUnLockCheck == FALSE)
                            {
                                if(mhal_DPRx_HWFastTrainingBusy_Get(dprx_id) == TRUE)
                                {
                                    glDPRxInfo[dprx_id].usFastTrainUnLockCheck = TRUE;
                                    glDPRxInfo[dprx_id].usFastTrainUnLockTimer = 1100; //T.B.D fast train timer +100 ms
                                }
                            }
                            else
                            {
                                if((glDPRxInfo[dprx_id].ucHDCPThreeStepReauthTimer == 0) && (glDPRxInfo[dprx_id].ucHDCPThreeStepReauth == DPRx_HDCP_STEP0_IDLE))
                                {

                                    glDPRxInfo[dprx_id].usFastTrainUnLockCheck = FALSE;
                                    glDPRxInfo[dprx_id].ucHDCPThreeStepReauth = DPRx_HDCP_STEP2_LOSELOCK;

        							// Clean fake training lock, only software reset works, it need at offline mode
        							mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, TRUE);
        							_mdrv_DPRx_ClearFakeTrainingLockStatus(dprx_id);

        							//This patch try to make Souce know "unlock", so no need to keep offline mode
        							mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, FALSE);

        							glHPEllitePatchEnable[dprx_id] = FALSE;
                                    DP_DRV_DPRINTF("******DP FLT Train Unlock Enter HPD step Recover********\r\n", dprx_id);
                                }
                            }
                        }


                    }
                }
            }

            if(mhal_DPRx_HWFastTrainingBusy_Get(dprx_id) == TRUE)
            {
                mhal_DPRx_SetCDRLossLockInterrupt(dprx_id, TRUE);
                mhal_DPRx_SetInterlaneSkewLoseInterrupt(dprx_id, TRUE);
                mhal_DPRx_SetInterlaneSkewDoneInterrupt(dprx_id, TRUE);
            }
            break;

        case DPRx_STATE_MEASURE:
            // HP Ellite book patch code, we need to make sure it would enter only one time when DPMS wake-up or AC on
            // So, when lock one time, we don'e need the patch code
            glHPEllitePatchEnable[dprx_id] = FALSE;

            if(_mdrv_DPRx_CheckInputTiming(dprx_id))
            {
                for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
                {
                    if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
                    {
                        mhal_DPRx_DecoderIsrDetectEnable(dprx_decoder_id, TRUE);

                        mhal_DPRx_UpdateMVIDValue(dprx_decoder_id);
                        mhal_DPRx_EnableAutoInterlace(dprx_decoder_id, TRUE);

                        if(mhal_DPRx_GetDRRFlag(dprx_aux_id) == TRUE)
                        {
                            mhal_DPRx_EnableVspHwRegen(dprx_decoder_id, FALSE);

                            // Adaptive sync/freesync should ignore VTT change
                            usMSAChgInterruptEvent = DPRx_MISC1|DPRx_MISC0|DPRx_VDE|DPRx_HDE|DPRx_HTT;
                            mhal_DPRx_MSAChgInterruptEvent_Enable(dprx_decoder_id, usMSAChgInterruptEvent);
                        }
                        else
                        {
                            mhal_DPRx_EnableVspHwRegen(dprx_decoder_id, TRUE);

                            usMSAChgInterruptEvent = DPRx_MISC1|DPRx_MISC0|DPRx_VDE|DPRx_HDE|DPRx_VTT|DPRx_HTT;
                            mhal_DPRx_MSAChgInterruptEvent_Enable(dprx_decoder_id, usMSAChgInterruptEvent);
                        }

                        if((mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_02210) & BIT1))
                        {
                            mhal_DPRx_EnableSEReplaceByBE(dprx_decoder_id, FALSE);
                        }
                        else
                        {
                            mhal_DPRx_EnableSEReplaceByBE(dprx_decoder_id, TRUE);
                        }

                        glDPRxDecoderInfo[dprx_decoder_id].bAudioMute = TRUE;
                        glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange = TRUE;
                        glDPRxDecoderInfo[dprx_decoder_id].DPAudioFreq = 0;
                        glDPRxDecoderInfo[dprx_decoder_id].ucAudioCTS_UCD400 = 0;
                        glucAudioPath[dprx_decoder_id] = TRUE;
                    }
                }

                glDPRxInfo[dprx_id].bDPTrainingFlag = FALSE;
                glDPRxInfo[dprx_id].bDPTrainingP1T = FALSE;
                glDPRxInfo[dprx_id].bDPTrainingP234T = FALSE;
                glDPRxInfo[dprx_id].bAudioRecoverCnt = DPRX_AUDIO_RECOVER_CNT;

                glDPRxInfo[dprx_id].ucState = DPRx_STATE_NORMAL;
                glDPRxInfo[dprx_id].uwDPRxStableTimeout = DPRX_STATE_STABLE_DEBOUNCE_TIME;

                DP_DRV_DPRINTF("\r\n** DP mode pass measure -> normal! port %d\r\n", dprx_id);
            }
            #if(DPRX_AUDIO_NOVIDEO == 0x1)
            else if((mhal_DPRx_IsVBIDVideoMute(_mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id), DPRX_AUDIO_CheckVideoMute_CNT) == TRUE) && (mhal_DPRx_IsVBIDAudioMute(_mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id), DPRX_AUDIO_CheckAudioMute_CNT) == FALSE))
            {
                glDPRxInfo[dprx_id].ucState = DPRx_STATE_NORMAL;

                for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
                {
                    if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
                    {
                        glDPRxDecoderInfo[dprx_decoder_id].ucAudioCTS_UCD400= 0;
                    }
                }

                DP_DRV_DPRINTF("** DP Audio out without video -> Normal! port %d", dprx_id);
            }
            #endif
            else if(glDPRxInfo[dprx_id].DPCheckModeCnt > DPRX_MEASURE_TIMING_COUNTER)
            {
                glDPRxInfo[dprx_id].ucState = DPRx_STATE_CKECKLOCK;

                DP_DRV_DPRINTF("\r\n** DP mode fail measure -> check! port %d\r\n", dprx_id);
            }
            else
            {
                glDPRxInfo[dprx_id].DPCheckModeCnt++;
            }
            break;

        case DPRx_STATE_NORMAL:
            if(!bCDRLockFlag)
            {
                for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
                {
                    if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
                    {
                        mhal_DPRx_DecoderIsrDetectEnable(dprx_decoder_id, FALSE);

                        glDPRxInfo[dprx_id].bRxDecodeStable = FALSE;
                        glDPRxInfo[dprx_id].uwDPRxStableTimeout = DPRX_STATE_STABLE_DEBOUNCE_TIME;
                    }
                }

                mhal_DPRx_HDCPLinkFailReset(dprx_id);
                mhal_DPRx_HDCP14SoftReset(dprx_id);
                mhal_DPRx_HDCP22SoftReset(dprx_id);
                mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, TRUE);

                glDPRxInfo[dprx_id].ucState = DPRx_STATE_CKECKLOCK;
                glDPRxInfo[dprx_id].bHdcp14StartAuth = FALSE;
                glDPRxInfo[dprx_id].bHdcp22StartAuth = FALSE;

                DP_DRV_DPRINTF("\r\n** DP loss lock normal -> check! port %d\r\n", dprx_id);
            }
            else if(_mdrv_DPRx_CheckVPLLBigChange(dprx_id))
            {
                glDPRxInfo[dprx_id].ucState = DPRx_STATE_MEASURE;
                glDPRxInfo[dprx_id].DPCheckModeCnt = 0;
                glDPRxInfo[dprx_id].uwDPRxStableTimeout = DPRX_STATE_STABLE_DEBOUNCE_TIME;
                mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, TRUE);
                glDPRxInfo[dprx_id].bHdcp14StartAuth = FALSE;
                glDPRxInfo[dprx_id].bHdcp22StartAuth = FALSE;

                DP_DRV_DPRINTF("\r\n** DP VPLL change normal -> measure! port %d\r\n", dprx_id);
            }
            else
            {
                for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
                {
                    if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
                    {
#if 1
                        glDPRxInfo[dprx_id].bRxDecodeStable = TRUE;
#else
                        // Avoid upstream data from garbage to normal, we have to output normal data
                        if(mhal_DPRx_IsInputStreamValid(dprx_decoder_id) == TRUE)
                        {
                            glDPRxInfo[dprx_id].bRxDecodeStable = TRUE;
                        }

                        if(glDPRxInfo[dprx_id].bRxDecodeStable == TRUE)
                        {
                            if(mhal_DPRx_GetHwHtotalLearningStable(dprx_aux_id, dprx_decoder_id) == FALSE)
                            {
                                if(ucUnStableTimes[dprx_decoder_id] < 10)
                                {
                                    ucUnStableTimes[dprx_decoder_id]++;
                                }
                            }
                            else
                            {
                                ucUnStableTimes[dprx_decoder_id] = 0;
                            }

                            if(ucUnStableTimes[dprx_decoder_id] == 10)
                            {
                                glDPRxInfo[dprx_id].bRxDecodeStable = FALSE;
                            }
                        }
#endif
                    }
                }

                _mdrv_DPRx_NormalModeSetting(dprx_id);
                _mdrv_DPRx_Regen_Sync(dprx_id);

                bSignalStable = TRUE;

                #if(DPRX_AUDIO_NOVIDEO == 0x1)
                if(mhal_DPRx_IsVBIDVideoMute(_mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id), DPRX_AUDIO_CheckVideoMute_CNT ) == TRUE)
                {
                    glDPRxInfo[dprx_id].ucState = DPRx_STATE_VIDEOMUTE;
                    glDPRxInfo[dprx_id].bDPNoVideoStrm = TRUE;

                    DP_DRV_DPRINTF("** DP normal -> VideoMute! port %d\r\n", dprx_id);
                }
                #endif
            }
            break;

#if(DPRX_AUDIO_NOVIDEO == 0x1)
            case DPRx_STATE_VIDEOMUTE:
                if(!bCDRLockFlag)
                {
                    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
                    {
                        if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
                        {
                            mhal_DPRx_DecoderIsrDetectEnable(dprx_decoder_id, FALSE);

                            glDPRxInfo[dprx_id].bRxDecodeStable = FALSE;
                            glDPRxInfo[dprx_id].uwDPRxStableTimeout = DPRX_STATE_STABLE_DEBOUNCE_TIME;
                        }
                    }

                    mhal_DPRx_HDCPLinkFailReset(dprx_id);
                    mhal_DPRx_HDCP14SoftReset(dprx_id);
                    mhal_DPRx_HDCP22SoftReset(dprx_id);
                    mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, TRUE);

                    glDPRxInfo[dprx_id].ucState = DPRx_STATE_CKECKLOCK;
                    glDPRxInfo[dprx_id].bHdcp14StartAuth = FALSE;
                    glDPRxInfo[dprx_id].bHdcp22StartAuth = FALSE;

                    DP_DRV_DPRINTF("\r\n** DP loss lock normal -> check! port %d\r\n", dprx_id);
                }
                else if(glDPRxInfo[dprx_id].bDPNoVideoStrm == FALSE)
                {
                    BYTE DPRX_AUDIO_SELECT = mhal_DPRx_GetAudioStream(dprx_id);

                    mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, TRUE);
                    mhal_DPRx_HDCPLinkFailReset(dprx_id);
                    glDPRxInfo[dprx_id].ucState = DPRx_STATE_MEASURE;

                    DP_DRV_DPRINTF("** DP videomute off -> measure! port %d", dprx_id);
                }
                else
                {
                    glDPRxInfo[dprx_id].bDPNoVideoStrm = mhal_DPRx_IsVBIDVideoMute(_mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id), DPRX_AUDIO_CheckVideoMute_CNT); // No Video
                    _mdrv_DPRx_AudioHandler(dprx_id);
                }
                break;
#endif

        default:
            break;
    }

    if(glDPRxInfo[dprx_id].ucPreState != glDPRxInfo[dprx_id].ucState)
    {
        glDPRxInfo[dprx_id].ucPreState = glDPRxInfo[dprx_id].ucState;

        if(glDPRxInfo[dprx_id].ucState == DPRx_STATE_CKECKLOCK)
        {
            for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
            {
                if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
                {
                    mhal_DPRx_UpdateAudioMNCode(dprx_decoder_id, 0, 0);
                }
            }
        }
    }

    return bSignalStable;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_Regen_Sync()
//  [Description]
//					_mdrv_DPRx_Regen_Sync
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_Regen_Sync(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    mhal_DPRx_EnableRegenSync(dprx_decoder_id, FALSE);
    mhal_DPRx_SetRegenSync(dprx_id, (BIT0 << dprx_id));

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_StablePolling()
//  [Description]
//					_mdrv_DPRx_StablePolling
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_StablePolling(DPRx_ID dprx_id)
{
    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    _mdrv_DPRx_PollingPacket(dprx_id);
    mdrv_DPRx_PollingColorimetry(dprx_id);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_PollingPacket()
//  [Description]
//					_mdrv_DPRx_PollingPacket
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_PollingPacket(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;
    static BYTE ucPrePacketTimer[DPRx_DECODER_ID_MAX] = {0};
    WORD usPacketStatusTemp;

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
        {
            if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketTimer == 0)
            {
                // 1000ms/fps = (1000 / pixel clk * 100000) * VTT * HTT
                if(glDPRxDecoderInfo[dprx_decoder_id].uwDPPixel != 0)
                {
                    glDPRxDecoderInfo[dprx_decoder_id].ucPacketTimer = glDPRxDecoderInfo[dprx_decoder_id].ulFrameTime;
                    ucPrePacketTimer[dprx_decoder_id] = glDPRxDecoderInfo[dprx_decoder_id].ucPacketTimer;
                }
                else
                {
                    glDPRxDecoderInfo[dprx_decoder_id].ucPacketTimer = ucPrePacketTimer[dprx_decoder_id];
                }

                usPacketStatusTemp = mhal_DPRx_GetPacketStatus(dprx_decoder_id);
                glDPRxDecoderInfo[dprx_decoder_id].ulInputPacketStatus |= usPacketStatusTemp;
                _mdrv_DPRx_GetPacketReceived(dprx_id, dprx_decoder_id);
            }
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_CableDisconnectReset()
//  [Description]
//					_mdrv_DPRx_CableDisconnectReset
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_CableDisconnectReset(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    BOOL bRxPortAtOffline = FALSE;
    DPRx_ID OnLine_dprx_id = _mdrv_DPRx_GetOnlineRxID();

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    DP_DRV_DPUTSTR("Rx cable disconnect Reset \r\n");

    glDPRxInfo[(BYTE)dprx_id].bHdcp14StartAuth = FALSE;
    glDPRxInfo[(BYTE)dprx_id].bHdcp22StartAuth = FALSE;

    if(dprx_id == OnLine_dprx_id)
    {
        glDPRxInfo[(BYTE)dprx_id].bOverWriteLockStatus = FALSE;
        mhal_DPRx_OverWriteDPCD202_203(dprx_id, FALSE, 0x0000);
    }
    mhal_DPRx_CableDisconectResetDPCD(dprx_id, dprx_aux_id);
    bRxPortAtOffline = mhal_DPRx_IsAuxAtOffLine(dprx_aux_id);

    // Clear fake training status need at DP offline mode
    mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, TRUE);
    _mdrv_DPRx_ClearFakeTrainingLockStatus(dprx_id);

    if(bRxPortAtOffline == FALSE)
    {
        mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, FALSE);
        mhal_DPRx_SetCDRLossLockInterrupt(dprx_id, FALSE);
        mhal_DPRx_SetInterlaneSkewLoseInterrupt(dprx_id, FALSE);
        mhal_DPRx_SetInterlaneSkewDoneInterrupt(dprx_id, FALSE);
    }

    glDPRxInfo[(BYTE)dprx_id].ucState = DPRx_STATE_STARTUP;
    glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable = FALSE;

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_CheckCableDetection()
//  [Description]
//					_mdrv_DPRx_CheckCableDetection
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_CheckCableDetection(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    static BYTE ubDisconnectDebouce[DPRx_ID_MAX] = {0x0};
    DPRx_ID OnLine_dprx_id = _mdrv_DPRx_GetOnlineRxID();

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

#if (SET_DPC_PORT_AS_DP_PORT == 0x0) // For DPRx_ID_2 is not DPC port case
    if(dprx_id != DPRx_ID_2) // DPRx_ID_2 is DPC port, cable detect is different from DP port
#endif
    {
        if(mhal_DPRx_CableGND_Level(dprx_aux_id) == FALSE) // GND detected
        {
            glDPRxInfo[dprx_id].bDPcableConnent = TRUE;
            ubDisconnectDebouce[dprx_id] = 0x0;
        }
        else
        {
            ubDisconnectDebouce[dprx_id]++;

            if((ubDisconnectDebouce[dprx_id] > 0x20) && (mhal_DPRx_AUX_N_Level(dprx_aux_id) == FALSE)) // Connect --> disconnect, double confirm AUX_N disappear
            {
                if(glDPRxInfo[dprx_id].bDPcableConnent == TRUE)
                {
                    _mdrv_DPRx_CableDisconnectReset(dprx_id);
                }

                if(dprx_id == OnLine_dprx_id)
                {
                    mhal_DPRx_OverWriteDPCD202_203(dprx_id, FALSE, 0x0000);
                    glDPRxInfo[dprx_id].bOverWriteLockStatus = FALSE;
                }

                glDPRxInfo[dprx_id].bDPcableConnent = FALSE;
            }
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_CTSCheck()
//  [Description]
//					_mdrv_DPRx_CTSCheck
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL _mdrv_DPRx_CTSCheck(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    BOOL XDATA bCTSFlag = FALSE;

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    if(glDPRxInfo[dprx_id].bDPAutoTestEn)
    {
        glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;

        mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);

        bCTSFlag = TRUE;

		if((glDPRxInfo[dprx_id].ubTypeC_PinAssign == BIT2)&& //pin C
			(glDPRxInfo[dprx_id].ubTypeC_CC != 0x2))
		{
			//T.B.D
		}
		else if((glDPRxInfo[dprx_id].ubTypeC_PinAssign == BIT3)&& //pin D
			(glDPRxInfo[dprx_id].ubTypeC_CC != 0x2))
		{
			if(glDPRxInfo[dprx_id].ubTypeC_CC == 0x0)
			{
				//T.B.D
			}
			else if(glDPRxInfo[dprx_id].ubTypeC_CC == 0x1)
			{
				//T.B.D
			}
		}
		else if((glDPRxInfo[dprx_id].ubTypeC_PinAssign == BIT4)&& //pin E
		(glDPRxInfo[dprx_id].ubTypeC_CC != 0x2))
		{
			//T.B.D
		}

        if(glDPRxInfo[dprx_id].DPVersion == DP_VERSION_11)
        {
            mhal_DPRx_SetInternalDPVersion(dprx_id, dprx_aux_id, 0x1, DP_VERSION_11); // DP_VERSION_11 is only for HW internal version, not DPCD value
        }
        else
        {
            mhal_DPRx_SetInternalDPVersion(dprx_id, dprx_aux_id, 0x4, DP_VERSION_14); // DP_VERSION_14 is only for HW internal version, not DPCD value
        }
    }
    else
    {
        // Default set to the highest supported DP version because of some HW restriction by DP version
        mhal_DPRx_SetInternalDPVersion(dprx_id, dprx_aux_id, 0x4, DP_VERSION_14);
    }

    return bCTSFlag;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_FakeTrainingLockStatus_Set()
//  [Description]
//					_mdrv_DPRx_FakeTrainingLockStatus_Set
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_FakeTrainingLockStatus_Set(DPRx_AUX_ID dprx_aux_id, BYTE ubLinkRate, BYTE ubLaneCount)
{
    if(dprx_aux_id == DPRx_AUX_ID_MAX)
    {
        return;
    }
    BYTE i = 0x0;
    BYTE ubState = 0x0;

    for(i = 0x0; i < 0x50; i++)
    {
        switch(ubState)
        {
            case 0:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00100, ubLinkRate);
                    ubState = 1;
                }
                break;

            case 1:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00101, ubLaneCount);
                    ubState = 2;
                }
                break;

            case 2:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00102, 0x21);
                    ubState = 3;
                }
                break;

            case 3:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00103, (Faketrain_pre << 3) + Faketrain_swing);
                    ubState = 4;
                }
                break;

            case 4:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00104, (Faketrain_pre << 3) + Faketrain_swing);
                    ubState = 5;
                }
                break;

            case 5:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00105, (Faketrain_pre << 3) + Faketrain_swing);
                    ubState = 6;
                }
                break;

            case 6:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00106, (Faketrain_pre << 3) + Faketrain_swing);
                    ubState = 7;
                }
                break;

            case 7:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00102, 0x23);
                    ubState = 8;
                }
                break;

            default:
                break;
        }

        if(ubState == 8)
        {
            break;
        }

        mhal_DPRx_DELAY_NOP(300 + i*150);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
// 				 	_mdrv_DP_ClearFakeTrainingLockStatus()
//  [Description]
//					_mdrv_DP_ClearFakeTrainingLockStatus
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_ClearFakeTrainingLockStatus(DPRx_ID dprx_id)
{
    BYTE i = 0x0;
    BYTE ubState = 0x0;
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    for(i = 0x0; i < 0x50; i++)
    {
        switch(ubState)
        {
            case 0:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00103, 0x0);
                    ubState = 1;
                }
                break;

            case 1:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00104, 0x0);
                    ubState = 2;
                }
                break;

            case 2:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00105, 0x0);
                    ubState = 3;
                }
                break;

            case 3:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00106, 0x0);
                    ubState = 4;
                }
                break;

            case 4:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00102, 0x1);
                    ubState = 5;
                }
                break;

            case 5:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00102, 0x0);
                    ubState = 6;
                }
                break;

            default:
                break;
        }

        if(ubState == 6)
        {
            break;
        }

        mhal_DPRx_DELAY_NOP(300 + i*150);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
// 				 	_mdrv_DPRX_InputPortType(void)
//  [Description]
//					_mdrv_DPRX_InputPortType
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE _mdrv_DPRX_InputPortType(void)
{
	if(INPUT_IS_DISPLAYPORT(SrcInputType) == TRUE)
	{
		return DP_INPUTPORT_IS_DP_PORT;
	}
	else if(INPUT_IS_USBTYPEC(SrcInputType) == TRUE)
	{
		return DP_INPUTPORT_IS_DPC_PORT;
	}
	else
	{
		return DP_INPUTPORT_IS_NONE;
	}
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_HDCPHandler()
//  [Description]
//					_mdrv_DPRx_HDCPHandler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_HDCPHandler(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    _mdrv_DPRx_HDCPThreeStepReauth(dprx_id, dprx_aux_id, dprx_phy_id);

#if (DPRX_HDCP2_ENABLE == 0x1)
    _mdrv_DPRx_HDCP2Handler((DPRx_ID)dprx_id);
#endif

#if 1//(DPRX_HDCP14_Repeater_ENABLE == 0x1)
    _mdrv_DPRx_HDCP14Handler((DPRx_ID)dprx_id);
#endif

    return;
}

#if 1//(DPRX_HDCP14_Repeater_ENABLE == 0x1)
//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_HDCP14Handler()
//  [Description]
//					_mdrv_DPRx_HDCP14Handler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_HDCP14Handler(DPRx_ID dprx_id)
{
    //DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    return;
}
#endif

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_MSCHIP_ScreenMute()
//  [Description]
//                  _mdrv_DPRx_MSCHIP_ScreenMute
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_MSCHIP_ScreenMute(void)
{
    if((INPUT_IS_DISPLAYPORT(SrcInputType) == TRUE) || (INPUT_IS_USBTYPEC(SrcInputType) == TRUE))
    {
        MuteVideoAndAudio();
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_MSCHIP_DPRxID2PortNumber()
//  [Description]
//					_mdrv_DPRx_MSCHIP_DPRxID2PortNumber
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE _mdrv_DPRx_MSCHIP_DPRxID2PortNumber(DPRx_ID dprx_id)
{
    #if (FPGA_Verification == 1)
        return Input_Displayport_C1; //MT9701 FPGA board define
    #endif
    if(dprx_id == DPRx_ID_MAX)
    {
        return Input_Nothing;
    }

    switch(dprx_id)
    {
        case DPRx_ID_0:
            return Input_Displayport_C1;
            break;

        case DPRx_ID_1:
            return Input_Displayport_C2;
            break;

        case DPRx_ID_2:
            if(Input_Displayport_C3 != Input_Nothing)
            {
                return Input_Displayport_C3;
            }
            else
            {
                return Input_UsbTypeC_C3;
            }
            break;

        default:
            return Input_Nothing;
            break;
    }

    return Input_Nothing;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID()
//  [Description]
//					_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
DPRx_ID _mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(DPRx_ID dprx_id)
{
    if(Input_UsbTypeC3 != Input_Nothing)
    {
        if((dprx_id >= DPRx_ID_2) && (dprx_id < DPRx_ID_MAX))
        {
            return (dprx_id - DPRx_ID_2);
        }
    }

    return DPRx_ID_MAX;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_GetOnlineRxID()
//  [Description]
//					_mdrv_DPRx_GetOnlineRxID
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
DPRx_ID _mdrv_DPRx_GetOnlineRxID(void)
{
    #if (FPGA_Verification == 1)
        return DPRx_ID_0; // MT9701 FPGA board define
    #endif

    if((Input_Displayport_C1 != Input_Nothing) && ((SrcInputType == Input_Displayport_C1)))
    {
        return DPRx_ID_0;
    }
    else if((Input_Displayport_C2 != Input_Nothing) && (SrcInputType == Input_Displayport_C2))
    {
        return DPRx_ID_1;
    }
    else if((Input_Displayport_C3 != Input_Nothing) && ((SrcInputType == Input_Displayport_C3)))
    {
        return DPRx_ID_2;
    }
    else if((Input_UsbTypeC3 != Input_Nothing) && ((SrcInputType == Input_UsbTypeC3)))
    {
        return DPRx_ID_2;
    }
    else
    {
        return DPRx_ID_MAX;
    }

    return DPRx_ID_MAX;
}

void ________INIT________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_Initial()
//  [Description]
//					mdrv_DPRx_Initial
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_Initial(void)
{
    DPRx_ID dprx_id = DPRx_ID_MAX;
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    DPRx_PHY_ID dprx_phy_id = DPRx_PHY_ID_MAX;
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;

    msEread_Init(&usInfo1, &ubInfo2);
    mdrv_DPRx_InitValue();
    mhal_DPRx_EDIDOffsetSetting();
    mhal_DPRx_SetAuxClockGating(FALSE);

    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        mhal_DPRx_Initial_Decoder(dprx_decoder_id);
    }

    for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
    {
        dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
        dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

        if(GET_DPRx_FUNCTION_ENABLE_PORT(dprx_id))
        {
            /*
            if(dprx_id == DPRx_ID_0)
            {
                mhal_DPRx_Load_EDID(dprx_id, dprx_aux_id, EDID_DPRX_PORT0);
            }
            else if(dprx_id == DPRx_ID_1)
            {
                mhal_DPRx_Load_EDID(dprx_id, dprx_aux_id, EDID_DPRX_PORT1);
            }
            else if(dprx_id == DPRx_ID_2)
            {
                mhal_DPRx_Load_EDID(dprx_id, dprx_aux_id, EDID_DPRX_PORT2);
            }
            */

            printf("[DPRx] dprx_id => %x \r\n", dprx_id);
            printf("[DPRx] dprx_aux_id => %x \r\n", dprx_aux_id);
            printf("[DPRx] dprx_phy_id => %x \r\n", dprx_phy_id);

            mhal_DPRx_Initial(dprx_id, dprx_aux_id, dprx_phy_id);

            if(_mdrv_DPRx_MSCHIP_DPRxID2PortNumber(dprx_id) == Input_UsbTypeC_C3)
            {
                mhal_DPRx_SetHwHPDControlEnable(dprx_aux_id, FALSE);
            }
            else
            {
                mhal_DPRx_SetHwHPDControlEnable(dprx_aux_id, TRUE);
            }

            if(dprx_id == DPRx_ID_2)
            {
                mhal_DPRx_PHYPowerModeSetting(mhal_ePM_POWEROFF, dprx_id, DPRx_PHY_ID_1);
            }
            else
            {
                mhal_DPRx_PHYPowerModeSetting(mhal_ePM_POWEROFF, dprx_id, DPRx_PHY_ID_0);
            }

            #if (DP_RX_FT_TIMER_A_WAIT_SQ_SIGNAL == 0x0)
            mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);
            #endif

            glHPEllitePatchEnable[dprx_id] = TRUE;
        }
        else
        {
            // Search invalid AUX_ID for power down setting
            mhal_DPRx_SetPowerDownControl(DPRx_ID_MAX, dprx_aux_id, DP_ePM_POWEROFF_NoUsedPort);
            glHPEllitePatchEnable[dprx_id] = FALSE;
        }
    }

    mdrv_DPRx_SetAuxPMClock(TRUE); // Set PM Aux clock to Xtal need after aux initial

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_InitValue()
//  [Description]
//					mdrv_DPRx_InitValue
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_InitValue(void)
{
    DPRx_ID dprx_id = DPRx_ID_MAX;
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;

    glLastRxID = 0xFF;

    memset(&glDPRxInfo, 0, sizeof(glDPRxInfo));

    for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
    {
        glDPRxInfo[dprx_id].ucState = DPRx_STATE_STARTUP;
        glDPRxInfo[dprx_id].decoderID_Info = (BIT0 << DPRx_DECODER_ID_0);
        glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;
        glDPRxInfo[dprx_id].OnlinePort = DPRx_ID_MAX;
        glTypeC_PhyLaneSwap[dprx_id] = 0xE4;
    }

    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable = TRUE;
    }

    if(Input_Displayport_C1 != Input_Nothing)
    {
        ucDPFunctionEnableIndex |= BIT0;
    }

    if(Input_Displayport_C2 != Input_Nothing)
    {
        ucDPFunctionEnableIndex |= BIT1;
    }

    if(Input_Displayport_C3 != Input_Nothing || (Input_UsbTypeC_C3 != Input_Nothing))
    {
        ucDPFunctionEnableIndex |= BIT2;
    }

    ucDPTPCFunctionEnableIndex = 0; // T.B.D

    printf("[DPRx] ucDPFunctionEnableIndex => %x \r\n", ucDPFunctionEnableIndex);
    printf("[DPRx] ucDPTPCFunctionEnableIndex => %x \r\n", ucDPTPCFunctionEnableIndex);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRX_PortConfigSetting()
//  [Description]
//					mdrv_DPRX_PortConfigSetting
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRX_PortConfigSetting(BYTE *ucDPFunctionPtr, BYTE *ucDPTPCFunctionPtr)
{
    // DP port check
    if(Input_Displayport_C1 != Input_Nothing)
    {
        *ucDPFunctionPtr |= BIT0;
    }

    if(Input_Displayport_C2 != Input_Nothing)
    {
        *ucDPFunctionPtr |= BIT1;
    }

    if(Input_Displayport_C3 != Input_Nothing)
    {
        *ucDPFunctionPtr |= BIT2;
    }

    // TpyeC port check
    if(Input_UsbTypeC_C3 != Input_Nothing)
    {
        *ucDPTPCFunctionPtr |= DP_TYPEC_PORT0;
        *ucDPFunctionPtr |= BIT3;
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_VersionSetting()
//  [Description]
//					mdrv_DPRx_VersionSetting
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_VersionSetting(DPRx_ID dprx_id, BYTE ucVersion)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    glDPRxInfo[dprx_id].DPVersion = ucVersion;

    mhal_DPRx_VersionSetting(dprx_aux_id, ucVersion);

    #if (DP_VESA_ADAPTIVE_SYNC_SDP_SUPPORT == 0x01)
	if(ucVersion >= DP_VERSION_14)
	{
		mdrv_DPRx_SetVESA_AdaptiveSyncEanble(dprx_id, TRUE);
	}
	else
	{
		mdrv_DPRx_SetVESA_AdaptiveSyncEanble(dprx_id, FALSE);
	}
	#endif

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetupInputPort_DisplayPort()
//  [Description]
//					mdrv_DPRx_SetupInputPort_DisplayPort
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetupInputPort_DisplayPort(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    
    BYTE ubCheckAuxIdleTimes;
    BYTE ubLinkRate;
    BYTE ubLaneCount;

    // Avoid waste time to do the same settings
    if(dprx_id != DPRx_ID_MAX)
    {
        mhal_DPRx_OverWriteDPCD202_203(dprx_id, FALSE, 0x0000);
        glDPRxInfo[dprx_id].bOverWriteLockStatus = FALSE;
        glDPRxInfo[dprx_id].OnlinePort = dprx_id;
    }

    if((glLastRxID == dprx_id) || (dprx_id == DPRx_ID_MAX))
    {
        return;
    }

    ubCheckAuxIdleTimes = 0x0;

    while(ubCheckAuxIdleTimes < 10)
    {
        if(mhal_DPRx_GetAuxValid(dprx_aux_id) == FALSE) // Aux idle
        {
            break;
        }

        mhal_DPRx_DELAY_NOP(100 + (ubCheckAuxIdleTimes * 70));

        ubCheckAuxIdleTimes++;
    }

    // Disable interrupt during switch port
    mhal_DPRx_DecoderIsrDetectEnable(dprx_decoder_id, FALSE);
    mhal_DPRx_EnableReceiverInterrupt(dprx_id, FALSE);
    mhal_DPRx_SetCDRLossLockInterrupt(dprx_id, FALSE);
    mhal_DPRx_SetInterlaneSkewLoseInterrupt(dprx_id, FALSE);
    mhal_DPRx_SetInterlaneSkewDoneInterrupt(dprx_id, FALSE);

    // Check have been do HDCP14 on offline port, if yes request Tx do reauth
    if((mhal_DPRx_GetProgramDPCD8Flag(dprx_aux_id) == TRUE) || (glDPRxInfo[dprx_id].bHdcp22AuthinOffline == TRUE))
    {
        if(glDPRxInfo[dprx_id].ucHDCPThreeStepReauth == DPRx_HDCP_STEP0_IDLE)
        {
            printf("******HDCP22 auth during offline start HDCP three step reauth********\r\n");
            glDPRxInfo[dprx_id].ucHDCPThreeStepReauth = DPRx_HDCP_STEP1_INTEGRITYFAIL;
            glDPRxInfo[dprx_id].ucHDCPThreeStepReauthTimer = DPRX_HDCP_Step1_IntegrityFail_Timer;
            glDPRxInfo[dprx_id].bHDCP22ReauthCheck = TRUE;
            glDPRxInfo[dprx_id].bHdcp22AuthinOffline = FALSE;
        }
    }
    else if((mhal_DPRx_HDCP14CheckAKSVStatus(dprx_aux_id)) || (mhal_DPRx_HDCP14CheckAnStatus(dprx_aux_id)))
    {
        if(glDPRxInfo[dprx_id].ucHDCPThreeStepReauth == DPRx_HDCP_STEP0_IDLE)
        {
            printf("******HDCP14 auth during offline start HDCP three step reauth********\r\n");
            glDPRxInfo[dprx_id].ucHDCPThreeStepReauth = DPRx_HDCP_STEP1_INTEGRITYFAIL;
            glDPRxInfo[dprx_id].ucHDCPThreeStepReauthTimer = DPRX_HDCP_Step1_IntegrityFail_Timer;
            glDPRxInfo[dprx_id].bHDCP22ReauthCheck = FALSE;
        }
    }

    if(glLastRxID != 0xFF)
    {
        if(glLastRxID == DPRx_ID_2)
        {
            mhal_DPRx_PHYPowerModeSetting(mhal_ePM_STANDBY, glLastRxID, DPRx_PHY_ID_1);
        }
        else
        {
            mhal_DPRx_PHYPowerModeSetting(mhal_ePM_STANDBY, glLastRxID, DPRx_PHY_ID_0);
        }
    }

    if(dprx_id == DPRx_ID_2)
    {
        mhal_DPRx_PHYPowerModeSetting(mhal_ePM_POWERON, dprx_id, DPRx_PHY_ID_1);
    }
    else
    {
        mhal_DPRx_PHYPowerModeSetting(mhal_ePM_POWERON, dprx_id, DPRx_PHY_ID_0);
    }

    mhal_DPRx_HWFastTrainingEnable(dprx_id, TRUE);

    if(dprx_id == DPRx_ID_2)
    {
    	#if((SET_DPC_PORT_AS_DP_PORT == 0x1) && (SET_DP_C3_LANE023_PN_SWAP == 0x1))
		mhal_DPRx_LanePNSwapEnable_Set(dprx_id, BIT0|BIT2|BIT3);
        #elif(SET_DPC_PORT_AS_DP_PORT == 0x0)
        mdrv_DPRx_SetDataLaneSettings(dprx_id, TRUE, glTypeC_PhyLaneSwap[dprx_id]);
        #endif
    }
    else
    {
		mhal_DPRx_LanePNSwapEnable_Set(dprx_id, 0);
    }

    if(glLastRxID != 0xFF)
    {
        if((mhal_DPRx_GetDPCDValueByRIU(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPCD_00202) & 0x0F) != 0x7) // online -> offline
        {
            mhal_DPRx_SetOffLine(glLastRxID, _mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), TRUE);
            _mdrv_DPRx_ClearFakeTrainingLockStatus(glLastRxID);
        }
        else
        {
            ubLinkRate = mhal_DPRx_GetDPCDValueByRIU(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPCD_00100);
            ubLaneCount = mhal_DPRx_GetDPCDValueByRIU(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPCD_00101);
            mhal_DPRx_SetOffLine(glLastRxID, _mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), TRUE);
            _mdrv_DPRx_FakeTrainingLockStatus_Set(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), ubLinkRate, ubLaneCount);
        }

		glDPRxInfo[glLastRxID].bHdcp14StartAuth = FALSE;
        glDPRxInfo[glLastRxID].bHdcp22StartAuth = FALSE;
        glDPRxInfo[glLastRxID].bHdcp22AuthinOffline = FALSE;
        mhal_DPRx_SetProgrammableDPCDEnable(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), FALSE);
        // offline port detect HDCP22
        mhal_DPRx_SetProgramDPCD(TRUE, _mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPRx_PROGRAM_DPCD_8, DPRX_PROGRAM_DPCD8_ADDERSS, FALSE);
        mhal_DPRx_SetProgramDPCDInterrupt(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPRx_PROGRAM_DPCD_8, TRUE);
    }

    mhal_DPRx_SetupInputPort(dprx_id, dprx_aux_id, TRUE);
    _mdrv_DPRx_MuxSelect(dprx_id, dprx_aux_id);

    mhal_DPRx_ResetAsyncFIFO(dprx_id, dprx_aux_id);
    mhal_DPRx_SetProgrammableDPCDEnable(dprx_aux_id, TRUE);

    #if (DPRX_HDCP2_ENABLE == 1)
    mhal_DPRx_SetXDATAProgrammableDPCDEnable(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPRx_XDATAPROGRAM_DPCD_0, TRUE, FALSE);
    mhal_DPRx_SetXDATAProgrammableDPCDEnable(dprx_aux_id, DPRx_XDATAPROGRAM_DPCD_0, FALSE, FALSE);
    #else
    mhal_DPRx_SetXDATAProgrammableDPCDEnable(dprx_aux_id, DPRx_XDATAPROGRAM_DPCD_0, TRUE, TRUE);
    #endif

    #if (DP_XDATA_PROGRAMMABLE_DPCD_MCCS == 1)
    mhal_DPRx_SetXDATAProgrammableDPCDEnable(dprx_aux_id, DPRx_XDATAPROGRAM_DPCD_1, FALSE, FALSE);
    #else
    mhal_DPRx_SetXDATAProgrammableDPCDEnable(dprx_aux_id, DPRx_XDATAPROGRAM_DPCD_1, TRUE, TRUE);
    #endif

    if((mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_00202) & 0x0F) != 0x7) // offline -> online
    {
        mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, FALSE); //ov non_pm 202 203
    }
    else
    {
	    #if (DPRX_OFFLINE_TO_ONLINE_KEEP_LOCK == 0x1)
         //keep offline wait fast train
		#else
		mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, FALSE);
		#endif
    }

    mhal_DPRx_SetGPIOforAUX(dprx_aux_id, TRUE);

    // Enable interrupt after switch port
	mhal_DPRx_EnableReceiverInterrupt(dprx_id, TRUE);

    glLastRxID = dprx_id;

    if(dprx_id == DPRx_ID_MAX) // For non DP port case, all port set offline
    {
        glLastRxID = 0xFF;
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_Switch_Port_Check()
//  [Description]
//					mdrv_DPRx_Switch_Port_Check
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_Switch_Port_Check(void)
{
    BYTE ubLinkRate;
    BYTE ubLaneCount;

    if(glLastRxID != 0xFF)
    {
        mhal_DPRx_HWFastTrainingEnable(glLastRxID, FALSE);

        if((mhal_DPRx_GetDPCDValueByRIU(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPCD_00202) & 0x0F) != 0x7) // online -> offline
        {
            mhal_DPRx_SetOffLine(glLastRxID, _mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), TRUE);
            _mdrv_DPRx_ClearFakeTrainingLockStatus(glLastRxID);
        }
        else
        {
            ubLinkRate = mhal_DPRx_GetDPCDValueByRIU(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPCD_00100);
            ubLaneCount = mhal_DPRx_GetDPCDValueByRIU(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPCD_00101);
            mhal_DPRx_SetOffLine(glLastRxID, _mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), TRUE);
            _mdrv_DPRx_FakeTrainingLockStatus_Set(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), ubLinkRate, ubLaneCount);
        }

        if(glLastRxID == DPRx_ID_2)
        {
            mhal_DPRx_PHYPowerModeSetting(mhal_ePM_STANDBY, glLastRxID, DPRx_PHY_ID_1);
        }
        else
        {
            mhal_DPRx_PHYPowerModeSetting(mhal_ePM_STANDBY, glLastRxID, DPRx_PHY_ID_0);
        }

        #if (DPRX_HDCP2_ENABLE == 1)
        mhal_DPRx_SetXDATAProgrammableDPCDEnable(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPRx_XDATAPROGRAM_DPCD_0, TRUE, FALSE);
        #endif

        glDPRxInfo[glLastRxID].bHdcp14StartAuth = FALSE;
        glDPRxInfo[glLastRxID].bHdcp22StartAuth = FALSE;
        glDPRxInfo[glLastRxID].OnlinePort = DPRx_ID_MAX;
        glLastRxID = 0xFF;
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_Not_DisplayPort()
//  [Description]
//					mdrv_DPRx_Not_DisplayPort
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_Not_DisplayPort(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;

    for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
    {
        dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
        dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

        glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;
        glDPRxInfo[dprx_id].OnlinePort = DPRx_ID_MAX;

        mhal_DPRx_SetupInputPort(dprx_id, dprx_aux_id, FALSE);

        #if (DP_RX_FT_TIMER_A_WAIT_SQ_SIGNAL == 0x0)
        mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);
        #endif

        mhal_DPRx_SetProgrammableDPCDEnable(dprx_aux_id, FALSE);
        #if (DPRX_HDCP2_ENABLE == 1)
		mhal_DPRx_ProgramDPCDEnable(dprx_aux_id, DPRx_PROGRAM_DPCD_8, TRUE);
        #else
        mhal_DPRx_SetXDATAProgrammableDPCDEnable(dprx_aux_id, DPRx_XDATAPROGRAM_DPCD_0, FALSE, FALSE);
        #endif
        mhal_DPRx_SetXDATAProgrammableDPCDEnable(dprx_aux_id, DPRx_XDATAPROGRAM_DPCD_1, FALSE, FALSE);

        // Disable interrupt for non-DP port
        mhal_DPRx_DecoderIsrDetectEnable(dprx_decoder_id, FALSE);
        mhal_DPRx_EnableReceiverInterrupt(dprx_id, FALSE);
        mhal_DPRx_SetCDRLossLockInterrupt(dprx_id, FALSE);
        mhal_DPRx_SetInterlaneSkewLoseInterrupt(dprx_id, FALSE);
        mhal_DPRx_SetInterlaneSkewDoneInterrupt(dprx_id, FALSE);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_AUX_N_Level()
//  [Description]
//					mdrv_DPRx_AUX_N_Level
//  [Arguments]:
//
//  [Return]:   	1: Cable connect
//					0: Cable disconnect
//
//**************************************************************************
BOOL mdrv_DPRx_AUX_N_Level(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    switch(dprx_id)
    {
        case DPRx_ID_0:
            return mhal_DPRx_AUX_N_Level(dprx_aux_id);;

        case DPRx_ID_1:
            return mhal_DPRx_AUX_N_Level(dprx_aux_id);

        case DPRx_ID_2:
#if(SET_DPC_PORT_AS_DP_PORT == 0x0) // For DPRx_ID_2 is not DPC port case
            return mhal_DPRx_TypeC_AUX_N_Level(dprx_id, glDPRxInfo[dprx_id].ubTypeC_PinAssign, glDPRxInfo[dprx_id].ubTypeC_CC);
#else
            return mhal_DPRx_AUX_N_Level(dprx_aux_id);
#endif

        default:
            return FALSE;
    }

    return FALSE;
}

void ________VIDEO________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetLaneCount()
//  [Description]
//					mdrv_DPRx_SetLaneCount
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetLaneCount(DPRx_ID dprx_id, BYTE ubLaneCount)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    BYTE uctemp = 0;

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    if((ubLaneCount == DP_LANECOUNT_1) || (ubLaneCount == DP_LANECOUNT_2) || (ubLaneCount == DP_LANECOUNT_4))
    {
        uctemp = ((mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_00002) & 0xE0) | ubLaneCount);
        mhal_DPRx_SetDPCDValueByRIU(dprx_aux_id, DPCD_00002, uctemp, DPRx_RIU_DPCD_Auto);

        uctemp = ((mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_02202) & 0xE0) | ubLaneCount);
        mhal_DPRx_SetDPCDValueByRIU(dprx_aux_id, DPCD_02202, uctemp, DPRx_RIU_DPCD_Auto);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetDPVersion()
//  [Description]
//					mdrv_DPRx_GetDPVersion
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_GetDPVersion(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if(dprx_id == DPRx_ID_MAX)
    {
        return 0x0;
    }

    return mhal_DPRx_DPCDVersion_Get(dprx_aux_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetDPCDLinkRate()
//  [Description]
//					mdrv_DPRx_GetDPCDLinkRate
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_GetDPCDLinkRate(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    WORD ucLockStatus;

    if(dprx_id == DPRx_ID_MAX)
    {
        return 0;
    }

    ucLockStatus = ((mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_00203) << 8) | mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_00202));

    if(ucLockStatus != 0x7 && ucLockStatus != 0x77 && ucLockStatus != 0x7777)
    {
        return 0;
    }

    return mhal_DPRx_GetDPCDLinkRate(dprx_aux_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetDPLaneCnt()
//  [Description]
//					mdrv_DPRx_GetDPLaneCnt
//  [Arguments]:
//
//	[Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_GetDPLaneCnt(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    WORD ucLockStatus;

    if(dprx_id == DPRx_ID_MAX)
    {
        return 0;
    }

    ucLockStatus = ((mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_00203) << 8) | mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_00202));

    if(ucLockStatus != 0x7 && ucLockStatus != 0x77 && ucLockStatus != 0x7777)
    {
        return 0;
    }

    return mhal_DPRx_GetDPLaneCnt(dprx_aux_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetHVInformation()
//  [Description]
//					mdrv_DPRx_GetHVInformation
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_GetHVInformation(DPRx_ID dprx_id, WORD *usHTotalValue, WORD *usVTotalValue)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return;
    }

    *usHTotalValue = glDPRxDecoderInfo[dprx_decoder_id].uwDPHtotal;
    *usVTotalValue = glDPRxDecoderInfo[dprx_decoder_id].uwDPVtotal;

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetHVDEInformation()
//  [Description]
//					mdrv_DPRx_GetHVDEInformation
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_GetHVDEInformation(DPRx_ID dprx_id, WORD *usHDE, WORD *usVDE)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return;
    }

    *usHDE = glDPRxDecoderInfo[dprx_decoder_id].uwDPHWidth;
    *usVDE = glDPRxDecoderInfo[dprx_decoder_id].uwDPVWidth;

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetPixelClock()
//  [Description]
//					mdrv_DPRx_GetPixelClock
//  [Arguments]:
//
//  [Return]:
//                  Pixel clock = xxx MHz
//**************************************************************************
WORD mdrv_DPRx_GetPixelClock(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return mhal_DPRx_GetTimingPixelClock(dprx_id, dprx_decoder_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetMSAChgFlag()
//  [Description]
//					mdrv_DPRx_GetMSAChgFlag
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetMSAChgFlag(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return FALSE;
    }

    return glDPRxDecoderInfo[dprx_decoder_id].bDPMSAChange;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_ClrMSAChgFlag()
//  [Description]
//					mdrv_DPRx_ClrMSAChgFlag
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_ClrMSAChgFlag(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return;
    }

    glDPRxDecoderInfo[dprx_decoder_id].bDPMSAChange = FALSE;

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_PollingColorimetry()
//  [Description]
//					mdrv_DPRx_PollingColorimetry
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_PollingColorimetry(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    WORD usPollingInfo[DPRX_STABLE_POLLING_QUEUE_SIZE] = {0};
    BYTE usColorSpace = DP_COLOR_FORMAT_UNKNOWN;
    BYTE ucColorFormat = DP_COLOR_FORMAT_UNKNOWN;

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return;
    }

    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
        {
            mhal_DPRx_GetMISC01(dprx_decoder_id, usPollingInfo);

            glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 = usPollingInfo[0];
            glDPRxDecoderInfo[dprx_decoder_id].DPMISC1 = usPollingInfo[1];

            if(glDPRxDecoderInfo[dprx_decoder_id].DPMISC1 & BIT6) // Ignore MISC 0
            {
                mhal_DPRx_GetVSCSDP(dprx_decoder_id, usPollingInfo);

                // VSC SDP DB16 --> Pixel Encoding and Colorimetry Formats
                //==========================================================================================
                // Bit 7:4 --> Pixel Encoding
                //******************************************************************************************
                // 0: RGB
                // 1: YCbCr444
                // 2: YCbCr422
                // 3: YCbCr420
                // 4: Y-only
                // 5: RAW
                //==========================================================================================
                switch(usPollingInfo[0] >> 4)
                {
                    case 0:
                        glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_RGB;
                        break;

                    case 1:
                        glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_YUV_444;
                        break;

                    case 2:
                        glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_YUV_422;
                        break;

                    case 3:
                        glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_YUV_420;
                        break;

                    case 4:
                        glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_YONLY;
                        break;

                    case 5:
                        glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_RAW;
                        break;

                    default:
                        glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_UNKNOWN;
                        break;
                }

                // VSC SDP DB16 --> Pixel Encoding and Colorimetry Formats
                //==========================================================================================
                // Bit 3:0 --> Colorimetry Formats
                //******************************************************************************************
                // RGB                                  YCbCr444/422/420
                // 0: sRGB                              0: ITU-R BT601
                // 1: RGB wide gamut fixed point        1: ITU-R BT709
                // 2: RGB wide gamut floating point     2: xvYCC601
                // 3: Adobe RGB                         3: xvYCC709
                // 4: DCI-P3                            4: sYCC601
                // 5: Custom color profile              5: Adobe YCC601
                // 6: ITU-R BT2020 RGB                  6: ITU-R BT2020 YcCbcCrc
                //                                      7: ITU-R BT2020 YcCbCr
                //==========================================================================================
                _mdrv_DPRx_VSCPayload(dprx_id, usPollingInfo[0]);

                // VSC SDP DB17 --> Dynamic Range and Component Bit Depth Type
                //==========================================================================================
                // Bit 7 --> Dynamic Range
                //******************************************************************************************
                // 0: VESA range
                // 1: CEA range
                //==========================================================================================
                if(usPollingInfo[1] & BIT7)
                {
                    glDPRxDecoderInfo[dprx_decoder_id].ucDPRangeFormat = DP_COLOR_RANGE_LIMIT;
                }
                else
                {
                    glDPRxDecoderInfo[dprx_decoder_id].ucDPRangeFormat = DP_COLOR_RANGE_FULL;
                }

                // VSC SDP DB17 --> Dynamic Range and Component Bit Depth Type
                //==========================================================================================
                // Bit 2:0 --> Component Bit Depth Type
                //******************************************************************************************
                // RGB          YCbCr444/422/420
                // 0: 6bpc
                // 1: 8bpc      1: 8bpc
                // 2: 10bpc     2: 10bpc
                // 3: 12bpc     3: 12bpc
                // 4: 16bpc     4: 16bpc
                //==========================================================================================
    			glDPRxDecoderInfo[dprx_decoder_id].ucDPColorDepth = usPollingInfo[1] & (BIT2|BIT1|BIT0);
            }
            else // Reference MISC0
            {
                glDPRxDecoderInfo[dprx_decoder_id].ucDPColorDepth = glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 >> 5;

                //==========================================================================================
                // MISC0[4:1] --> Pixel Encoding and Colorimetry Formats
                //******************************************************************************************
                // 0000: RGB    (MISC1[7] = 0)
                // 0000: Y-only (MISC1[7] = 1)
                // 0100: sRGB
                // 0011: RGB wide gamut fixed point
                // 1011: RGB wide gamut floating point
                // 0001: RAW
                // 0101: YCbCr422 ITU-R BT601
                // 1101: YCbCr422 ITU-R BT709
                // 0110: YCbCr444 ITU-R BT601
                // 1110: YCbCr444 ITU-R BT709
                // 0001: YCbCr422 xvYCC601
                // 1001: YCbCr422 xvYCC709
                // 0010: YCbCr444 xvYCC601
                // 1010: YCbCr444 xvYCC709
                // 1100: Adobe RGB
                //==========================================================================================
                if((glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 & (BIT1|BIT2|BIT3|BIT4)) == (BIT3|BIT4))
                {
                    glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_RGB;
                    glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_ADOBERBG;
                    glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_MAX;
                }
                else
                {
                    usColorSpace = (glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 & (BIT1|BIT2)) >> 1;

                    switch(usColorSpace)
                    {
                        case 0: // RGB
                            glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_RGB;
                            break;

                        case 1: // YCbCr422
                            glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_YUV_422;
                            break;

                        case 2: // YCbCr444
                            glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_YUV_444;
                            break;

                        default:
                            glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_UNKNOWN;
                            break;
                    }

                    if(glDPRxDecoderInfo[dprx_decoder_id].DPMISC1 & BIT7)
                    {
                        if(glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 & BIT1) // RAW
                        {
                            glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_RAW;
                        }
                        else // Y-only
                        {
                            glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_YONLY;
                        }
                    }
                    else
                    {
                        if(glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 & (BIT1|BIT2)) // YCbCr444/422
                        {
                            if(glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 & BIT3) // YCbCr
                            {
                                if((glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 & BIT4) == BIT4) // ITU-R BT709
                                {
                                    glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_ITU709;
                                    glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU709;
                                }
                                else // ITU-R BT601
                                {
                                    glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_ITU601;
                                    glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU601;
                                }
                            }
                            else // xvYCC
                            {
                                if((glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 & BIT4) == BIT4) // xvYCC709
                                {
                                    glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_xvYCC709;
                                    glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU709;
                                }
                                else // xvYCC601
                                {
                                    glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_xvYCC601;
                                    glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU601;
                                }
                            }
                        }
                    }
                }
            }

            switch(usPollingInfo[0] & (BIT1|BIT2|BIT3|BIT4))
            {
                case 0: // RGB
                case (BIT3|BIT4): // Adobe RGB
                case (BIT1|BIT2): // RGB wild
                case (BIT1|BIT2|BIT4): // RGB wild
                    glDPRxDecoderInfo[dprx_decoder_id].ucDPRangeFormat = DP_COLOR_RANGE_FULL;
                    break;

                default:
                    glDPRxDecoderInfo[dprx_decoder_id].ucDPRangeFormat = DP_COLOR_RANGE_LIMIT;
                    break;
            }
        }
    }

    // Only for TSUMR2
    // Overwrite VBlanking data to scalar for 640x480 Vblanking data abnormal issue
    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
        {
            if(ucColorFormat != glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat)
            {
                ucColorFormat = glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat;

                mhal_DPRx_OverwriteVBlankingData(dprx_decoder_id, glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat, glDPRxDecoderInfo[dprx_decoder_id].ucDPRangeFormat);
            }
        }
    }
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetYuvColorimetry()
//  [Description]
//					mdrv_DPRx_GetYuvColorimetry
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_GetYuvColorimetry(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetColorSpace()
//  [Description]
//					mdrv_DPRx_GetColorSpace
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_GetColorSpace(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetColorRange()
//  [Description]
//					mdrv_DPRx_GetColorRange
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_GetColorRange(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return glDPRxDecoderInfo[dprx_decoder_id].ucDPRangeFormat;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetColorimetry()
//  [Description]
//					mdrv_DPRx_GetColorimetry
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_GetColorimetry(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return glDPRxDecoderInfo[dprx_decoder_id].ucColorType;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetColorDepthInfo()
//  [Description]
//					mdrv_DPRx_GetColorDepthInfo
//  [Arguments]:
//
//  [Return]:
//  				pPacketData[0] --> [7:5] bit
//  				000: 6 bit
//  				001: 8 bit
//  				010: 10 bit
//  				011: 12 bit
//  				100: 16 bit
//**************************************************************************
BYTE mdrv_DPRx_GetColorDepthInfo(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return glDPRxDecoderInfo[dprx_decoder_id].ucDPColorDepth & (BIT2|BIT1|BIT0);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetInterlaceFlag()
//  [Description]
//					mdrv_DPRx_GetInterlaceFlag
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetInterlaceFlag(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return FALSE;
    }

    return mhal_DPRx_GetInterlaceFlag(dprx_decoder_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_Get_Misc()
//  [Description]
//					mdrv_DPRx_Get_Misc
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_Get_Misc(DPRx_ID dprx_id, BYTE *pPacketData)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return FALSE;
    }

    pPacketData[0] = glDPRxDecoderInfo[dprx_decoder_id].DPMISC0;
    pPacketData[1] = glDPRxDecoderInfo[dprx_decoder_id].DPMISC1;

    if(glDPRxInfo[dprx_id].bRxDecodeStable)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_EnableDRRFunction()
//  [Description]
//					mdrv_DPRx_EnableDRRFunction
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_EnableDRRFunction(DPRx_ID dprx_id, BOOL bEnable)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    mhal_DPRx_EnableDRRFunction(dprx_aux_id, bEnable);

    if(bEnable == FALSE)
	{
		mdrv_DPRx_ClearFreeSyncFlag(dprx_id);
	}

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetDRRFlag()
//  [Description]
//					mdrv_DPRx_GetDRRFlag
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetDRRFlag(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return FALSE;
    }

    return mhal_DPRx_GetDRRFlag(dprx_aux_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetPacketData()
//  [Description]
//                  mdrv_DPRx_GetPacketData
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetPacketData(DPRx_ID dprx_id, WORD usPacketReceiveType, BYTE *pucPacketData, BYTE ucPacketLength)
{
    BYTE ubHeader[DP_SDP_PACKET_MAX_HEAD_LENGTH] = {0x0};
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    BOOL bPktReceived = FALSE;

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return FALSE;
    }

    // Step1: find correct decoder for this Rx pokrt
    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
        {
            break; // Temp solution for 1 port using 1 decoder case
        }
    }

    if(ucPacketLength > DP_SDP_PACKET_MAX_DATA_LENGTH)
    {
        ucPacketLength = DP_SDP_PACKET_MAX_DATA_LENGTH;
    }

    switch(usPacketReceiveType)
    {
    	case DP_HDR_PACKET:
            mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_DRM, ubHeader, pucPacketData, ucPacketLength);

            if(glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (BIT0 << DP_SDP_SEL_DRM))
            {
                bPktReceived = TRUE;
            }
			break;

		case DP_AVI_PACKET:
            mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_AVI, ubHeader, pucPacketData, ucPacketLength);

            if(glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (BIT0 << DP_SDP_SEL_AVI))
            {
                bPktReceived = TRUE;
            }
	        break;

		case DP_SPD_PACKET:
            mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_SPD, ubHeader, pucPacketData, ucPacketLength);

            if(glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (BIT0 << DP_SDP_SEL_SPD))
            {
                bPktReceived = TRUE;
            }
	        break;

		case DP_AUDIO_PACKET:
            mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_AUI, ubHeader, pucPacketData, ucPacketLength);

            if(glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (BIT0 << DP_SDP_SEL_AUI))
            {
                bPktReceived = TRUE;
            }
	        break;

		case DP_AUDIO_TIMESTAMP:
            mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_AUDIO_TIMESTAMP, ubHeader, pucPacketData, ucPacketLength);

            if(glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (BIT0 << DP_SDP_SEL_AUDIO_TIMESTAMP))
            {
                bPktReceived = TRUE;
            }
	        break;

		case DP_AUDIO_TIMESREAM:
            mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_AUDIO_STREAM, ubHeader, pucPacketData, ucPacketLength);

            if(glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (BIT0 << DP_SDP_SEL_AUDIO_STREAM))
            {
                bPktReceived = TRUE;
            }
			break;

        case DP_VSP_PACKET:
            mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_VSP, ubHeader, pucPacketData, ucPacketLength);

            if(glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (BIT0 << DP_SDP_SEL_VSP))
            {
                bPktReceived = TRUE;
            }
			break;

		case DP_ISRC_PACKET:
			mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_ISRC, ubHeader, pucPacketData, ucPacketLength);

            if(glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (BIT0 << DP_SDP_SEL_ISRC))
            {
                bPktReceived = TRUE;
            }
			break;

		case DP_MPEG_PACKET:
			mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_MPEG, ubHeader, pucPacketData, ucPacketLength);

            if(glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (BIT0 << DP_SDP_SEL_MPEG))
            {
                bPktReceived = TRUE;
            }
			break;

		case DP_NTSC_PACKET:
			mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_NTSC, ubHeader, pucPacketData, ucPacketLength);

            if(glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (BIT0 << DP_SDP_SEL_NTSC))
            {
                bPktReceived = TRUE;
            }
			break;

		case DP_VSC_EXT_CEA_PACKET:
			mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_VSC_EXT_CEA, ubHeader, pucPacketData, ucPacketLength);

            if(glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (BIT0 << DP_SDP_SEL_VSC_EXT_CEA))
            {
                bPktReceived = TRUE;
            }
			break;

		case DP_VSC_EXT_VESA_PACKET:
			mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_VSC_EXT_VESA, ubHeader, pucPacketData, ucPacketLength);

            if(glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (BIT0 << DP_SDP_SEL_VSC_EXT_VESA))
            {
                bPktReceived = TRUE;
            }
			break;

		case DP_ADS_PACKET:
			mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_ADS, ubHeader, pucPacketData, ucPacketLength);

            if(glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (BIT0 << DP_SDP_SEL_ADS))
            {
                bPktReceived = TRUE;
            }
			break;

        case DP_AUDIO_CHANNEL_STATUS:
            bPktReceived = mhal_DPRx_GetAudioChannelStatus(dprx_decoder_id, ucPacketLength, pucPacketData);
            break;

        default:
            return FALSE;
    }

    return bPktReceived;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetPacketReceived_Partial()
//  [Description]
//					mdrv_DPRx_GetPacketReceived_Partial
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetPacketReceived_Partial(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    DWORD usPacketStatusTemp;

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return FALSE;
    }

    usPacketStatusTemp = (DWORD)mhal_DPRx_GetPacketStatus_ext(dprx_decoder_id);

#if (DPRX_PACKET_UPDATED_BY_VSYNC == TRUE)
    ////////////VSP/////////////
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_VSP))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_VSP));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, DP_SDP_SEL_VSP);
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_VSP] = 0;
    }
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_VSP));
    }

    ////////////AVI/////////////
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_AVI))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_AVI));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, DP_SDP_SEL_AVI);
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_AVI] = 0;
    }
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_AVI));
    }

    ////////////SPD/////////////
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_SPD))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_SPD));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, (BIT0 << DP_SDP_SEL_SPD));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[(BIT0 << DP_SDP_SEL_SPD)] = 0;
    }
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_SPD));
    }

    ////////////HDR/////////////
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_DRM))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_DRM));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, DP_SDP_SEL_DRM);
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_DRM] = 0;
    }
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_DRM));
    }

    ////////////VSC_EXT_VESA/////////////
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_VSC_EXT_VESA))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_VSC_EXT_VESA));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, DP_SDP_SEL_VSC_EXT_VESA);
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_VSC_EXT_VESA] = 0;
    }
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_VSC_EXT_VESA));
    }
#endif

    return TRUE;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetPacketReceived()
//  [Description]
//					mdrv_DPRx_GetPacketReceived
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL _mdrv_DPRx_GetPacketReceived(DPRx_ID dprx_id, DPRx_DECODER_ID dprx_decoder_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DWORD usPacketStatusTemp;

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return FALSE;
    }

    usPacketStatusTemp = (DWORD)mhal_DPRx_GetPacketStatus_ext(dprx_decoder_id);

    ////////////AUDIO TimeStamp/////////////once per frame
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_AUDIO_TIMESTAMP))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_AUDIO_TIMESTAMP));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, DP_SDP_SEL_AUDIO_TIMESTAMP);
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_AUDIO_TIMESTAMP] = 0;
    }
    #if (DPRX_AUDIO_TIME_STAMP_LOST_CNT > 0)
    else if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_AUDIO_TIMESTAMP] < DPRX_AUDIO_TIME_STAMP_LOST_CNT)
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_AUDIO_TIMESTAMP));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_AUDIO_TIMESTAMP]++;
    }
    #endif
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_AUDIO_TIMESTAMP));
    }

    ////////////AUDIO Stream/////////////
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_AUDIO_STREAM))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_AUDIO_STREAM));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, DP_SDP_SEL_AUDIO_STREAM);
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_AUDIO_STREAM] = 0;
    }
    #if (DPRX_AUDIO_STREAM_LOST_CNT > 0)
    else if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_AUDIO_STREAM] < DPRX_AUDIO_STREAM_LOST_CNT)
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_AUDIO_STREAM));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_AUDIO_STREAM]++;
    }
    #endif
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_AUDIO_STREAM));
    }

    ////////////ACM/////////////once per two frame
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_ACM))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_ACM));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, DP_SDP_SEL_ACM);
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_ACM] = 0;
    }
    #if (DPRX_ACM_LOST_CNT > 0)
    else if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_ACM] < DPRX_ACM_LOST_CNT)
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_ACM));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_ACM]++;
    }
    #endif
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_ACM));
    }

    ////////////ISRC/////////////once per two frame
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_ISRC))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_ISRC));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, DP_SDP_SEL_ISRC);
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_ISRC] = 0;
    }
    #if (DPRX_ISRC_LOST_CNT > 0)
    else if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_ISRC] < DPRX_ISRC_LOST_CNT)
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_ISRC));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_ISRC]++;
    }
    #endif
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_ISRC));
    }

    ////////////VSC/////////////once per frame
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_VSC))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_VSC));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, DP_SDP_SEL_VSC);
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_VSC] = 0;
    }
    #if (DPRX_VSC_LOST_CNT > 0)
    else if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_VSC] < DPRX_VSC_LOST_CNT)
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_VSC));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_VSC]++;
    }
    #endif
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_VSC));
    }

    ////////////PPS/////////////once per frame
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_PPS))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_PPS));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, (BIT0 << DP_SDP_SEL_PPS));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_PPS] = 0;
    }
    if((mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_00160) & BIT0) == 0)
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_PPS));
    }

#if (DPRX_PACKET_UPDATED_BY_VSYNC == FALSE)
    ////////////VSP/////////////once per two frame
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_VSP))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_VSP));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, DP_SDP_SEL_VSP);
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_VSP] = 0;
    }
    #if (DPRX_VSP_LOST_CNT > 0)
    else if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_VSP] < DPRX_VSP_LOST_CNT)
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_VSP));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_VSP]++;
    }
    #endif
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_VSP));
    }

    ////////////AVI/////////////once per frame
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_AVI))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_AVI));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, DP_SDP_SEL_AVI);
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_AVI] = 0;
    }
    #if (DPRX_AVI_LOST_CNT > 0)
    else if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_AVI] < DPRX_AVI_LOST_CNT)
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_AVI));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_AVI]++;
    }
    #endif
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_AVI));
    }

    ////////////SPD/////////////not more than once per frame , suggest once every second //TBD
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_SPD))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_SPD));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, (BIT0 << DP_SDP_SEL_SPD));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_SPD] = 0;
    }
    #if (DPRX_SPD_LOST_CNT > 0)
    else if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_SPD] < DPRX_SPD_LOST_CNT)
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_SPD));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_SPD]++;
    }
    #endif
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_SPD));
    }
#endif

    ////////////AUI/////////////once per frame
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_AUI))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_AUI));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, (BIT0 << DP_SDP_SEL_AUI));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_AUI] = 0;
    }
    #if (DPRX_AUI_LOST_CNT > 0)
    else if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_AUI] < DPRX_AUI_LOST_CNT)
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << [DP_SDP_SEL_AUI]));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[[DP_SDP_SEL_AUI]]++;
    }
    #endif
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_AUI));
    }

    ////////////MPEG/////////////once per frame
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_MPEG))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_MPEG));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, (BIT0 << DP_SDP_SEL_MPEG));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_MPEG] = 0;
    }
    #if (DPRX_MPEG_LOST_CNT > 0)
    else if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_MPEG] < DPRX_MPEG_LOST_CNT)
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << [DP_SDP_SEL_MPEG]));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[[DP_SDP_SEL_MPEG]]++;
    }
    #endif
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_MPEG));
    }

    ////////////NTSC/////////////once per frame
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_NTSC))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_NTSC));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, (BIT0 << DP_SDP_SEL_NTSC));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_NTSC] = 0;
    }
    #if (DPRX_NTSC_LOST_CNT > 0)
    else if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_NTSC] < DPRX_NTSC_LOST_CNT)
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << [DP_SDP_SEL_NTSC]));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[[DP_SDP_SEL_NTSC]]++;
    }
    #endif
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_NTSC));
    }

#if (DPRX_PACKET_UPDATED_BY_VSYNC == FALSE)
    ////////////DRM/////////////once per frame
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_DRM))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_DRM));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, DP_SDP_SEL_DRM);
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_DRM] = 0;
    }
    #if (DPRX_DRM_LOST_CNT > 0)
    else if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_DRM] < DPRX_DRM_LOST_CNT)
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << [DP_SDP_SEL_DRM]));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[[DP_SDP_SEL_DRM]]++;
    }
    #endif
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_DRM));
    }

    ////////////VSC_EXT_VESA/////////////once per frame
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_VSC_EXT_VESA))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_VSC_EXT_VESA));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, DP_SDP_SEL_VSC_EXT_VESA);
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_VSC_EXT_VESA] = 0;
    }
    #if (DPRX_VSC_EXT_VESA_LOST_CNT > 0)
    else if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_VSC_EXT_VESA] < DPRX_VSC_EXT_VESA_LOST_CNT)
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << [DP_SDP_SEL_VSC_EXT_VESA]));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[[DP_SDP_SEL_VSC_EXT_VESA]]++;
    }
    #endif
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_VSC_EXT_VESA));
    }
#endif

    ////////////VSC_EXT_CEA/////////////once per frame
    if(usPacketStatusTemp & (BIT0 << DP_SDP_SEL_VSC_EXT_CEA))
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << DP_SDP_SEL_VSC_EXT_CEA));
        mhal_DPRx_ClearPacketStatus_ext(dprx_decoder_id, DP_SDP_SEL_VSC_EXT_CEA);
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_VSC_EXT_CEA] = 0;
    }
    #if (DPRX_VSC_EXT_CEA_LOST_CNT > 0)
    else if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[DP_SDP_SEL_VSC_EXT_CEA] < DPRX_VSC_EXT_CEA_LOST_CNT)
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys |= (usPacketStatusTemp & (BIT0 << [DP_SDP_SEL_VSC_EXT_CEA]));
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketLostCnt[[DP_SDP_SEL_VSC_EXT_CEA]]++;
    }
    #endif
    else
    {
        glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys = glDPRxDecoderInfo[dprx_decoder_id].ulPacketStatustoSys & (~(BIT0 << DP_SDP_SEL_VSC_EXT_CEA));
    }

    return TRUE;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_CheckDPLock()
//  [Description]
//					mdrv_DPRx_CheckDPLock
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_CheckDPLock(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX) || (dprx_phy_id == DPRx_PHY_ID_MAX))
    {
        return FALSE;
    }

    return mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_CheckDPTimingStable()
//  [Description]
//					mdrv_DPRx_CheckDPTimingStable
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_CheckDPTimingStable(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    BOOL XDATA bStableFlag = FALSE;

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return FALSE;
    }

    if(dprx_decoder_id < DPRx_DECODER_ID_MAX)
    {
        if((glDPRxInfo[dprx_id].ucState == DPRx_STATE_NORMAL) && (glDPRxInfo[dprx_id].uwDPRxStableTimeout == 0x0))
        {
            bStableFlag = glDPRxInfo[dprx_id].bRxDecodeStable;
        }
    }

    return bStableFlag;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_CheckIgnoreDPMS()
//  [Description]
//					mdrv_DPRx_CheckIgnoreDPMS
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_CheckIgnoreDPMS(DPRx_ID dprx_id)
{
    BOOL bIgnoreFlag = FALSE;

    dprx_id = 0;

    return bIgnoreFlag;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DP_DP_GetDPState()
//  [Description]
//                  mdrv_DP_DP_GetDPState
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetDPStable(DPRx_ID dprx_id)
{
    BOOL bNormalState = FALSE;

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    if((glDPRxInfo[dprx_id].ucState == DPRx_STATE_NORMAL) && (glDPRxInfo[dprx_id].uwDPRxStableTimeout == 0x0))
    {
        bNormalState = TRUE;
    }

    return bNormalState;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetVideoStreamCRC(), for SST stream only !!!
//  [Description]
//
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetVideoStreamCRC(DPRx_ID dprx_id, BYTE* pCRC_Data)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    BYTE i = 0x0;

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    mhal_DPRx_MCUWriteNonPMDPCD(dprx_id, dprx_aux_id, DPCD_00270, 0x1);

    for (i = 0; i < 150; i++) //wait HW calculate 1~2 frames
    {
        mhal_DPRx_DELAY_1ms();
    }

    for(i = 0x0; i < 6; i++)
    {
        pCRC_Data[i] = mhal_DPRx_MCUReadNonPMDPCD(dprx_id, dprx_aux_id, DPCD_00240 + i);
    }

    /*
    printf("CRC_R_CR0 = 0x%x\r\n", pCRC_Data[0]);
    printf("CRC_R_CR1 = 0x%x\r\n", pCRC_Data[1]);
    printf("CRC_G_Y0 = 0x%x\r\n", pCRC_Data[2]);
    printf("CRC_G_Y1 = 0x%x\r\n", pCRC_Data[3]);
    printf("CRC_B_CB0 = 0x%x\r\n", pCRC_Data[4]);
    printf("CRC_B_CB1 = 0x%x\r\n", pCRC_Data[5]);
    */

    mhal_DPRx_MCUWriteNonPMDPCD(dprx_id, dprx_aux_id, DPCD_00270, 0x0);

    return TRUE;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetVESA_AdaptiveSyncEanble()
//  [Description]
//					mdrv_DPRx_SetVESA_AdaptiveSyncEanble
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetVESA_AdaptiveSyncEanble(DPRx_ID dprx_id, BOOL bEnable)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    if(bEnable == TRUE)
    {
        //VESA Adaptive Sync need support MSA_TIMING_PAR_IGNORED & DPCD 0x2214
        mhal_DPRx_EnableDRRFunction(dprx_aux_id, TRUE);
        mhal_DPRx_SetDPCDValueByRIU_Mask(dprx_aux_id, DPCD_02214, BIT0, BIT0, DPRx_RIU_DPCD_Auto);
        mdrv_DPRx_SetSDPSplitEnable(dprx_id, TRUE);
    }
    else
    {
        mhal_DPRx_EnableDRRFunction(dprx_aux_id, FALSE);
        mhal_DPRx_SetDPCDValueByRIU_Mask(dprx_aux_id, DPCD_02214, 0, BIT0, DPRx_RIU_DPCD_Auto);
        mdrv_DPRx_SetSDPSplitEnable(dprx_id, FALSE);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetVESA_AdaptiveSyncEanble()
//  [Description]
//					mdrv_DPRx_SetVESA_AdaptiveSyncEanble
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetSDPSplitEnable(DPRx_ID dprx_id, BOOL bEnable)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    if(bEnable == TRUE)
    {
        mhal_DPRx_SetDPCDValueByRIU_Mask(dprx_aux_id, DPCD_02210, BIT1, BIT1, DPRx_RIU_DPCD_Auto);
    }
    else
    {
        mhal_DPRx_SetDPCDValueByRIU_Mask(dprx_aux_id, DPCD_02210, 0, BIT1, DPRx_RIU_DPCD_Auto);
    }

    return;
}

void ________AUDIO________(void);
//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_SetAudioMaskCount()
//  [Description]
//					_mdrv_DPRx_SetAudioMaskCount
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_SetAudioMaskCount(DPRx_ID dprx_id)
{
    DWORD ulAudioHblank = 0x0;
    DWORD ulAudioMaskCount = 0x0;
    DPRx_AudioStream DPRX_AUDIO_SELECT = mhal_DPRx_GetAudioStream(dprx_id);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX) || (DPRX_AUDIO_SELECT == DPRx_AUD_STREAM_MAX))
    {
        return;
    }

    if(glucAudioPath[dprx_decoder_id] == TRUE)
    {
        if(glDPRxDecoderInfo[dprx_decoder_id].uwDPPixel > 0)
        {
            ulAudioHblank = ((((DWORD)1000*(glDPRxDecoderInfo[dprx_decoder_id].uwDPHWidth)) / glDPRxDecoderInfo[dprx_decoder_id].uwDPPixel) * 85) / 100;

            ulAudioMaskCount = (ulAudioHblank / (1000000 / XTAL_CLOCK_KHZ)) - DPRX_AUDIO_MASK_OFFSET;

            if(ulAudioMaskCount > 0xF0)
            {
                ulAudioMaskCount = 0xF0;
            }
        }
        else
        {
            ulAudioMaskCount = 0x20;
        }

        mhal_DPRx_SetAudioMaskCount(dprx_id, (BYTE)ulAudioMaskCount);

        msWriteByteMask(REG_DPRX_ALOCK0_00_L + DP_REG_OFFSET_ALOCK(DPRX_AUDIO_SELECT), 0, BIT0);
        mhal_DPRx_DELAY_NOP(15);
        msWriteByteMask(REG_DPRX_ALOCK0_00_L + DP_REG_OFFSET_ALOCK(DPRX_AUDIO_SELECT), BIT0, BIT0);

        glucAudioPath[dprx_decoder_id] = FALSE;
    }
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_AudioHandler()
//  [Description]
//					_mdrv_DPRx_AudioHandler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_AudioHandler(DPRx_ID dprx_id)
{
    DPRx_AudioStream DPRX_AUDIO_SELECT = mhal_DPRx_GetAudioStream(dprx_id);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    Bool bIVSChangeFlag = FALSE;

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX) || (DPRX_AUDIO_SELECT == DPRx_AUD_STREAM_MAX))
    {
        return;
    }

    if(glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable)
    {
        _mdrv_DPRx_SetAudioMaskCount(dprx_id);

        if(mhal_DPRx_CheckAudioAbsent(dprx_decoder_id, DPRX_AUDIO_CheckAudioAbsent_CNT)) // No audio
        {
            mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, TRUE);
            mhal_DPRx_AudioAlockReset(DPRX_AUDIO_SELECT);

            glDPRxDecoderInfo[dprx_decoder_id].bAudioMute = TRUE;
            glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange = TRUE;
            glDPRxDecoderInfo[dprx_decoder_id].DPAudioFreq = 0;
            glDPRxDecoderInfo[dprx_decoder_id].ucAudioCTS_UCD400 = 0;
            glDPRxInfo[dprx_id].bAudioRecoverCnt = DPRX_AUDIO_RECOVER_CNT;
        }
        else
        {
            if(mhal_DPRx_CheckLossAlignment(dprx_id)) // Check alignment
            {
                if(mhal_DPRx_CalAudioFreqByIVS(dprx_id) != glDPRxDecoderInfo[dprx_decoder_id].ucAudioFreqByIVS) // Compare IVS change
                {
                    if(mhal_DPRx_CalAudioFreqByIVS(dprx_id) != DPRx_AUD_FREQ_ERROR)
                    {
                        mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, TRUE);
                        glDPRxDecoderInfo[dprx_decoder_id].ucAudioFreqByIVS = mhal_DPRx_CalAudioFreqByIVS(dprx_id);

                        mhal_DPRx_AudioFPLLReset(DPRX_AUDIO_SELECT);
                        bIVSChangeFlag = TRUE;
                    }
                }

                if((mhal_DPRx_CheckAUPLLBigChange(dprx_decoder_id)) || (glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange) || bIVSChangeFlag)
                {
                    glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange = TRUE;
                    msWriteByteMask(REG_DPRX_ALOCK0_00_L + DP_REG_OFFSET_ALOCK(DPRX_AUDIO_SELECT), BIT0, BIT0);
                    glDPRxDecoderInfo[dprx_decoder_id].DPAudioFreq = mhal_DPRx_CalAudioFreq(dprx_id, dprx_decoder_id);
                }

                if(glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange)
                {
                    glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange = FALSE;
                    glDPRxInfo[dprx_id].bAudioRecoverCnt = DPRX_AUDIO_RECOVER_CNT;
                    mhal_DPRx_ClrAudioBigChgFlag(dprx_decoder_id);
                }

                // Check alock
                if(mhal_DPRx_AudioCheckStable(dprx_id, DPRX_AUDIO_STABLE_CNT) && (glDPRxDecoderInfo[dprx_decoder_id].bAudioMute || mhal_DPRx_GetAudioGlobeMute(dprx_id)))
                {
                    DP_DRV_DPRINTF("** Alock DP audio Unmute %d\r\n", dprx_id);

                    mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, FALSE);

                    glDPRxDecoderInfo[dprx_decoder_id].bAudioMute = FALSE;
                    mhal_DPRx_CalAudioFreq(dprx_id, dprx_decoder_id);
                }

                if(glDPRxInfo[dprx_id].bAudioRecoverCnt == 0)
                {
                    mhal_DPRx_AudioCheckFIFOStatus(dprx_id);
                    glDPRxInfo[dprx_id].bAudioRecoverCnt = DPRX_AUDIO_RECOVER_CNT;
                }
            }
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetAudioFreq()
//  [Description]
//					mdrv_DPRx_GetAudioFreq
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
WORD mdrv_DPRx_GetAudioFreq(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return mhal_DPRx_CalAudioFreq(dprx_id, dprx_decoder_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_CheckAudioStatus()
//  [Description]
//					mdrv_DPRx_CheckAudioStatus
//  [Arguments]:
//
//  [Return]:   	1: Has audio
//                  0: No audio
//
//**************************************************************************
BOOL mdrv_DPRx_CheckAudioStatus(DPRx_ID dprx_id)
{
    BOOL bAudioFlag = FALSE;

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    if(glDPRxInfo[dprx_id].InputPacketStatus & (BIT0|BIT1))
    {
        bAudioFlag = TRUE;
    }

    return bAudioFlag;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_ConfigAudioPort()
//  [Description]
//					mdrv_DPRx_ConfigAudioPort
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_ConfigAudioPort(DPRx_ID dprx_id, BOOL bEnable)
{
    BYTE rx_decoder_id = 0;
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    DPRx_AudioStream dprx_audio_select = 0;

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return;
    }

    //if(GET_DP_FUNCTION_ENABLE_PORT(dprx_id))
    {
        for(rx_decoder_id = DPRx_DECODER_ID_0; rx_decoder_id < DPRx_DECODER_ID_MAX; rx_decoder_id++)
        {
            glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable = FALSE;
        }

        mhal_DPRx_AudioGlobalMute(dprx_audio_select, TRUE);

        if(bEnable)
        {
            glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable = bEnable;
            glDPRxDecoderInfo[dprx_decoder_id].bAudioMute = TRUE;
            glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange = TRUE;
            glDPRxDecoderInfo[dprx_decoder_id].DPAudioFreq = 0;
            glDPRxDecoderInfo[dprx_decoder_id].ucAudioCTS_UCD400 = 0;
            glucAudioPath[dprx_decoder_id] = TRUE;
            glDPRxInfo[dprx_id].bAudioRecoverCnt = DPRX_AUDIO_RECOVER_CNT;
        }

        //MT9701 Only has one audio engine
        mhal_DPRx_SetAudioPath(dprx_id, dprx_decoder_id, DPRx_AUD_STREAM_0, bEnable);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_AudioChannelCnt()
//  [Description]
//                  mdrv_DPRx_AudioChannelCnt
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_AudioChannelCnt(DPRx_ID dprx_id, BYTE *pPacketData)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return mhal_DPRx_AudioChannelCnt(dprx_decoder_id, pPacketData);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_CheckAudioAbsent()
//  [Description]
//					mdrv_DPRx_CheckAudioAbsent
//  [Arguments]:
//
//  [Return]:  		1: No audio
//                 	0: Has Audio
//
//**************************************************************************
BOOL mdrv_DPRx_CheckAudioAbsent(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return FALSE;
    }

    return mhal_DPRx_CheckAudioAbsent(dprx_decoder_id, DPRX_AUDIO_CheckAudioAbsent_CNT);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetAudioGlobeMute()
//  [Description]
//					mdrv_DPRx_GetAudioGlobeMute
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetAudioGlobeMute(DPRx_ID dprx_id)
{
    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    return mhal_DPRx_GetAudioGlobeMute(dprx_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetNoAudioFlag()
//  [Description]
//					mdrv_DPRx_GetNoAudioFlag
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetNoAudioFlag(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return FALSE;
    }

    return mhal_DPRx_GetNoAudioFlag(dprx_decoder_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_IsAudioFmtPCM()
//  [Description]
//					mdrv_DPRx_IsAudioFmtPCM
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
DP_AUDIO_FORMAT mdrv_DPRx_IsAudioFmtPCM(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return DP_AUDIO_FMT_UNKNOWN;
    }

    return mhal_DPRx_IsAudioFmtPCM(dprx_decoder_id);
}

void ________AUX________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetOffLine()
//  [Description]
//					mdrv_DPRx_SetOffLine
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetOffLine(DPRx_ID dprx_id, BOOL bEnable)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, bEnable);

    return;
}

//**************************************************************************
//  [Function Name]:
//					mdrv_DPRx_CheckAuxPhyIdle()
//  [Description]
//					mdrv_DPRx_CheckAuxPhyIdle
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_CheckAuxPhyIdle(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    return mhal_DPRx_CheckAuxPhyIdle(dprx_aux_id);
}

//**************************************************************************
//  [Function Name]:
//					mdrv_DPRx_CheckAuxIdle()
//  [Description]
//					mdrv_DPRx_CheckAuxIdle
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_CheckAuxIdle(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    return mhal_DPRx_CheckAuxIdle(dprx_aux_id);
}

//**************************************************************************
//  [Function Name]:
//					mdrv_DPRx_SetAuxPMClock()
//  [Description]
//					mdrv_DPRx_SetAuxPMClock
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetAuxPMClock(BOOL bIsXtalClk)
{
    DPRx_ID dprx_id = DPRx_ID_0;
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    WORD ubRetryCnt = 0;

    while (dprx_id != DPRx_ID_MAX)
    {
        for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
        {
            dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

            if(GET_DPRx_FUNCTION_ENABLE_PORT(dprx_id))
            {
                if((mhal_DPRx_CheckAuxIdle(dprx_aux_id) == FALSE) || (mhal_DPRx_CheckAuxPhyIdle(dprx_aux_id) == FALSE))
                {
                    break;
                }
            }
        }

        ubRetryCnt ++;

        if(ubRetryCnt == 2000)
        {
            break;
        }
    }

    if(dprx_id == DPRx_ID_MAX)
    {
        if(bIsXtalClk == TRUE)
        {
            if(mhal_DPRx_GetAuxPMClock() == 0x0)
            {
                mhal_DPRx_SetAuxPMClock(TRUE);
            }
        }
        else
        {
            if(mhal_DPRx_GetAuxPMClock() == BIT2)
            {
                mhal_DPRx_SetAuxPMClock(FALSE);
            }
        }
    }
    else
    {
        printf("SetAuxPMClock Fail!");
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_ClearFreeSyncFlag()
//  [Description]
//					mdrv_DPRx_ClearFreeSyncFlag
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_ClearFreeSyncFlag(DPRx_ID dprx_id)
{
    BYTE ubTempValue;
	DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

	if(dprx_aux_id == DPRx_AUX_ID_MAX)
	{
		return;
	}

    ubTempValue = mhal_DPRx_MCUReadNonPMDPCD(dprx_id, dprx_aux_id, DPCD_00107);

	if((ubTempValue & BIT7) != 0x0)
	{
    	mhal_DPRx_MCUWriteNonPMDPCD(dprx_id, dprx_aux_id, DPCD_00107, ubTempValue & (~BIT7));
	}

	ubTempValue = mhal_DPRx_MCUReadPMDPCD(dprx_aux_id, DPCD_00107);

	if((ubTempValue & BIT7) != 0x0)
	{
		mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00107, ubTempValue & (~BIT7));
	}

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_Load_EDID()
//  [Description]
//					mdrv_DPRx_Load_EDID
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_Load_EDID(DPRx_ID dprx_id, BYTE *EdidData)
{
	DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

	mhal_DPRx_Load_EDID(dprx_id, dprx_aux_id, EdidData);

	return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetMCCSReplyEnable()
//  [Description]
//                  mdrv_DPRx_SetMCCSReplyEnable
//  [Arguments]:
//
//  [Return]:
//                  TRUE: Reply MCCS normally
//
//**************************************************************************
BOOL mdrv_DPRx_SetMCCSReplyEnable(DPRx_ID dprx_id, BOOL bEnable)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    return mhal_DPRx_SetMCCSReplyEnable(dprx_aux_id, bEnable);
}

void ________TRAINING________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetFastTrainingTime()
//  [Description]
//					mdrv_DPRx_SetFastTrainingTime
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetFastTrainingTime(DPRx_ID dprx_id, BYTE ubTime)
{
    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    mhal_DPRx_SetFastTrainingTime(dprx_id, ubTime);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_MaxLinkRate_Set()
//  [Description]
//					mdrv_DPRx_MaxLinkRate_Set
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_MaxLinkRate_Set(DPRx_ID dprx_id, BYTE ucMaxLinkRate)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

	if(dprx_id == DPRx_ID_MAX)
	{
		return 0;
	}

    if(glDPRxInfo[dprx_id].DPVersion >= DP_VERSION_14)
    {
    	switch(ucMaxLinkRate)
        {
            case DP_LINKRATE_RBR:
            case DP_LINKRATE_HBR:
            case DP_LINKRATE_HBR2: //MT9701 only support HBR2
                mhal_DPRx_SetDPCDValueByRIU(dprx_aux_id, DPCD_00001, ucMaxLinkRate, DPRx_RIU_DPCD_Auto);
                mhal_DPRx_SetDPCDValueByRIU(dprx_aux_id, DPCD_02201, ucMaxLinkRate, DPRx_RIU_DPCD_Auto);
                break;

            default:
                printf("[DP] Error Link Rate settings 01 ! \r\n");
                break;
        };
    }
    else if(glDPRxInfo[dprx_id].DPVersion == DP_VERSION_12)
    {
        switch(ucMaxLinkRate)
        {
            case DP_LINKRATE_RBR:
            case DP_LINKRATE_HBR:
            case DP_LINKRATE_HBR2:
                mhal_DPRx_SetDPCDValueByRIU(dprx_aux_id, DPCD_00001, ucMaxLinkRate, DPRx_RIU_DPCD_Auto);
                break;

            default:
                printf("[DP] Error Link Rate settings 02 ! \r\n");
                break;
        };
    }
    else if(glDPRxInfo[dprx_id].DPVersion == DP_VERSION_11)
    {
        switch(ucMaxLinkRate)
        {
            case DP_LINKRATE_RBR:
            case DP_LINKRATE_HBR:
                mhal_DPRx_SetDPCDValueByRIU(dprx_aux_id, DPCD_00001, ucMaxLinkRate, DPRx_RIU_DPCD_Auto);
                break;

            default:
                printf("[DP] Error Link Rate settings 03 ! \r\n");
                break;
        };
    }

    return 0;
}

void ________HPD_CONTROL________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_HPDControl()
//  [Description]
//					mdrv_DPRx_HPDControl
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_HPDControl(DPRx_ID dprx_id, BOOL bSetHPD)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);
    DPRx_ID OnLine_dprx_id = _mdrv_DPRx_GetOnlineRxID();

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX) || (dprx_phy_id == DPRx_PHY_ID_MAX))
    {
        return FALSE;
    }

    if(mhal_DPRx_TrainingBusy_Check(dprx_id))
    {
        //attempt to set HPD during training
        return FALSE;
    }

    mhal_DPRx_HPDControl(dprx_aux_id, bSetHPD);
    mhal_DPRx_PHYCDRDetectEnable(dprx_phy_id, bSetHPD);

    if(bSetHPD == 0x0)
    {
        glDPRxInfo[dprx_id].bDPLoseCDRLockIRQ = FALSE;
        glDPRxInfo[dprx_id].uwCDRHPDCnt = 0;

        if(dprx_id == OnLine_dprx_id)
        {
            // For special source HPD low but mainlink data still transmit
            mhal_DPRx_OverWriteDPCD202_203(dprx_id, TRUE, 0x0000);
            glDPRxInfo[dprx_id].bOverWriteLockStatus = TRUE;
        }
        mhal_DPRx_CableDisconectResetDPCD(dprx_id, dprx_aux_id);
        if((dprx_id == DPRx_ID_2) && (dprx_id < DPRx_ID_MAX))
        {
            mhal_DPRx_InternalOverWriteHPD(dprx_id, FALSE);	// For TypeC port fast training set internal hpd high
        }
    }
    else if((bSetHPD == 0x1) && (glDPRxInfo[dprx_id].bDPHpdState == 0x0))
    {
        glDPRxInfo[dprx_id].bDPLoseCDRLockIRQ = FALSE;
        glDPRxInfo[dprx_id].uwCDRHPDCnt = 0;

        if(dprx_id == OnLine_dprx_id)
        {
            mhal_DPRx_OverWriteDPCD202_203(dprx_id, FALSE, 0x0000);
            glDPRxInfo[dprx_id].bOverWriteLockStatus = FALSE;
        }

        if((dprx_id == DPRx_ID_2) && (dprx_id < DPRx_ID_MAX))
        {
            mhal_DPRx_InternalOverWriteHPD(dprx_id, TRUE); // For TypeC port fast training set internal hpd high
        }
    }

    glDPRxInfo[dprx_id].bDPHpdState = bSetHPD;

    return TRUE;
}

void ________HANDLER________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_Handler()
//  [Description]
//					mdrv_DPRx_Handler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_Handler(void)
{
    DPRx_ID dprx_id = DPRx_ID_MAX;
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    DPRx_PHY_ID dprx_phy_id = DPRx_PHY_ID_MAX;
    DPRx_ID OnLine_dprx_id;

    OnLine_dprx_id = _mdrv_DPRx_GetOnlineRxID();

    for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
    {
        if(GET_DPRx_FUNCTION_ENABLE_PORT(dprx_id))
        {
            _mdrv_DPRx_CheckCableDetection(dprx_id);

            if(dprx_id != OnLine_dprx_id)
            {
                continue;
            }

            if(_mdrv_DPRx_CTSCheck(dprx_id))  // For PHY CTS
            {
                continue;
            }

            dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
            dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

            #if (DP_RX_FT_TIMER_A_WAIT_SQ_SIGNAL == 0x0)
            if((mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort) == TRUE) &&
               (mhal_DPRx_CheckHWNormalTrainingDone(dprx_id) == TRUE))
            {
                glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;

                mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);
            }
            else if(mhal_DPRx_CheckSquelch(dprx_id))
            {
                if(glDPRxInfo[dprx_id].ubSQStableTimer == 0x0)
                {
                    mhal_DPRx_HWFastTrainingEnable(dprx_id, TRUE);
                }
            }
            else
            {
                glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;

                mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);
            }
            #endif

            if(_mdrv_DPRx_StateHandler(dprx_id)) // DPRx_STATE_NORMAL
            {
                _mdrv_DPRx_StablePolling(dprx_id);
                _mdrv_DPRx_AudioHandler(dprx_id);
            }

            _mdrv_DPRx_HDCPHandler((DPRx_ID)dprx_id);
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_RX_IRQ_Handler()
//  [Description]
//					mdrv_DPRx_RX_IRQ_Handler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_RX_IRQ_Handler(void)
{
    DPRx_ID dprx_id = DPRx_ID_MAX;
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    DPRx_PHY_ID dprx_phy_id = DPRx_PHY_ID_MAX;
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;
    WORD usRegOffsetPHY0ByID = 0x0;
    WORD usRegOffsetDPCD1ByID = 0x0;
    WORD usRegOffsetReceiverByID = 0x0;
    WORD usRegOffsetTransCTRLByID = 0x0;
    WORD usRegOffsetDPCD0ByID = 0x0;
    BYTE ucACDR_lane = 0x0;
	BYTE ucLinkRate;

    dprx_id = _mdrv_DPRx_GetOnlineRxID();
    dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

    if(dprx_id == DPRx_ID_MAX)
    {
        dprx_id = DPRx_ID_0;
        dprx_phy_id = DPRx_PHY_ID_0;
    }

    usRegOffsetPHY0ByID = DP_REG_OFFSET_PHY0(dprx_phy_id);
    usRegOffsetDPCD1ByID = DP_REG_OFFSET_DPCD1(dprx_id);
    usRegOffsetReceiverByID = DP_REG_OFFSET_RECEIVER(dprx_id);
    usRegOffsetTransCTRLByID = DP_REG_OFFSET_TRANS_CTRL(dprx_id);
    usRegOffsetDPCD0ByID = DP_REG_OFFSET_DPCD0(dprx_id);

#if (DPRx_HDCP2_ISR_MODE == 0x1) && (DPRX_HDCP2_ENABLE == 0x1)
    mdrv_DPRx_HDCP2FetchMsg(dprx_id);
#endif

    if(mhal_DPRx_GetAKSVReceivedFlag(dprx_id))
    {
        glDPRxInfo[dprx_id].bHDCP14R0beRead = FALSE;
        glDPRxInfo[dprx_id].bForceIntegrityFail = FALSE;

        if(mhal_DPRx_HWFastTrainingBusy_Get(dprx_id) == TRUE)
        {
            glDPRxInfo[dprx_id].bHdcp14StartAuth = TRUE;
        }

        mhal_DPRx_ForceHDCP13IntegrityFail(dprx_id, FALSE);
        mhal_DPRx_ForceHDCP22IntegrityFail(dprx_id, FALSE);
    }

    //==============================================================================
    //==============================================================================
    //==============================================================================
    //================================   Auto EQ   =================================
    //==============================================================================
    //==============================================================================

    //==============================================================================
    if(msReadByte(REG_DPRX_PHY2_44_H + usRegOffsetPHY0ByID) & BIT7) // Auto EQ Done Lane 0
    {
        msWriteByte(REG_DPRX_PHY2_47_H + usRegOffsetPHY0ByID, BIT7);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_PHY2_47_H + usRegOffsetPHY0ByID, 0);
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_PHY2_48_H + usRegOffsetPHY0ByID) & BIT7) // Auto EQ Done Lane 1
    {
        msWriteByte(REG_DPRX_PHY2_4B_H + usRegOffsetPHY0ByID, BIT7);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_PHY2_4B_H + usRegOffsetPHY0ByID, 0);
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_PHY2_4C_H + usRegOffsetPHY0ByID) & BIT7) // Auto EQ Done Lane 2
    {
        msWriteByte(REG_DPRX_PHY2_4F_H + usRegOffsetPHY0ByID, BIT7);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_PHY2_4F_H + usRegOffsetPHY0ByID, 0);
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_PHY2_50_H + usRegOffsetPHY0ByID) & BIT7) // Auto EQ Done Lane 3
    {
        msWriteByte(REG_DPRX_PHY2_53_H + usRegOffsetPHY0ByID, BIT7);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_PHY2_53_H + usRegOffsetPHY0ByID, 0);
        //// For one lane at agc state , RTL issue .
        mhal_DPRx_Check_AGC_Reset(dprx_phy_id);
    }


    //==============================================================================
    //==============================================================================
    //==============================================================================
    //=============================   Training ISR	 ===============================
    //==============================================================================
    //==============================================================================
    //==============================================================================

    //==============================================================================
    if(msReadByte(REG_DPRX_DPCD1_39_L + usRegOffsetDPCD1ByID) & BIT5) // TP1
    {
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, BIT5);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, 0);
        
        mhal_DPRx_SetAuxDelayReply(dprx_aux_id, DP_AUX_DELAY_TRAINING);

        glDPRxInfo[dprx_id].bDPTrainingP1T = TRUE;
        glDPRxInfo[dprx_id].bDPTrainingFlag = TRUE;
        glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;

        msWriteByte(REG_DPRX_PHY0_29_L + usRegOffsetPHY0ByID, 0x08); // Time out for symbol detect time (us) 20180702

        #if (DP_RX_FT_TIMER_A_WAIT_SQ_SIGNAL == 0x0)
        	mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);
        #endif
        //// For one lane at agc state , RTL issue . odinson2 also happen
        mhal_DPRx_Check_AGC_Reset(dprx_phy_id);

        msWriteByteMask(REG_DPRX_TRANS_CTRL_10_L + usRegOffsetTransCTRLByID, 0x3, BIT0|BIT1|BIT2); // Request counter

		#if (FPGA_Verification == 0x1)  //toggle to re-CDR(TX) for receive data on stable time, setting by Todd
			msWrite2Byte(0x113D80, BIT5);
			mhal_DPRx_DELAY_NOP(10);
			msWrite2Byte(0x113D80, 0);
		#endif

        // JL suggest turn off this bit when timer_a = 0 to avoid CR lose irq when unplug cable, only turn on this bit during normal training
        #if (DP_RX_FT_TIMER_A_WAIT_SQ_SIGNAL == 0x0)
        	msWriteByteMask(REG_DPRX_PHY0_62_L + usRegOffsetPHY0ByID, BIT7, BIT7);
        #endif
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_DPCD1_39_L + usRegOffsetDPCD1ByID) & BIT4) // TP2
    {
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, BIT4);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, 0);

        glDPRxInfo[dprx_id].bDPTrainingP234T = TRUE;
        glDPRxInfo[dprx_id].bDPTrainingFlag = TRUE;
        glDPRxInfo[dprx_id].uwSinkStatusCnt = 100; // For link CTS1.4, item 5.2.2.8 ESI Field Mapping
        glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;

        //mhal_DPRx_SetAuxDelayReply(dprx_aux_id, DP_AUX_DELAY_TRAINING); // 280us delay reply

        #if (DP_RX_FT_TIMER_A_WAIT_SQ_SIGNAL == 0x0)
        	mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);
        #endif
        //// For one lane at agc state , RTL issue . odinson2 also happen
        mhal_DPRx_Check_AGC_Reset(dprx_phy_id);

        msWriteByteMask(REG_DPRX_TRANS_CTRL_10_L + usRegOffsetTransCTRLByID, 0x2, BIT0|BIT1|BIT2); // Request counter

        // For link CTS1.4, item 5.2.2.8 ESI Field Mapping, overwrite DPCD 205 and 200F
        msWriteByteMask(REG_DPRX_DPCD1_4D_H + usRegOffsetDPCD1ByID, BIT0|BIT1|BIT2, BIT0|BIT1|BIT2);
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_DPCD1_39_L + usRegOffsetDPCD1ByID) & BIT3) // TP3
    {
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, BIT3);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, 0);

        glDPRxInfo[dprx_id].bDPTrainingP234T = TRUE;
        glDPRxInfo[dprx_id].bDPTrainingFlag = TRUE;
        glDPRxInfo[dprx_id].uwSinkStatusCnt = 100; // For link CTS1.4, item 5.2.2.8 ESI Field Mapping
        glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;

        //mhal_DPRx_SetAuxDelayReply(dprx_aux_id, DP_AUX_DELAY_TRAINING); // 280us delay reply

        #if (DP_RX_FT_TIMER_A_WAIT_SQ_SIGNAL == 0x0)
        	mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);
        #endif
        //// For one lane at agc state , RTL issue . odinson2 also happen
        mhal_DPRx_Check_AGC_Reset(dprx_phy_id);

        msWriteByteMask(REG_DPRX_TRANS_CTRL_10_L + usRegOffsetTransCTRLByID, 0x2, BIT0|BIT1|BIT2); // Request counter

        // For link CTS1.4, item 5.2.2.8 ESI Field Mapping, overwrite DPCD 205 and 200F
        msWriteByteMask(REG_DPRX_DPCD1_4D_H + usRegOffsetDPCD1ByID, BIT0|BIT1|BIT2, BIT0|BIT1|BIT2);
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_DPCD1_39_L + usRegOffsetDPCD1ByID) & BIT2) // TP4
    {
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, BIT2);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, 0);

        glDPRxInfo[dprx_id].bDPTrainingP234T = TRUE;
        glDPRxInfo[dprx_id].bDPTrainingFlag = TRUE;
        glDPRxInfo[dprx_id].uwSinkStatusCnt = 100; // For link CTS1.4, item 5.2.2.8 ESI Field Mapping
        glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;

        //mhal_DPRx_SetAuxDelayReply(dprx_aux_id, DP_AUX_DELAY_TRAINING); // 280us delay reply

        #if (DP_RX_FT_TIMER_A_WAIT_SQ_SIGNAL == 0x0)
        	mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);
        #endif
        //// For one lane at agc state , RTL issue . odinson2 also happen
        mhal_DPRx_Check_AGC_Reset(dprx_phy_id);

        msWriteByteMask(REG_DPRX_TRANS_CTRL_10_L + usRegOffsetTransCTRLByID, 0x2, BIT0|BIT1|BIT2); // Request counter

        // For link CTS1.4, item 5.2.2.8 ESI Field Mapping, overwrite DPCD 205 and 200F
        msWriteByteMask(REG_DPRX_DPCD1_4D_H + usRegOffsetDPCD1ByID, BIT0|BIT1|BIT2, BIT0|BIT1|BIT2);
    }

    //=========================================================================================================================
    if(msReadByte(REG_DPRX_DPCD1_39_L + usRegOffsetDPCD1ByID) & BIT1) // DPCD 270[0] = 1 (TEST_SINK_START)
    {
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, BIT1);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, 0);

        // When DPCD 0x270[0] change from 0 to 1, this IRQ would be trigger
        dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

        glDPRxDecoderInfo[dprx_decoder_id].usDPCD246StableTimer = DPRX_CRC_STABLE_TIMER_CNT;
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_DPCD1_39_L + usRegOffsetDPCD1ByID) & BIT6) // DPCD 270h
    {
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, BIT6);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, 0);

        if((msReadByte(REG_DPRX_DPCD0_4B_L + usRegOffsetDPCD0ByID) & BIT0) == 0)
        {
            mhal_DPRx_OverWriteDPCD246(dprx_aux_id, TRUE, 0x20);
        }

        if(msReadByte(REG_DPRX_DPCD0_4B_L + usRegOffsetDPCD0ByID) & BIT7)
        {
            glDPRxInfo[dprx_id].bDPAutoTestEn = 1;

            ucACDR_lane = (msReadByte(REG_DPRX_DPCD0_4B_L + usRegOffsetDPCD0ByID) & (BIT4|BIT5)) >> 4;

            if(ucACDR_lane == 0)
            {
                mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, glTypeC_PhyLaneSwap[dprx_id]&(BIT0|BIT1));
            }
            else if(ucACDR_lane == 1)
            {
                mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, ((glTypeC_PhyLaneSwap[dprx_id]&(BIT2|BIT3)) >> 2));
            }
            else if(ucACDR_lane == 2)
            {
                mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, ((glTypeC_PhyLaneSwap[dprx_id]&(BIT4|BIT5)) >> 4));
            }
            else if(ucACDR_lane == 3)
            {
                mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, ((glTypeC_PhyLaneSwap[dprx_id]&(BIT6|BIT7)) >> 6));
            }

#if (SET_DP_C3_LANE023_PN_SWAP == 0x1)
                msWriteByteMask(REG_DPRX_PHY0_5E_H + usRegOffsetPHY0ByID, 0xD0 , 0xF0);
#endif
        }
        else
        {
            glDPRxInfo[dprx_id].bDPAutoTestEn = 0;

            mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, glTypeC_PhyLaneSwap[dprx_id]&(BIT0|BIT1));
        }

#if 0//19072 C1 patch
        if(glDPRxInfo[dprx_id].bDPAutoTestEn == 1)
        {
            if(((msReadByte(REG_DPRX_DPCD0_4B_L + usRegOffsetDPCD0ByID) & (BIT4|BIT5)) >> 4) == 0x0)
            {
                mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, 0x1);
            }
            else if(((msReadByte(REG_DPRX_DPCD0_4B_L + usRegOffsetDPCD0ByID) & (BIT4|BIT5)) >> 4) == 0x1)
            {
                mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, 0x0);
            }
        }
        else
        {
            mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, 1); // Default set ACDR lane to lane 1
        }
#endif
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_DPCD1_38_L + usRegOffsetDPCD1ByID) & BIT2) // DPCD 160h
    {
        msWriteByte(REG_DPRX_DPCD1_3D_L + usRegOffsetDPCD1ByID, BIT2);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_DPCD1_3D_L + usRegOffsetDPCD1ByID, 0);
    }

	//==============================================================================
	if(msReadByte(REG_DPRX_DPCD1_3A_L + usRegOffsetDPCD1ByID) & BIT6) // DPCD 100h
	{
		msWriteByte(REG_DPRX_DPCD1_3D_L + usRegOffsetDPCD1ByID, BIT6);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_DPCD1_3D_L + usRegOffsetDPCD1ByID, 0);

		ucLinkRate = msReadByte(REG_DPRX_DPCD0_20_L + usRegOffsetDPCD0ByID);
		mhal_DPRx_SQHOverwrite(dprx_id, FALSE);

        switch(ucLinkRate)
        {
            case DP_LINKRATE_RBR:
                mhal_DPRx_Switch_Training_Setting(dprx_phy_id, DP_LINKRATE_RBR);
                break;

            case DP_LINKRATE_HBR:
                mhal_DPRx_Switch_Training_Setting(dprx_phy_id, DP_LINKRATE_HBR);
                break;

            case DP_LINKRATE_HBR2:
                mhal_DPRx_Switch_Training_Setting(dprx_phy_id, DP_LINKRATE_HBR2);
                break;

            default:
                break;
        }

		#if (FPGA_Verification == 0x1) // Link rate changing for FPGA
			if(ucLinkRate == DP_LINKRATE_RBR)
			{
				msWrite2Byte(0x113D90, 0x00CB);
				msWrite2Byte(0x113D92, 0x21F8);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x00BC);
				msWrite2Byte(0x113D92, 0xF004);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x0028);
				msWrite2Byte(0x113D92, 0x010A);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x0028);
				msWrite2Byte(0x113D92, 0x010A);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x0063);
				msWrite2Byte(0x113D92, 0x00C2);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x0095);
				msWrite2Byte(0x113D92, 0xE000);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x0010);
				msWrite2Byte(0x113D92, 0x07C0); // Tune for grphic card not training lock on RBR
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D80, 0x0001);
				msWrite2Byte(0x113D80, 0x0000);
			}
			else if(ucLinkRate == DP_LINKRATE_HBR)
			{
				msWrite2Byte(0x113D90, 0x00CB);
				msWrite2Byte(0x113D92, 0x67F8);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x00BC);
				msWrite2Byte(0x113D92, 0x0007);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x0028);
				msWrite2Byte(0x113D92, 0x008A);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x0028);
				msWrite2Byte(0x113D92, 0x008A);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x0063);
				msWrite2Byte(0x113D92, 0x00C1);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x0095);
				msWrite2Byte(0x113D92, 0xF000);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x0010);
				msWrite2Byte(0x113D92, 0x07C2);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D80, 0x0001);
				msWrite2Byte(0x113D80, 0x0000);
			}
			else if(ucLinkRate == DP_LINKRATE_HBR2)
			{
				msWrite2Byte(0x113D90, 0x00CB);
				msWrite2Byte(0x113D92, 0x67F8);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x00BC);
				msWrite2Byte(0x113D92, 0x0007);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x0028);
				msWrite2Byte(0x113D92, 0x008A);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x0028);
				msWrite2Byte(0x113D92, 0x008A);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x0063);
				msWrite2Byte(0x113D92, 0x00C0);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x0095);
				msWrite2Byte(0x113D92, 0x0000);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D90, 0x0010);
				msWrite2Byte(0x113D92, 0x07C2);
				msWrite2Byte(0x113D94, 0x0003);
				msWrite2Byte(0x113D94, 0x0000);

				msWrite2Byte(0x113D80, 0x0001);
				msWrite2Byte(0x113D80, 0x0000);
			}
		#endif

		mhal_DPRx_OverWriteDPCD202_203(dprx_id, FALSE, 0x0000);
		glDPRxInfo[dprx_id].bOverWriteLockStatus = FALSE;
        mhal_DPRx_SetCDRLossLockInterrupt(dprx_id, TRUE);
        mhal_DPRx_SetInterlaneSkewLoseInterrupt(dprx_id, TRUE);
        mhal_DPRx_SetInterlaneSkewDoneInterrupt(dprx_id, TRUE);
	}

    //==============================================================================
    //==============================================================================
    //==============================================================================
    //=============================   MainLink ISR   ===============================
    //==============================================================================
    //==============================================================================
    //==============================================================================

    //==============================================================================
    if(msReadByte(REG_DPRX_RECEIVER_64_L + usRegOffsetReceiverByID) & BIT6) // FT Enter
    {
        msWriteByte(REG_DPRX_RECEIVER_62_L + usRegOffsetReceiverByID, BIT6);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_RECEIVER_62_L + usRegOffsetReceiverByID, 0);

        if(glDPRxInfo[dprx_id].bDPAutoTestEn == FALSE)
        {
            //mhal_DPRx_MSCHIP_TypeC_PRBS7PNswapforFT(dprx_id, glDPRxInfo[dprx_id].ubTypeC_PinAssign);
            mhal_DPRx_Switch_Training_Setting_FT(dprx_phy_id);
        }
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_RECEIVER_63_L + usRegOffsetReceiverByID) & BIT0) // cr_lose_lock_irq
    {
        msWriteByte(REG_DPRX_RECEIVER_61_L + usRegOffsetReceiverByID, BIT0);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_RECEIVER_61_L + usRegOffsetReceiverByID, 0);

        if(mhal_DPRx_CheckSquelch(dprx_id) == TRUE)
        {
            _mdrv_DPRx_MSCHIP_ScreenMute();
        }

        glDPRxInfo[dprx_id].bDPLoseCDRLockIRQ = TRUE;
        glDPRxInfo[dprx_id].uwCDRHPDCnt = 30; // For link CTS1.4, item 5.3.2.1 IRQ HPD Pulse Due to CDR Loss Lock
    }

	//=========================================================================================================================
	if(msReadByte(REG_DPRX_RECEIVER_63_L + usRegOffsetReceiverByID) & BIT1) // Main link lose lock (CR/EQ/symbol lose lock)
	{
		msWriteByte(REG_DPRX_RECEIVER_61_L + usRegOffsetReceiverByID, BIT1);
		mhal_DPRx_DELAY_NOP(10);
		msWriteByte(REG_DPRX_RECEIVER_61_L + usRegOffsetReceiverByID, 0);

        if(mhal_DPRx_CheckSquelch(dprx_id) == TRUE)
        {
            _mdrv_DPRx_MSCHIP_ScreenMute();
        }
	}

    //==============================================================================
    if(msReadByte(REG_DPRX_RECEIVER_63_L + usRegOffsetReceiverByID) & BIT2) // interlane_skew_done_lose_irq
    {
        msWriteByte(REG_DPRX_RECEIVER_61_L + usRegOffsetReceiverByID, BIT2);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_RECEIVER_61_L + usRegOffsetReceiverByID, 0);

        if(mhal_DPRx_CheckSquelch(dprx_id) == TRUE)
        {
            _mdrv_DPRx_MSCHIP_ScreenMute();
        }

        glDPRxInfo[dprx_id].bDPInterlaneSkewLoseIRQ = TRUE;
        glDPRxInfo[dprx_id].bDPInterlaneSkewDoneIRQ = FALSE;
        glDPRxInfo[dprx_id].uwSkewHPDCnt = 1000;
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_RECEIVER_63_L + usRegOffsetReceiverByID) & BIT3) // interlane_skew_done_irq
    {
        msWriteByte(REG_DPRX_RECEIVER_61_L + usRegOffsetReceiverByID, BIT3);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_RECEIVER_61_L + usRegOffsetReceiverByID, 0);

        glDPRxInfo[dprx_id].bDPInterlaneSkewDoneIRQ = TRUE;
    }

	//=========================================================================================================================
    if(msReadByte(REG_DPRX_RECEIVER_63_H + usRegOffsetReceiverByID) & BIT0) // Link clock big change
    {
        msWriteByte(REG_DPRX_RECEIVER_61_H + usRegOffsetReceiverByID, BIT0);
		mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_RECEIVER_61_H + usRegOffsetReceiverByID, 0);
    }

    //=========================================================================================================================
    if(msReadByte(REG_DPRX_RECEIVER_63_H + usRegOffsetReceiverByID) & BIT1) // No link clock
    {
        msWriteByte(REG_DPRX_RECEIVER_61_H + usRegOffsetReceiverByID, BIT1);
		mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_RECEIVER_61_H + usRegOffsetReceiverByID, 0);
    }

	//=========================================================================================================================
    if(msReadByte(REG_DPRX_RECEIVER_63_H + usRegOffsetReceiverByID) & BIT6) // HDCP dpes
    {
        msWriteByte(REG_DPRX_RECEIVER_61_H + usRegOffsetReceiverByID, BIT6);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_RECEIVER_61_H + usRegOffsetReceiverByID, 0);
    }

    //=========================================================================================================================
    if(msReadByte(REG_DPRX_RECEIVER_63_H + usRegOffsetReceiverByID) & BIT7) // ~HDCP dpes
    {
        msWriteByte(REG_DPRX_RECEIVER_61_H + usRegOffsetReceiverByID, BIT7);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_RECEIVER_61_H + usRegOffsetReceiverByID, 0);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_RX2_IRQ_Handler()
//  [Description]
//					mdrv_DPRx_RX2_IRQ_Handler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_RX2_IRQ_Handler(void)
{
    DPRx_ID dprx_id = DPRx_ID_MAX;
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    DPRx_PHY_ID dprx_phy_id = DPRx_PHY_ID_MAX;
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;
    DPRx_AudioStream DPRX_AUDIO_SELECT = DPRx_AUD_STREAM_MAX;
    WORD usRegOffsetDecoderByID = 0x0;
    WORD usRegOffsetSdpByID = 0x0;

    dprx_id = _mdrv_DPRx_GetOnlineRxID();
    dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

    if(_mdrv_DPRX_InputPortType() == DP_INPUTPORT_IS_NONE)
    {
        dprx_id = DPRx_ID_0;
        dprx_aux_id = DPRx_AUX_ID_0;
        dprx_phy_id = DPRx_PHY_ID_0;
    }

    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        DPRX_AUDIO_SELECT = mhal_DPRx_GetAudioStream(dprx_id);
        usRegOffsetDecoderByID = DP_REG_OFFSET_DECODER(dprx_decoder_id);
        usRegOffsetSdpByID = DP_REG_OFFSET_SDP(dprx_decoder_id);

        if(msReadByte(REG_DPRX_DECODER_E0_0B_L + usRegOffsetDecoderByID) & BIT0) // Audio MN Change
        {
            msWriteByteMask(REG_DPRX_DECODER_E0_0D_L + usRegOffsetDecoderByID, BIT0, BIT0); // Audio MN big change mask

            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, BIT0);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, 0);

            if(glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable)
            {
                if(glDPRxDecoderInfo[dprx_decoder_id].ucAudioCTS_UCD400 <= 5)
                {
                    mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, TRUE);

                    msWriteByteMask(REG_DPRX_ALOCK0_00_L + DP_REG_OFFSET_ALOCK(DPRX_AUDIO_SELECT), 0, BIT0);

                    glDPRxDecoderInfo[dprx_decoder_id].bAudioMute = TRUE;
                    glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange = TRUE;
                    glDPRxDecoderInfo[dprx_decoder_id].DPAudioFreq = 0;
                    glDPRxDecoderInfo[dprx_decoder_id].ucAudioCTS_UCD400++;

                    if(dprx_id < DPRx_ID_MAX)
                    {
                        glDPRxInfo[dprx_id].bAudioRecoverCnt = DPRX_AUDIO_RECOVER_CNT;
                    }
                }
            }
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0B_L + usRegOffsetDecoderByID) & BIT1) // Video MN Change
        {
            msWriteByteMask(REG_DPRX_DECODER_E0_0D_L + usRegOffsetDecoderByID, BIT1, BIT1); // Video MN Change mask

            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, BIT1);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, 0);

            _mdrv_DPRx_MSCHIP_ScreenMute();

            glDPRxDecoderInfo[dprx_decoder_id].bDPVPLLBIGChange = TRUE;

            if(mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort) != TRUE)
            {
                msWriteByteMask(REG_DPRX_DECODER_E0_0D_L + usRegOffsetDecoderByID, BIT1, BIT1);
            }
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0B_L + usRegOffsetDecoderByID) & BIT2) // SDP ECC error
        {
            msWriteByteMask(REG_DPRX_DECODER_E0_0D_L + usRegOffsetDecoderByID, BIT2, BIT2); // SDP ECC error mask

            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, BIT2);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, 0);
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0B_L + usRegOffsetDecoderByID) & BIT3) // Video buffer overflow
        {
            msWriteByteMask(REG_DPRX_DECODER_E0_0D_L + usRegOffsetDecoderByID, BIT3, BIT3); // Video buffer overflow mask

            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, BIT3);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, 0);
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0B_L + usRegOffsetDecoderByID) & BIT4) // MSA change
        {
            msWriteByteMask(REG_DPRX_DECODER_E0_0D_L + usRegOffsetDecoderByID, BIT4, BIT4); // MSA change mask

            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, BIT4);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, 0);

            _mdrv_DPRx_MSCHIP_ScreenMute();

            glDPRxDecoderInfo[dprx_decoder_id].bDPVPLLBIGChange = TRUE;
            glDPRxDecoderInfo[dprx_decoder_id].bDPMSAChange = TRUE; // For system used on 800x600@60Hz switch to 800x600@75Hz, system read/clear this flag

            if(mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort) != TRUE)
            {
                msWriteByteMask(REG_DPRX_DECODER_E0_0D_L + usRegOffsetDecoderByID, BIT4, BIT4);
            }
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0B_L + usRegOffsetDecoderByID) & BIT5) // Video mute
        {
            msWriteByteMask(REG_DPRX_DECODER_E0_0D_L + usRegOffsetDecoderByID, BIT5, BIT5); // Video mute mask

            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, BIT5);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, 0);
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0B_L + usRegOffsetDecoderByID) & BIT6) // Audio mute
        {
            msWriteByteMask(REG_DPRX_DECODER_E0_0D_L + usRegOffsetDecoderByID, BIT6, BIT6); // Audio mute mask

            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, BIT6);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, 0);

            if(glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable)
            {
                mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, TRUE);

                glDPRxDecoderInfo[dprx_decoder_id].bAudioMute = TRUE;
                glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange = TRUE;
                glDPRxDecoderInfo[dprx_decoder_id].DPAudioFreq = 0;
                glDPRxDecoderInfo[dprx_decoder_id].ucAudioCTS_UCD400 = 0;

                if(dprx_id < DPRx_ID_MAX)
                {
                    glDPRxInfo[dprx_id].bAudioRecoverCnt = DPRX_AUDIO_RECOVER_CNT;
                }
            }
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0B_L + usRegOffsetDecoderByID) & BIT7) // Audio channel status change
        {
            msWriteByteMask(REG_DPRX_DECODER_E0_0D_L + usRegOffsetDecoderByID, BIT7, BIT7); // Audio channel status change mask

            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, BIT7);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, 0);

            if(glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable)
            {
                mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, TRUE);

                glDPRxDecoderInfo[dprx_decoder_id].bAudioMute = TRUE;
                glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange = TRUE;
                glDPRxDecoderInfo[dprx_decoder_id].DPAudioFreq = 0;
                glDPRxDecoderInfo[dprx_decoder_id].ucAudioCTS_UCD400 = 0;

                if(dprx_id < DPRx_ID_MAX)
                {
                    glDPRxInfo[dprx_id].bAudioRecoverCnt = DPRX_AUDIO_RECOVER_CNT;
                }
            }
        }

    	if(msReadByte(REG_DPRX_SDP_E0_44_H + usRegOffsetSdpByID) & BIT3) // MISC0 change
        {
            msWriteByte(REG_DPRX_SDP_E0_47_H + usRegOffsetSdpByID, BIT3);
			mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_SDP_E0_47_H + usRegOffsetSdpByID, 0);

            _mdrv_DPRx_MSCHIP_ScreenMute();
		}

    	if(msReadByte(REG_DPRX_SDP_E0_44_H + usRegOffsetSdpByID) & BIT4) // MISC1 change
        {
            msWriteByte(REG_DPRX_SDP_E0_47_H + usRegOffsetSdpByID, BIT4);
			mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_SDP_E0_47_H + usRegOffsetSdpByID, 0);

            _mdrv_DPRx_MSCHIP_ScreenMute();
		}

        if(msReadByte(REG_DPRX_DECODER_E0_0B_H + usRegOffsetDecoderByID) & BIT5) // PPS received ISR
        {
            msWriteByteMask(REG_DPRX_DECODER_E0_0D_H + usRegOffsetDecoderByID, BIT5, BIT5); // PPS received ISR mask

            msWriteByteMask(REG_DPRX_DECODER_E0_0F_H + usRegOffsetDecoderByID, BIT5, BIT5);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByteMask(REG_DPRX_DECODER_E0_0F_H + usRegOffsetDecoderByID, 0, BIT5);
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0B_H + usRegOffsetDecoderByID) & BIT7) // VBID compress flag been updated
        {
            msWriteByteMask(REG_DPRX_DECODER_E0_0D_H + usRegOffsetDecoderByID, BIT7, BIT7); // VBID compress flag been updated mask

            msWriteByteMask(REG_DPRX_DECODER_E0_0F_H + usRegOffsetDecoderByID, BIT7, BIT7);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByteMask(REG_DPRX_DECODER_E0_0F_H + usRegOffsetDecoderByID, 0, BIT7);
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0B_H + usRegOffsetDecoderByID) & BIT2) // vheight_unstable | (~msa_ignore_en & votal_unstable) | (~decompression_en & hwidth_unstable)
        {
			msWriteByteMask(REG_DPRX_DECODER_E0_0D_H + usRegOffsetDecoderByID, BIT2, BIT2);

            msWriteByte(REG_DPRX_DECODER_E0_0F_H + usRegOffsetDecoderByID, BIT2);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_H + usRegOffsetDecoderByID, 0);

            _mdrv_DPRx_MSCHIP_ScreenMute();
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_Aux_IRQ_Handler()
//  [Description]
//					mdrv_DPRx_Aux_IRQ_Handler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_Aux_IRQ_Handler(void)
{
    DPRx_ID dprx_id = DPRx_ID_MAX;
    DPRx_ID dprx_c_id = DPRx_ID_MAX;
    DPRx_ID dprx_id_offset = DPRx_ID_MAX;
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    BYTE ucInputPort;
    BYTE ubProgrammableHw_Index = 0x0;
    DPRx_ID OnLine_dprx_id = _mdrv_DPRx_GetOnlineRxID();

    UNUSED(ubProgrammableHw_Index); // Prevent warning

    for(dprx_id_offset = DPRx_ID_0; dprx_id_offset < DPRx_ID_MAX; dprx_id_offset++)
    {
        dprx_id = (OnLine_dprx_id + dprx_id_offset) % DPRx_ID_MAX; // online port first

        if(!(GET_DPRx_FUNCTION_ENABLE_PORT(dprx_id)))
        {
            continue;
        }

        dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
        ucInputPort = _mdrv_DPRx_MSCHIP_DPRxID2PortNumber(dprx_id);
        dprx_c_id = _mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id);

        if(mhal_DPRx_GetShortHPDIsrFlag(dprx_aux_id)) // Short HPD ISR mode
        {
            if((dprx_c_id != DPRx_ID_MAX) && (glDPRxInfo[dprx_id].bDPHpdState == TRUE))
            {
                glubTypeCShortHPD[dprx_c_id] = TRUE;
            }
        }

#if (DPRx_MCCS_SUPPORT == 0x1)
        mhal_DPRx_GetMCCSReceiveFlag(dprx_aux_id, ucInputPort);
#endif

#if (DPRX_PROGRAM_DPCD0_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_0;

        if(mhal_DPRx_GetProgramDPCD0Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD0Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD1_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_1;

        if(mhal_DPRx_GetProgramDPCD1Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD1Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD2_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_2;

        if(mhal_DPRx_GetProgramDPCD2Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD2Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD3_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_3;

        if(mhal_DPRx_GetProgramDPCD3Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD3Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD4_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_4;

        if(mhal_DPRx_GetProgramDPCD4Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD4Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD5_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_5;

        if(mhal_DPRx_GetProgramDPCD5Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD5Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD6_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_6;

        if(mhal_DPRx_GetProgramDPCD6Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD6Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD7_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_7;

        if(mhal_DPRx_GetProgramDPCD7Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD7Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD8_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_8;

        if(mhal_DPRx_GetProgramDPCD8Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD8Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
            if(OnLine_dprx_id != dprx_id)
            {
                glDPRxInfo[dprx_id].bHdcp22AuthinOffline = TRUE;
            }
        }
#endif

#if (DPRX_PROGRAM_DPCD9_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_9;

        if(mhal_DPRx_GetProgramDPCD9Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD9Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD10_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_10;

        if(mhal_DPRx_GetProgramDPCD10Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD10Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD11_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_11;

        if(mhal_DPRx_GetProgramDPCD11Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD11Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD12_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_12;

        if(mhal_DPRx_GetProgramDPCD12Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD12Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD13_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_13;

        if(mhal_DPRx_GetProgramDPCD13Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD13Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD14_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_14;

        if(mhal_DPRx_GetProgramDPCD14Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD14Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD15_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_15;

        if(mhal_DPRx_GetProgramDPCD15Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD15Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif


#if (DPRX_XDATA_PROGRAM_DPCD0_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_XDATAPROGRAM_DPCD_0;

        if(mhal_DPRx_GetXDATAProgramDPCD0Flag(dprx_aux_id))
        {
            mhal_DPRx_XDATAProgramDPCD0Proc(dprx_aux_id);
        }
#endif

#if (DPRX_XDATA_PROGRAM_DPCD1_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_XDATAPROGRAM_DPCD_1;

        if(mhal_DPRx_GetXDATAProgramDPCD1Flag(dprx_aux_id))
        {
            mhal_DPRx_XDATAProgramDPCD1Proc(dprx_aux_id);
        }
#endif
        if(mhal_DPRx_GetDPCD11AWriteFlag(dprx_aux_id)  == TRUE) // DPCD 0x11A
        {
        	mhal_DPRx_DPCD11AProc(dprx_aux_id);
        }

		//=========================================================================================================================
    	if(mhal_DPRx_GetDPCD100PMFlag(dprx_aux_id)  == TRUE) // DPCD 100
        {
        	mhal_DPRx_DPCD100PMProc(dprx_aux_id);
        }

        //=========================================================================================================================
    	if(mhal_DPRx_GetDPCD101PMFlag(dprx_aux_id)  == TRUE) // DPCD 101
        {
        	mhal_DPRx_DPCD101PMProc(dprx_aux_id);
        }

        //=========================================================================================================================
    	if(mhal_DPRx_GetDPCD108PMFlag(dprx_aux_id)  == TRUE) // DPCD 108
        {
			mhal_DPRx_DPCD108PMProc(dprx_aux_id);
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_TimerHandler()
//  [Description]
//					mdrv_DPRx_TimerHandler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_Timer_IRQ_Handler(void)
{
    volatile DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    volatile DPRx_ID dprx_id = DPRx_ID_MAX;
    volatile DPRx_ID dprx_c_id = DPRx_ID_MAX;
    volatile DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;
    volatile DPRx_PHY_ID dprx_phy_id = DPRx_PHY_ID_MAX;
    volatile BOOL bTrainingFlag = FALSE;

    if(mhal_DPRx_GetAuxPMClock() == 0x0)
    {
        return;
    }

    for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
    {
        if(GET_DPRx_FUNCTION_ENABLE_PORT(dprx_id))
        {
            dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
            dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);
            dprx_c_id = _mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id);

            for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
            {
                if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
                {
                    if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketTimer > 0)
                    {
                        glDPRxDecoderInfo[dprx_decoder_id].ucPacketTimer--;
                    }

                    if(glDPRxDecoderInfo[dprx_decoder_id].usDPCD246StableTimer > 0)
                	{
                		glDPRxDecoderInfo[dprx_decoder_id].usDPCD246StableTimer--;

                		if(glDPRxDecoderInfo[dprx_decoder_id].usDPCD246StableTimer == 0)
                		{
                		    glDPRxDecoderInfo[dprx_decoder_id].bDPCD246StableTimerUpFlag = TRUE;
                		}
                		else
                		{
                		    glDPRxDecoderInfo[dprx_decoder_id].bDPCD246StableTimerUpFlag = FALSE;
                		}
                	}

                	if(glDPRxDecoderInfo[dprx_decoder_id].usDPCD246OverwriteTimer > 0)
                	{
                		glDPRxDecoderInfo[dprx_decoder_id].usDPCD246OverwriteTimer--;

                		if(glDPRxDecoderInfo[dprx_decoder_id].usDPCD246OverwriteTimer == 0)
                		{
                		    mhal_DPRx_OverWriteDPCD246(dprx_aux_id, TRUE, 0x20);
                		}
                	}
                }
            }

            if(glDPRxInfo[dprx_id].uwDPRxStableTimeout > 0)
            {
                glDPRxInfo[dprx_id].uwDPRxStableTimeout--;
            }

            if(glDPRxInfo[dprx_id].uwCDRHPDCnt > 0)
            {
                glDPRxInfo[dprx_id].uwCDRHPDCnt--;

                // CDR lose lock
                if(glDPRxInfo[dprx_id].bDPLoseCDRLockIRQ)
                {
                    bTrainingFlag = mhal_DPRx_GetTrainingPatternFlag(dprx_id);
                    if((glDPRxInfo[dprx_id].uwCDRHPDCnt == 0) && (!bTrainingFlag))
                    {
                        if(mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort))
                        {
                            glDPRxInfo[dprx_id].bDPLoseCDRLockIRQ = FALSE;
                        }
                        else
                        {
                            glDPRxInfo[dprx_id].bDPLoseCDRLockIRQ = FALSE;

                            if(mhal_DPRx_CheckLossCDRStatus(dprx_aux_id))
                            {
                                mhal_DPRx_PHYCDRDetectEnable(dprx_phy_id, FALSE);
								_mdrv_DPRx_ShortHPD(dprx_id);
                                mhal_DPRx_SymbolEQResetEnable(dprx_id, TRUE);
                                mhal_DPRx_SymbolEQResetEnable(dprx_id, FALSE);
                                mhal_DPRx_PowerDownEQEnable(dprx_phy_id, TRUE);
                                mhal_DPRx_PowerDownEQEnable(dprx_phy_id, FALSE);
                                mhal_DPRx_PHYCDRDetectEnable(dprx_phy_id, TRUE);

                                // For type-C port, use mailbox to trigger short HPD event
                                if((dprx_c_id != DPRx_ID_MAX)  && (glDPRxInfo[dprx_id].bDPHpdState == TRUE))
                                {
                                    glubTypeCShortHPD[(BYTE)dprx_c_id] = TRUE;
                                }

                                mhal_DPRx_HDCP22SoftReset(dprx_id);
                            }
                        }
                    }
                }
            }

            if(glDPRxInfo[dprx_id].uwSkewHPDCnt > 0)
            {
                glDPRxInfo[dprx_id].uwSkewHPDCnt--;

                // Interlane skew lose
                if(glDPRxInfo[dprx_id].bDPInterlaneSkewLoseIRQ)
                {
                    bTrainingFlag = mhal_DPRx_GetTrainingPatternFlag(dprx_id);

                    if(mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort) == FALSE)
                    {
                        glDPRxInfo[dprx_id].bDPInterlaneSkewLoseIRQ = FALSE;
                    }
                    else if((glDPRxInfo[dprx_id].uwSkewHPDCnt == 0) && (!bTrainingFlag))
                    {
                        glDPRxInfo[dprx_id].bDPInterlaneSkewLoseIRQ = FALSE;

                        if(mhal_DPRx_CheckInterlaneSkewStatus(dprx_id, dprx_aux_id)) // Lock
                        {
                            _mdrv_DPRx_ShortHPD(dprx_id);
                        }
                    }
                }
            }

            if(glDPRxInfo[dprx_id].uwSinkStatusCnt > 0)
            {
                if(glDPRxInfo[dprx_id].uwSinkStatusCnt < 2)
                {
                    // For link CTS1.4, item 5.2.2.8 ESI Field Mapping, disable overwrite DPCD 205 and 200F
                    msWriteByteMask(REG_DPRX_DPCD1_4D_H + DP_REG_OFFSET_DPCD1(dprx_id), 0, BIT0|BIT1|BIT2);
                }

                glDPRxInfo[dprx_id].uwSinkStatusCnt--;
            }

            if(glDPRxInfo[dprx_id].uwHDCPCnt > 0)
            {
                glDPRxInfo[dprx_id].uwHDCPCnt--;
            }

            if(glDPRxInfo[dprx_id].ucHDCPThreeStepReauthTimer > 0)
            {
                glDPRxInfo[dprx_id].ucHDCPThreeStepReauthTimer--;
            }

            if(glDPRxInfo[dprx_id].uwDPStableCount > 0)
            {
                glDPRxInfo[dprx_id].uwDPStableCount--;
            }

            if(glDPRxInfo[dprx_id].ucInterlaceCount> 0)
            {
                glDPRxInfo[dprx_id].ucInterlaceCount--;
            }

            if(glDPRxInfo[dprx_id].bAudioRecoverCnt> 0)
            {
                glDPRxInfo[dprx_id].bAudioRecoverCnt--;
            }

            if(glDPRxInfo[dprx_id].ubContDownTimer > 0)
            {
                glDPRxInfo[dprx_id].ubContDownTimer--;
            }

            if(glDPRxInfo[dprx_id].ucHDCPLongHPDTimer > 0)
            {
                glDPRxInfo[dprx_id].ucHDCPLongHPDTimer--;
            }

            if(glDPRxInfo[dprx_id].ubSQStableTimer > 0)
            {
                glDPRxInfo[dprx_id].ubSQStableTimer--;
            }

			if(glDPRxInfo[dprx_id].usFastTrainUnLockTimer > 0)
            {
                glDPRxInfo[dprx_id].usFastTrainUnLockTimer--;
            }
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_Timer_variable_Reset()
//  [Description]
//                  _mdrv_DPRx_Timer_variable_Reset
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_Timer_variable_Reset(void)
{
    DPRx_ID dprx_id = DPRx_ID_MAX;
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;

    for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
    {
        glDPRxInfo[dprx_id].uwDPRxStableTimeout=0;
        glDPRxInfo[dprx_id].uwCDRHPDCnt=0;
        glDPRxInfo[dprx_id].uwSkewHPDCnt=0;
        glDPRxInfo[dprx_id].uwSinkStatusCnt=0;
        glDPRxInfo[dprx_id].uwHDCPCnt=0;
        glDPRxInfo[dprx_id].ucHDCPThreeStepReauthTimer=0;
        glDPRxInfo[dprx_id].uwDPStableCount=0;
        glDPRxInfo[dprx_id].ucInterlaceCount=0;
        glDPRxInfo[dprx_id].bAudioRecoverCnt=0;
        glDPRxInfo[dprx_id].ubContDownTimer=0;
        glDPRxInfo[dprx_id].ucHDCPLongHPDTimer=0;
        glDPRxInfo[dprx_id].ubSQStableTimer=0;
    }

    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketTimer=0;
        glDPRxDecoderInfo[dprx_decoder_id].usDPCD246StableTimer=0;
        glDPRxDecoderInfo[dprx_decoder_id].usDPCD246OverwriteTimer=0;
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_Timer_TimeUp_Handler()
//  [Description]
//                  mdrv_DPRx_Timer_TimeUp_Handler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
VOID mdrv_DPRx_Timer_TimeUp_Handler(void)
{
    DPRx_ID dprx_id = DPRx_ID_MAX;
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    volatile DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;
    static WORD usPreviousCRCValue[3] = {0};
    static WORD usCurrentCRCValue[3] = {0};
    static BYTE ucCRC_Count[DPRx_DECODER_ID_MAX] = {0};

    for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
    {
        dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
        dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

		if(((mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_00270) & BIT0) == BIT0) &&
		    (glDPRxDecoderInfo[dprx_decoder_id].bDPCD246StableTimerUpFlag == TRUE) &&
		    (dprx_decoder_id != DPRx_DECODER_ID_MAX))
		{
            if(ucCRC_Count[dprx_decoder_id] == 0)
		    {
		        mhal_DPRx_CRC_Get(dprx_decoder_id, usPreviousCRCValue);

		        if((usPreviousCRCValue[0] != 0) || (usPreviousCRCValue[1] != 0) || (usPreviousCRCValue[2] != 0))
		        {
		            glDPRxDecoderInfo[dprx_decoder_id].usDPCD246StableTimer = DPRX_CRC_STABLE_TIMER_CNT;
                    ucCRC_Count[dprx_decoder_id]++;
		        }
		    }
		    else if(ucCRC_Count[dprx_decoder_id] > 0)
		    {
		        mhal_DPRx_CRC_Get(dprx_decoder_id, usCurrentCRCValue);

    		    if((usCurrentCRCValue[0] == usPreviousCRCValue[0]) &&
    		       (usCurrentCRCValue[1] == usPreviousCRCValue[1]) &&
    		       (usCurrentCRCValue[2] == usPreviousCRCValue[2]) &&
    		       ((usCurrentCRCValue[0] != 0) || (usCurrentCRCValue[1] != 0) || (usCurrentCRCValue[2] != 0)))
    		    {
    		        if(ucCRC_Count[dprx_decoder_id] == DPRX_CRC_FRAME_CHECK_CNT)
    		        {
        		        mhal_DPRx_OverWriteDPCD246(dprx_aux_id, FALSE, 0);
        		        glDPRxDecoderInfo[dprx_decoder_id].usDPCD246OverwriteTimer = DPRX_DPCD246_VALID_TIMER_CNT;
        		        ucCRC_Count[dprx_decoder_id] = 0;
    		        }
    		        else
    		        {
    		            glDPRxDecoderInfo[dprx_decoder_id].usDPCD246StableTimer = DPRX_CRC_STABLE_TIMER_CNT;
    		            ucCRC_Count[dprx_decoder_id]++;
    		        }
    		    }
    		    else
    		    {
    		        glDPRxDecoderInfo[dprx_decoder_id].usDPCD246StableTimer = DPRX_CRC_STABLE_TIMER_CNT;
    		        ucCRC_Count[dprx_decoder_id] = 0;
    		    }
		    }
		}
    }

    return;
}

void ________HDCP________(void);
#if (DPRX_HDCP14_Repeater_ENABLE == 0x1)
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_HDCP14MapDPCDWrite()
//  [Description]
//					mdrv_DPRx_HDCP14MapDPCDWrite
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_HDCP14MapDPCDWrite(DPRx_ID dprx_id, BYTE u8OffsetAddr, BYTE ucLength, BYTE *pucData)
{
    //BOOL bRet;

    dprx_id = dprx_id;
    u8OffsetAddr = u8OffsetAddr;
    ucLength = 0;
    pucData = pucData;
    /*
    switch(u8OffsetAddr)
    {
        case DPTX_HDCP1_OFFSETADDR_BStatus:
            mhal_DPRx_HDCP14WriteBinfo(dprx_id, pucData[1], pucData[0]);
        	break;

        case DPTX_HDCP1_OFFSETADDR_VPrime:
            mhal_DPRx_HDCP14WriteV(dprx_id, pucData);
        	break;

        case DPTX_HDCP1_OFFSETADDR_BCaps:
            bRet = (pucData[0] & BIT5)? TRUE : FALSE;

            if(bRet == TRUE)
            {
                glDPRxInfo[DPRx_ID_0].bHDCP14TriggerShortHPD = TRUE;
            }
        	break;

        default:
        	break;
    }
    */
    return;
}

//**************************************************************************
//  [Function Name]:
//                  mhal_DPRx_HDCP14WriteKSVFIFO()
//  [Description]
//					mdrv_DPRx_HDCP14WriteKSVFIFO
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_HDCP14WriteKSVFIFO(DPRx_ID dprx_id, WORD u16length, BYTE *BKSVData)
{
    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    mhal_DPRx_HDCP14WriteKSVFIFO(dprx_id, u16length, BKSVData);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_HDCP14ConfigRepeaterPair()
//  [Description]
//					mdrv_DPRx_HDCP14ConfigRepeaterPair
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_HDCP14ConfigRepeaterPair(DPRx_ID dprx_id, BYTE ucOutputPort, BOOL bEnable)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    static BYTE XDATA ucLASTID;

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    ucOutputPort = ucOutputPort;

    if(bEnable == TRUE)
    {
        mhal_DPRx_HDCP14RepeaterEnable(dprx_id, dprx_aux_id, bEnable);
        ucLASTID = dprx_id;
    }

    return;
}
#endif

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_ClearAKSVFlag()
//  [Description]
//					mdrv_DPRx_ClearAKSVFlag
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_ClearAKSVFlag(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    mhal_DPRx_ClearAKSVFlag(dprx_aux_id);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_CheckHDCPState()
//  [Description]
//                  check HDCP is 1.4 or 2.2 or no encryption
//  [Arguments]:
//
//  [Return]:
//                  HDCP1.4 or HDCP2.2 or no encryption
//
//**************************************************************************
DP_HDCP_STATE mdrv_DPRx_CheckHDCPState(DPRx_ID dprx_id)
{
    if(dprx_id == DPRx_ID_MAX)
    {
        return DP_HDCP_NO_ENCRYPTION;
    }

    return mhal_DPRx_CheckHDCPState(dprx_id);
}

#if (DPRX_HDCP2_ENABLE == 0x1)
//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_HDCP2GetRxData()
//  [Description]
//					_mdrv_DPRx_HDCP2GetRxData
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL _mdrv_DPRx_HDCP2GetRxData(DPRx_ID dprx_id, BYTE ucMessageID, BYTE *pHDCPData)
{
    BOOL bGetData = FALSE;

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    switch(ucMessageID)
    {
        case DP_HDCP2_MSG_ID_AKE_INIT:
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_AKE_RTX, pHDCPData);
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_AKE_TXCAPS, &pHDCPData[DP_HDCP2_AKE_RTX_SIZE]);
            break;

        case DP_HDCP2_MSG_ID_AKE_NO_STORED_KM:
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_AKE_EKPUB_KM, pHDCPData);
            break;

        case DP_HDCP2_MSG_ID_AKE_STORED_KM:
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_AKE_EKH_KM_WR, pHDCPData);
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_AKE_M, &pHDCPData[DP_HDCP2_AKE_EKH_KM_WR_SIZE]);
            break;

        case DP_HDCP2_MSG_ID_LC_INIT:
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_LC_RN, pHDCPData);
            break;

        case DP_HDCP2_MSG_ID_SKE_SEND_EKS:
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_SKE_EDKEY_KS, pHDCPData);
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_SKE_RIV, &pHDCPData[DP_HDCP2_SKE_EDKEY_KS_SIZE]);
            break;

        case DP_HDCP2_MSG_ID_REPAUTH_SEND_ACK:
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_ACK_SEND_ACK_V, pHDCPData);
            break;

        case DP_HDCP2_MSG_ID_REPAUTH_STREAM_MANAGE:
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_STREAM_SEQ_NUM_M, pHDCPData);
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_STREAM_k, &pHDCPData[DP_HDCP2_STREAM_SEQ_NUM_M_SIZE]);
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_STREAM_STREAM_ID_TYPE, &pHDCPData[DP_HDCP2_STREAM_SEQ_NUM_M_SIZE + DP_HDCP2_STREAM_k_SIZE]);
            break;

        default:
            break;
    }

    return bGetData;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_HDCP2SetTxData()
//  [Description]
//					_mdrv_DPRx_HDCP2SetTxData
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_HDCP2SetTxData(DPRx_ID dprx_id, BYTE ucMessageID, BYTE *pHDCPData)
{
    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    switch(ucMessageID)
    {
        case DP_HDCP2_MSG_ID_AKE_SEND_CERT:
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_AKE_RRX, pHDCPData);
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_AKE_RXCAPS, &pHDCPData[DP_HDCP2_AKE_RRX_SIZE]);
            break;

        case DP_HDCP2_MSG_ID_AKE_SEND_H_PRIME:
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_AKE_H_PRIME, pHDCPData);

            glDPRxInfo[dprx_id].bHDCP22TriggerShortHPD = TRUE;
            glDPRxInfo[dprx_id].u8HDCP22MsgID = DP_HDCP2_MSG_ID_AKE_SEND_H_PRIME;
            break;

        case DP_HDCP2_MSG_ID_AKE_SEND_PAIRING_INFO:
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_AKE_EKH_KM_RD, pHDCPData);

            glDPRxInfo[dprx_id].bHDCP22TriggerShortHPD = TRUE;
            glDPRxInfo[dprx_id].u8HDCP22MsgID = DP_HDCP2_MSG_ID_AKE_SEND_PAIRING_INFO;
            break;

        case DP_HDCP2_MSG_ID_LC_SEND_L_PRIME:
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_LC_L_PRIME, pHDCPData);
            break;

        case DP_HDCP2_MSG_ID_REPAUTH_SEND_RECVID_LIST:
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_RECVLIST_RXINFO, pHDCPData);
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_RECVLIST_SEQ_NUM_V, &pHDCPData[DP_HDCP2_RECVLIST_RXINFO_SIZE]);
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_RECVLIST_VPRIME, &pHDCPData[DP_HDCP2_RECVLIST_RXINFO_SIZE + DP_HDCP2_RECVLIST_SEQ_NUM_V_SIZE]);
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_RECVLIST_RECEIVER_ID_LIST, &pHDCPData[DP_HDCP2_RECVLIST_RXINFO_SIZE + DP_HDCP2_RECVLIST_SEQ_NUM_V_SIZE + DP_HDCP2_RECVLIST_VPRIME_SIZE]);

            glDPRxInfo[dprx_id].bHDCP22TriggerShortHPD = TRUE;
            glDPRxInfo[dprx_id].u8HDCP22MsgID = DP_HDCP2_MSG_ID_REPAUTH_SEND_RECVID_LIST;
            break;

        case DP_HDCP2_MSG_ID_REPAUTH_STREAM_READY:
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_STREAM_MPRIME, pHDCPData);
            break;

        default:
            break;
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_HDCP2Handler()
//  [Description]
//					_mdrv_DPRx_HDCP2Handler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_HDCP2Handler(DPRx_ID dprx_id)
{
    static BYTE ucHDCPCStatusDelayCnt[DPRx_ID_MAX] = {0x0};
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    // HDCP22 trigger short HPD
    if(glDPRxInfo[dprx_id].bHDCP22TriggerShortHPD == TRUE)
    {
        if(glDPRxInfo[dprx_id].u8HDCP22MsgID == DP_HDCP2_MSG_ID_AKE_SEND_H_PRIME)
        {
            glDPRxInfo[dprx_id].bHDCP22TriggerShortHPD = FALSE;
            glDPRxInfo[dprx_id].u8HDCP22MsgID = DP_HDCP2_MSG_ID_NONE;

            mhal_DPRx_HDCP2SetRxStatus(dprx_id, DP_HDCP2_RXSTATUS_H_PRIME_AVAILABLE, TRUE);
            mhal_DPRx_HDCP2SetRxStatus(dprx_id, DP_HDCP2_RXSTATUS_H_PRIME_AVAILABLE, FALSE);
            mhal_DPRx_SetCPIRQ(dprx_aux_id);
            _mdrv_DPRx_ShortHPD(dprx_id);

            DP_DRV_DPRINTF("H' HPD ID#%d", dprx_id);
        }
        else if(glDPRxInfo[dprx_id].u8HDCP22MsgID == DP_HDCP2_MSG_ID_AKE_SEND_PAIRING_INFO)
        {
            if(ucHDCPCStatusDelayCnt[dprx_id] < 0x5) //patch H' not reply complete but short hpd be triggered
            {
                ucHDCPCStatusDelayCnt[dprx_id]++;
                return;
            }
            else
            {
                ucHDCPCStatusDelayCnt[dprx_id] = 0x0;
            }

            glDPRxInfo[dprx_id].bHDCP22TriggerShortHPD = FALSE;
            glDPRxInfo[dprx_id].u8HDCP22MsgID = DP_HDCP2_MSG_ID_NONE;

            mhal_DPRx_HDCP2SetRxStatus(dprx_id, DP_HDCP2_RXSTATUS_PAIRING_AVAILABLE, TRUE);
            mhal_DPRx_HDCP2SetRxStatus(dprx_id, DP_HDCP2_RXSTATUS_PAIRING_AVAILABLE, FALSE);
            mhal_DPRx_SetCPIRQ(dprx_aux_id);
            _mdrv_DPRx_ShortHPD(dprx_id);

            DP_DRV_DPRINTF("Paring HPD ID#%d", dprx_id);
        }
        else if(glDPRxInfo[dprx_id].u8HDCP22MsgID == DP_HDCP2_MSG_ID_REPAUTH_SEND_RECVID_LIST)
        {

            glDPRxInfo[dprx_id].bHDCP22TriggerShortHPD = FALSE;
            glDPRxInfo[dprx_id].u8HDCP22MsgID = DP_HDCP2_MSG_ID_NONE;

            mhal_DPRx_HDCP2SetRxStatus(dprx_id, DP_HDCP2_RXSTATUS_READY, TRUE);
            mhal_DPRx_HDCP2SetRxStatus(dprx_id, DP_HDCP2_RXSTATUS_READY, FALSE);
            mhal_DPRx_SetCPIRQ(dprx_aux_id);
            _mdrv_DPRx_ShortHPD(dprx_id);
            DP_DRV_DPRINTF("Rdy HPD ID#%d", dprx_id);
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetHDCP2CallBackFunction()
//  [Description]
//					mdrv_DPRx_SetHDCP2CallBackFunction
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetHDCP2CallBackFunction(DPRx_HDCP2_CB_FUNC pHDCP2RxFunc)
{
    pmdrv_DP_HDCP2RxEventProc = pHDCP2RxFunc;

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetHDCP2ConfigRepeaterCallBackFunction()
//  [Description]
//					mdrv_DPRx_SetHDCP2ConfigRepeaterCallBackFunction
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetHDCP2ConfigRepeaterCallBackFunction(DPRX_HDCP2_Config_Repeater_CB_FUNC pHDCP2RxConfig_RepeaterFunc)
{
    pmdrv_DPRX_HDCP2_Config_Repeater_CB_FUNC = pHDCP2RxConfig_RepeaterFunc;

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_HDCP2TxEventProc()
//  [Description]
//					mdrv_DPRx_HDCP2TxEventProc
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_HDCP2TxEventProc(DPRx_ID dprx_id, BYTE ucMessageID, BYTE *pMessageData)
{
    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    _mdrv_DPRx_HDCP2SetTxData(dprx_id, ucMessageID, pMessageData);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_HDCP2SetCertRx()
//  [Description]
//					mdrv_DPRx_HDCP2SetCertRx
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_HDCP2SetCertRx(BYTE *pHDCP2CertRx)
{
    DPRx_ID dprx_id = DPRx_ID_0;

    mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_AKE_CERTRX, pHDCP2CertRx);

    mhal_DPRx_EnableHDCP2EventMask(dprx_id, TRUE); // Enable HDCP22 event mask
#if(DPRx_HDCP2_ISR_MODE == 0x1)
    mhal_DPRx_EnableHDCP2Interrupt(dprx_id, TRUE); // Enable HDCP22 interrupt
#endif

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_HDCP2SetRxCaps()
//  [Description]
//					mdrv_DPRx_HDCP2SetRxCaps
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_HDCP2SetRxCaps(DPRx_ID dprx_id, BOOL bEnable)
{
    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    mhal_DPRx_HDCP2SetRxCaps(dprx_id, bEnable);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_HDCP22RepeaterGetRxinfo()
//  [Description]
//					mdrv_DPRx_HDCP22RepeaterGetRxinfo
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_HDCP22RepeaterGetRxinfo(DPRx_ID dprx_id, BYTE *pRxInfo_Hbyte, BYTE *pRxInfo_Lbyte)
{
    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    mhal_DPRx_HDCP22ReadRxinfo(dprx_id, pRxInfo_Hbyte, pRxInfo_Lbyte);

    return;
}

#if (DPRx_HDCP2_ISR_MODE == 0x1)
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_HDCP2FetchMsg()
//  [Description]
//					mdrv_DPRx_HDCP2FetchMsg
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_HDCP2FetchMsg(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    if(mhal_DPRx_GetHDCP2IrqFlag(dprx_id)) // BK1106_2D[13]: dp_hdcp22_irq
    {
        // HDCP22 client 1 interrupt event
        if(mhal_DPRx_GetHDCP2AKEInitFlag(dprx_id)) // BK110B_70[1]: ake_init_irq_status
        {
            ucHDCPData[0] = DP_HDCP2_MSG_ID_AKE_INIT;

            // Reset HDCP HPD status
            glDPRxInfo[dprx_id].bHDCP22TriggerShortHPD = FALSE;
            glDPRxInfo[dprx_id].u8HDCP22MsgID = DP_HDCP2_MSG_ID_NONE;
            glDPRxInfo[dprx_id].bForceIntegrityFail = FALSE;
            glDPRxInfo[dprx_id].bHdcp22StartAuth = TRUE;

            mhal_DPRx_ForceHDCP13IntegrityFail(dprx_id, FALSE);
            mhal_DPRx_ForceHDCP22IntegrityFail(dprx_id, FALSE);

            // Overread to reset RX status H' and pairing available
            mhal_DPRx_EnableHDCP2ReadDownInterrupt(dprx_id, FALSE);
            mhal_DPRx_MCUReadNonPMDPCD(dprx_id, dprx_aux_id, DP_HDCP2_DPCD_HprimeReadDone);
            mhal_DPRx_MCUReadNonPMDPCD(dprx_id, dprx_aux_id, DP_HDCP2_DPCD_PairingReadDone);
            mhal_DPRx_EnableHDCP2ReadDownInterrupt(dprx_id, TRUE);

            // Trigger repeater TX start Auth to sink
            mhal_DPRx_MCUReadNonPMDPCD(dprx_id, dprx_aux_id, DP_HDCP2_DPCD_Rxinfo); // Reset RX status ready
        }
        else if(mhal_DPRx_GetHDCP2NoStoredKmFlag(dprx_id)) // BK110B_70[2]: ake_no_stored_km_status
        {
            ucHDCPData[0] = DP_HDCP2_MSG_ID_AKE_NO_STORED_KM;
        }
        else if(mhal_DPRx_GetHDCP2StoredKmFlag(dprx_id)) // BK110B_70[3]: ake_stored_km_status
        {
            ucHDCPData[0] = DP_HDCP2_MSG_ID_AKE_STORED_KM;
        }
        else if(mhal_DPRx_GetHDCP2LCInitFlag(dprx_id)) // BK110B_70[4]: locality_check_status
        {
            ucHDCPData[0] = DP_HDCP2_MSG_ID_LC_INIT;
        }
        else if(mhal_DPRx_GetHDCP2SKEFlag(dprx_id)) // BK110B_70[5]: ske_irq
        {
            ucHDCPData[0] = DP_HDCP2_MSG_ID_SKE_SEND_EKS;
        }
        else if(mhal_DPRx_GetHDCP2HprimeReadDoneFlag(dprx_id)) // BK110B_78[8]: h_pulum_status
        {
            ucHDCPData[0] = DP_HDCP2_MSG_ID_NONE;
        }
        else if(mhal_DPRx_GetHDCP2RepAuthSendAckFlag(dprx_id)) // BK160B_79[1]: repauth_send_ack
        {
            ucHDCPData[0] = DP_HDCP2_MSG_ID_REPAUTH_SEND_ACK;
        }
        else if(mhal_DPRx_GetHDCP2RepAuthStreamManageFlag(dprx_id)) // BK160B_79[2]: repauth_stream_manage
        {
            ucHDCPData[0] = DP_HDCP2_MSG_ID_REPAUTH_STREAM_MANAGE;
        }
        else
        {
            return;
        }

        _mdrv_DPRx_HDCP2GetRxData(dprx_id, ucHDCPData[0], &ucHDCPData[1]);

        if(pmdrv_DP_HDCP2RxEventProc != NULL) // Have call back function
        {
            pmdrv_DP_HDCP2RxEventProc(0, ucHDCPData);
        }

        // Turn on mask avoid edge trigger interrupt conflict in next time
        mhal_DPRx_EnableHDCP2Interrupt(dprx_id, FALSE); // Disble HDCP22 IRQ mask
        mhal_DPRx_EnableHDCP2EventMask(dprx_id, FALSE); // Disble HDCP22 event mask

        // Turn off mask avoid edge trigger interrupt conflict in next time
        mhal_DPRx_EnableHDCP2Interrupt(dprx_id, TRUE); // Enable HDCP22 IRQ mask
        mhal_DPRx_EnableHDCP2EventMask(dprx_id, TRUE); // Enable HDCP22 event mask
    }

    return;
}
#endif
#endif

void ________TYPE_C________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetDataLaneSettings()
//  [Description]
//					mdrv_DPRx_SetDataLaneSettings
//  [Arguments]:
//					ubTargetLaneNumber: [1:0] for Lane0,
//										[3:2] for Lane1,
//										[5:4] for Lane2,
//										[7:6] for Lane3
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_SetDataLaneSettings(DPRx_ID dprx_id, BOOL bEnable, BYTE ubTargetLaneNumber)
{
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);
    DPRx_ID dprx_online_id = _mdrv_DPRx_GetOnlineRxID();

    if((dprx_id == DPRx_ID_MAX) || (dprx_phy_id == DPRx_PHY_ID_MAX))
    {
        return FALSE;
    }

    if((glDPRxInfo[dprx_id].ubTypeC_PinAssign == 0x0) || (glDPRxInfo[dprx_id].ubTypeC_CC == 0x2))
    {

    }
    else if((glDPRxInfo[dprx_id].ubTypeC_PinAssign == BIT2) || (glDPRxInfo[dprx_id].ubTypeC_PinAssign == BIT3)) // pinC D
    {
        if(glDPRxInfo[dprx_id].ubTypeC_CC == 0x1)
        {
            if(dprx_online_id == dprx_id)
            {
                mhal_DPRx_SetPHYPRBS7PNSwapEnable(dprx_phy_id, 0);
                mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, 1);
                mhal_DPRx_LanePNSwapEnable_Set(dprx_id, 0);
            }

            ubTargetLaneNumber = 0x39;
        }
        else if(glDPRxInfo[dprx_id].ubTypeC_CC == 0x0)
        {
            if(dprx_online_id == dprx_id)
            {
                mhal_DPRx_SetPHYPRBS7PNSwapEnable(dprx_phy_id, 0);
                mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, 0);
                mhal_DPRx_LanePNSwapEnable_Set(dprx_id, 0);
            }

            ubTargetLaneNumber = 0x6C;
        }
    }
    else if(glDPRxInfo[dprx_id].ubTypeC_PinAssign == BIT4) // pinE
    {
        if(glDPRxInfo[dprx_id].ubTypeC_CC == 0x1)
        {
            if(dprx_online_id == dprx_id)
            {
                mhal_DPRx_SetPHYPRBS7PNSwapEnable(dprx_phy_id, BIT7|BIT6|BIT5|BIT4);
                mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, 3);
                mhal_DPRx_LanePNSwapEnable_Set(dprx_id, BIT0|BIT1|BIT2|BIT3);
            }

            ubTargetLaneNumber = 0x93;
        }
        else if(glDPRxInfo[dprx_id].ubTypeC_CC == 0x0)
        {
            if(dprx_online_id == dprx_id)
            {
                mhal_DPRx_SetPHYPRBS7PNSwapEnable(dprx_phy_id, BIT7|BIT6|BIT5|BIT4);
                mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, 2);
                mhal_DPRx_LanePNSwapEnable_Set(dprx_id, BIT0|BIT1|BIT2|BIT3);
            }

            ubTargetLaneNumber = 0xC6;
        }
    }

	if(_mdrv_DPRx_MSCHIP_DPRxID2PortNumber(dprx_id) != Input_UsbTypeC_C3) // Update ACDR lane if lane swap
    {
        mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, ubTargetLaneNumber & (BIT1|BIT0));
    }

    //printf("rxid %d set lane swap enable  pin %x cc %x\r\n",dprx_id,glDPRxInfo[dprx_id].ubTypeC_PinAssign,glDPRxInfo[dprx_id].ubTypeC_CC,ubTargetLaneNumber);
    mhal_DPRx_SetPHYLaneSwapEnable(dprx_id, dprx_phy_id, bEnable, ubTargetLaneNumber);
    glTypeC_PhyLaneSwap[dprx_id] = ubTargetLaneNumber;

    return TRUE;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetAuxLaneSettings()
//  [Description]
//					mdrv_DPRx_SetAuxLaneSettings
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_SetAuxLaneSettings(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return FALSE;
    }

    if((glDPRxInfo[dprx_id].ubTypeC_PinAssign == 0x0) || (glDPRxInfo[dprx_id].ubTypeC_CC == 0x2))
    {
        Init_TYPEC_A_AUX_TRI();
        Init_TYPEC_A_AUX_P();
        Init_TYPEC_A_AUX_N();
    }
    else if((glDPRxInfo[dprx_id].ubTypeC_PinAssign == BIT2) || (glDPRxInfo[dprx_id].ubTypeC_PinAssign == BIT3)) // pinC D
    {
        if(glDPRxInfo[dprx_id].ubTypeC_CC == 0x1)
        {
            hw_Clr_TYPEC_A_AUX_P();
            hw_Set_TYPEC_A_AUX_N();
            hw_Set_TYPEC_A_AUX_TRI();

            mhal_DPRx_SetAuxPNSwapEnable(dprx_aux_id,TRUE);
        }
        else if(glDPRxInfo[dprx_id].ubTypeC_CC == 0x0)
        {
            hw_Set_TYPEC_A_AUX_P();
            hw_Clr_TYPEC_A_AUX_N();
            hw_Set_TYPEC_A_AUX_TRI();

            mhal_DPRx_SetAuxPNSwapEnable(dprx_aux_id,FALSE);
        }
    }
    else if(glDPRxInfo[dprx_id].ubTypeC_PinAssign == BIT4) // pinE
    {
        if(glDPRxInfo[dprx_id].ubTypeC_CC == 0x1)
        {
            hw_Set_TYPEC_A_AUX_P();
            hw_Clr_TYPEC_A_AUX_N();
            hw_Set_TYPEC_A_AUX_TRI();

            mhal_DPRx_SetAuxPNSwapEnable(dprx_aux_id,FALSE);
        }
        else if(glDPRxInfo[dprx_id].ubTypeC_CC == 0x0)
        {
            hw_Clr_TYPEC_A_AUX_P();
            hw_Set_TYPEC_A_AUX_N();
            hw_Set_TYPEC_A_AUX_TRI();

            mhal_DPRx_SetAuxPNSwapEnable(dprx_aux_id,TRUE);
        }
    }

    return TRUE;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetLanePNSwapEnable()
//  [Description]
//					mdrv_DPRx_SetLanePNSwapEnable
//  [Arguments]:
//					ubLanePNSwapSelect: BIT0 for Lane0, BIT1 for Lane1, BIT2 for Lane2, BIT3 for Lane3, only work when b4LanePNSwap = TRUE
//					ubTargetLaneNumber: [1:0] for Lane0, [3:2] for Lane1, [5:4] for Lane2 , [7:6] for Lane3
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_SetLanePNSwapEnable(DPRx_ID dprx_id, BOOL bEnable, BOOL bAuxPNSwap, BOOL b4LanePNSwap, BYTE ubLanePNSwapSelect)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    BYTE bRet = FALSE;

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return FALSE;
    }

    if(INPUT_IS_USBTYPEC3(SrcInputType) == TRUE)
    {
        mhal_DPRx_SetHwHPDControlEnable(dprx_aux_id, FALSE);
    }

    if(b4LanePNSwap == FALSE || bEnable == FALSE)
    {
        ubLanePNSwapSelect = 0;
    }

    bRet = mhal_DPRx_LanePNSwapEnable_Set(dprx_id, ubLanePNSwapSelect);
    bRet = mhal_DPRx_SetAuxPNSwapEnable(dprx_aux_id, (bEnable & bAuxPNSwap)) & bRet;

    return bRet;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetTypeCInfo()
//  [Description]
//					mdrv_DPRx_SetTypeCInfo
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_SetTypeCInfo(DPRx_ID dprx_id, BYTE ubCCpinInfo, BYTE ubPinAssingInfo)
{
    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    glDPRxInfo[dprx_id].ubTypeC_CC = ubCCpinInfo;
    glDPRxInfo[dprx_id].ubTypeC_PinAssign = ubPinAssingInfo;

    if(ubCCpinInfo < 2)
    {
        glDPRxInfo[dprx_id].bDPcableConnent = TRUE;
    }
    else
    {
        glDPRxInfo[dprx_id].bDPcableConnent = FALSE;
    }

    return TRUE;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetEQ_Current()
//  [Description]
//					mdrv_DPRx_SetEQ_Current
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_SetEQ_Current(DPRx_ID dprx_id, BOOL eq_current)
{
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_phy_id == DPRx_PHY_ID_MAX))
    {
        return FALSE;
    }

    mhal_DPRx_SetEQ_Current(dprx_phy_id, eq_current);

    return TRUE;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetTypeCHPDEvent()
//  [Description]
//					mdrv_DPRx_GetTypeCHPDEvent
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetTypeCHPDEvent(DPRx_ID dprx_id, BYTE *ucHPDValue)
{
    DPRx_ID dprx_c_id = _mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id);

    if(dprx_id == DPRx_ID_MAX || dprx_c_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    *ucHPDValue = glubTypeCHPDCtrl[dprx_c_id];

    return glubTriggerTypeCHPDFlag[dprx_c_id];
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_ClrTypeCHPDEvent()
//  [Description]
//					mdrv_DPRx_ClrTypeCHPDEvent
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_ClrTypeCHPDEvent(DPRx_ID dprx_id)
{
    DPRx_ID dprx_c_id = _mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id);

    if(dprx_id == DPRx_ID_MAX || dprx_c_id == DPRx_ID_MAX)
    {
        return;
    }

    glubTypeCHPDCtrl[dprx_c_id] = FALSE;
    glubTriggerTypeCHPDFlag[dprx_c_id] = FALSE;

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetTypeCShortHPDEvent()
//  [Description]
//					mdrv_DPRx_GetTypeCShortHPDEvent
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetTypeCShortHPDEvent(DPRx_ID dprx_id)
{
    DPRx_ID dprx_c_id = _mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id);

    if(dprx_id == DPRx_ID_MAX || dprx_c_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    return glubTypeCShortHPD[dprx_c_id];
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_ClrTypeCShortHPDEvent()
//  [Description]
//					mdrv_DPRx_ClrTypeCShortHPDEvent
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_ClrTypeCShortHPDEvent(DPRx_ID dprx_id)
{
    DPRx_ID dprx_c_id = _mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id);

    if(dprx_id == DPRx_ID_MAX || dprx_c_id  == DPRx_ID_MAX)
    {
        return;
    }

    glubTypeCShortHPD[dprx_c_id] = FALSE;

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_TypeC_CableDisconect()
//  [Description]
//					mdrv_DPRx_TypeC_CableDisconect
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_TypeC_CableDisconect(DPRx_ID dprx_id)
{
    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    if(_mdrv_DPRx_CTSCheck(dprx_id)) // For PHY CTS
    {
        return;
    }

    _mdrv_DPRx_CableDisconnectReset(dprx_id);

    return;
}

void ________POWER________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_IsSystemGoRealSleep()
//  [Description]
//					mdrv_DPRx_IsSystemGoRealSleep
//  [Arguments]:
//
//  [Return]:
//            		TRUE: Real PM mode, FASE: Fake sleep mode
//**************************************************************************
BOOL mdrv_DPRx_IsSystemGoRealSleep(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX) || (dprx_phy_id == DPRx_PHY_ID_MAX))
    {
        return FALSE;
    }

    if(_mdrv_DPRx_CTSCheck(dprx_id)) // For PHY CTS
    {
        return FALSE;
    }

    if(mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort) == TRUE)
    {
        return FALSE;
    }
    else if(mdrv_DPRx_AUX_N_Level(dprx_id) && mhal_DPRx_CheckSquelch(dprx_id))
    {
        return FALSE;
    }

    return TRUE;
}

void ________MSCHIP________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_MSCHIP_CableDetect()
//  [Description]
//					mdrv_DPRx_MSCHIP_CableDetect
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_MSCHIP_CableDetect(DPRx_ID dprx_id)
{
    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    return glDPRxInfo[dprx_id].bDPcableConnent;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_MSCHIP_EnableDPDetect()
//  [Description]
//					mdrv_DPRx_MSCHIP_EnableDPDetect
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_MSCHIP_EnableDPDetect(BYTE ucPMMode, BOOL bEnable)
{
    DPRx_ID dprx_id = DPRx_ID_MAX;
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;
    DPRx_PHY_ID dprx_phy_id = DPRx_PHY_ID_MAX;
    WORD usRegOffsetAuxPM0ByID = DP_REG_OFFSET_AUX_PM0(dprx_id);
    WORD usRegOffsetAuxPM2ByID = DP_REG_OFFSET_AUX_PM2(dprx_id);
    UNUSED(bEnable);

    switch(ucPMMode)
    {
        case ePM_STANDBY: // DPMS
            // Switch FRO before turn off Xtal
            mdrv_DPRx_SetAuxPMClock(FALSE); // Set PM Aux clock to FRO

            for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
            {
                dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
                dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

                msWriteByte(REG_DPRX_AUX_PM0_3C_H + usRegOffsetAuxPM0ByID, 0xFF); // Clear AUX received info
                msWriteByteMask(REG_DPRX_AUX_PM2_61_L + usRegOffsetAuxPM2ByID, 0, BIT7); // reg_pd_vcm_op
                mhal_DPRx_CableDisconectResetDPCD(dprx_id, dprx_aux_id);
                mhal_DPRx_OverWriteDPCD202_203(dprx_id, FALSE, 0x0000);
                glDPRxInfo[dprx_id].bOverWriteLockStatus = FALSE;

                // Clear fake training status need at DP offline mode
                mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, TRUE);
                _mdrv_DPRx_ClearFakeTrainingLockStatus(dprx_id);

                _mdrv_DPRx_Timer_variable_Reset();

				// Disable interrupt
				mhal_DPRx_EnableReceiverInterrupt(dprx_id, FALSE);
				mhal_DPRx_SetCDRLossLockInterrupt(dprx_id, FALSE);
                mhal_DPRx_SetInterlaneSkewLoseInterrupt(dprx_id, FALSE);
                mhal_DPRx_SetInterlaneSkewDoneInterrupt(dprx_id, FALSE);
                mhal_DPRx_EnableDPCD103Interrupt(dprx_id, FALSE);
            	mhal_DPRx_EnableDPCD202Interrupt(dprx_id, FALSE); // For debug
				mhal_DPRx_SetProgrammableDPCDEnable(dprx_aux_id, FALSE);
                mhal_DPRx_SetXDATAProgrammableDPCDEnable(dprx_aux_id, DPRx_XDATAPROGRAM_DPCD_0, TRUE, FALSE);
                mhal_DPRx_SetXDATAProgrammableDPCDEnable(dprx_aux_id, DPRx_XDATAPROGRAM_DPCD_1, TRUE, FALSE);

                mhal_DPRx_EnableAuxInterrupt(dprx_aux_id, FALSE);
                mhal_DPRx_EnableDPAUXRecvInterrupt(dprx_aux_id, FALSE);
            	mhal_DPRx_EnablePHYInterrupt(dprx_phy_id, FALSE);

                if(GET_DPRx_FUNCTION_ENABLE_PORT(dprx_id))
                {
                    mhal_DPRx_PHYPowerModeSetting(ucPMMode, dprx_id, dprx_phy_id);
                }
            }
            break;

        case ePM_POWEROFF: // DC off
            // Switch FRO before turn off Xtal
            mdrv_DPRx_SetAuxPMClock(FALSE); // Set PM Aux clock to FRO

            for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
            {
                dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
                dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
                dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

                glDPRxInfo[dprx_id].ucState = DPRx_STATE_STARTUP;

                if(dprx_decoder_id < DPRx_DECODER_ID_MAX)
                {
                    glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable = FALSE;
                }
                mhal_DPRx_CableDisconectResetDPCD(dprx_id, dprx_aux_id);
                mhal_DPRx_OverWriteDPCD202_203(dprx_id, FALSE, 0x0000);
                glDPRxInfo[dprx_id].bOverWriteLockStatus = FALSE;

                // Clear fake training status need at DP offline mode
                mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, TRUE);
                _mdrv_DPRx_ClearFakeTrainingLockStatus(dprx_id);

                _mdrv_DPRx_Timer_variable_Reset();

				// Disable interrupt
				mhal_DPRx_EnableReceiverInterrupt(dprx_id, FALSE);
				mhal_DPRx_SetCDRLossLockInterrupt(dprx_id, FALSE);
                mhal_DPRx_SetInterlaneSkewLoseInterrupt(dprx_id, FALSE);
                mhal_DPRx_SetInterlaneSkewDoneInterrupt(dprx_id, FALSE);
                mhal_DPRx_EnableDPCD103Interrupt(dprx_id, FALSE);
            	mhal_DPRx_EnableDPCD202Interrupt(dprx_id, FALSE); // For debug
				mhal_DPRx_SetProgrammableDPCDEnable(dprx_aux_id, FALSE);
                mhal_DPRx_SetXDATAProgrammableDPCDEnable(dprx_aux_id, DPRx_XDATAPROGRAM_DPCD_0, TRUE, FALSE);
                mhal_DPRx_SetXDATAProgrammableDPCDEnable(dprx_aux_id, DPRx_XDATAPROGRAM_DPCD_1, TRUE, FALSE);
                mhal_DPRx_EnableAuxInterrupt(dprx_aux_id, FALSE);
                mhal_DPRx_EnableDPAUXRecvInterrupt(dprx_aux_id, FALSE);
            	mhal_DPRx_EnablePHYInterrupt(dprx_phy_id, FALSE);

                if(GET_DPRx_FUNCTION_ENABLE_PORT(dprx_id))
                {
                    mhal_DPRx_PHYPowerModeSetting(ucPMMode, dprx_id, dprx_phy_id);
                }
            }
            break;

        default:
            break;
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_MSCHIP_EnableDPDetect()
//  [Description]
//					mdrv_DPRx_MSCHIP_EnableDPDetect
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_MSCHIP_DP_PMHandler(void)
{
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;

    for(dprx_aux_id = DPRx_AUX_ID_0; dprx_aux_id < DPRx_AUX_ID_MAX; dprx_aux_id++)
    {
        #if (DP_XDATA_PROGRAMMABLE_DPCD_MCCS == 1)
        if(mhal_DPRx_GetXDATAProgramDPCD1Flag(dprx_aux_id))
        {
            mhal_DPRx_XDATAProgramDPCD1Proc(dprx_aux_id);
        }
        #endif
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_CheckMCCSXDATAProgrammableDPCD()
//  [Description]
//					mdrv_DPRx_CheckMCCSXDATAProgrammableDPCD
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
DPRx_MCCS_WAKEUP mdrv_DPRx_CheckMCCSWakeUpXDATAProgrammableDPCD(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if(dprx_aux_id == DPRx_AUX_ID_MAX)
    {
        return DPRx_MCCS_MAX;
    }

    return mhal_DPRx_CheckMCCSWakeUpXDATAProgrammableDPCD(dprx_aux_id);
}
#endif // ENABLE_DP_INPUT

//**************************************************************************
//  [Function Name]:
//				  	_mdrv_DPRx_MSCHIP_DPRxID2AuxID()
//  [Description]
//					_mdrv_DPRx_MSCHIP_DPRxID2AuxID
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
DPRx_AUX_ID _mdrv_DPRx_MSCHIP_DPRxID2AuxID(DPRx_ID dprx_id)
{
#if (FPGA_Verification == 1)
    return DPRx_AUX_ID_0;  // MT9701 FPGA board define
#endif

    if(dprx_id == DPRx_ID_MAX)
    {
        return DPRx_AUX_ID_MAX;
    }

    switch(dprx_id)
    {
        case DPRx_ID_0:
            return (DPRx_AUX_ID)DPRx_C1_AUX;

        case DPRx_ID_1:
            return (DPRx_AUX_ID)DPRx_C2_AUX;

        case DPRx_ID_2:
            return (DPRx_AUX_ID)DPRx_C3_AUX;

        default:
            return DPRx_AUX_ID_MAX;
    }

    return DPRx_AUX_ID_MAX;
}

//**************************************************************************
//  [Function Name]:
//				  	_mdrv_DPRx_MSCHIP_DPRxID2DecodeID()
//  [Description]
//					_mdrv_DPRx_MSCHIP_DPRxID2DecodeID
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
DPRx_DECODER_ID _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(DPRx_ID dprx_id)
{
#if (FPGA_Verification == 1)
        return DPRx_DECODER_ID_0;
#endif

    if(dprx_id == DPRx_ID_MAX)
    {
        return DPRx_DECODER_ID_MAX;
    }
    else
    {
        return DPRx_DECODER_ID_0;
    }
}

//**************************************************************************
//  [Function Name]:
//				  	_mdrv_DPRx_MSCHIP_DPRxID2PhyID()
//  [Description]
//					_mdrv_DPRx_MSCHIP_DPRxID2PhyID
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
DPRx_PHY_ID _mdrv_DPRx_MSCHIP_DPRxID2PhyID(DPRx_ID dprx_id)
{
#if (FPGA_Verification == 1)
        return DPRx_PHY_ID_0;
#endif

    if(dprx_id == DPRx_ID_MAX)
    {
        return DPRx_PHY_ID_MAX;
    }

    switch(dprx_id)
    {
        case DPRx_ID_0:
        case DPRx_ID_1:
            return DPRx_PHY_ID_0;

        case DPRx_ID_2:
            return DPRx_PHY_ID_1;

        default:
            return DPRx_PHY_ID_MAX;
    }

    return DPRx_PHY_ID_MAX;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetPixelClock10K()
//  [Description]
//					mdrv_DPRx_GetPixelClock10K
//  [Arguments]:
//
//  [Return]:
//                  Pixel clock = xxx MHz
//**************************************************************************
WORD mdrv_DPRx_GetPixelClock10K(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return mhal_DPRx_GetTimingPixelClock10K(dprx_id, dprx_decoder_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetPowerDownControl()
//  [Description]
//					mdrv_DPRx_SetPowerDownControl
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetPowerDownControl(DPRx_ID dprx_id, DP_ePM_Mode dp_pm_Mode)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    mhal_DPRx_SetPowerDownControl(dprx_id, dprx_aux_id, dp_pm_Mode);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetPhyPowerDownControl()
//  [Description]
//					mdrv_DPRx_SetPowerDownControl
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetPhyPowerDownControl(DPRx_ID dprx_id, DP_ePM_Mode dp_pm_Mode)
{
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);
    mhal_DP_PM_Mode edp_pm_mode = mhal_ePM_INVAILD;

    if((dprx_id == DPRx_ID_MAX) || (dprx_phy_id == DPRx_PHY_ID_MAX))
    {
        return;
    }

    switch(dp_pm_Mode)
    {
        case DP_ePM_POWERON:
            edp_pm_mode = mhal_ePM_POWERON;
            break;

        case DP_ePM_STANDBY:
            edp_pm_mode = mhal_ePM_STANDBY;
            break;

        case DP_ePM_POWEROFF:
            edp_pm_mode = mhal_ePM_POWEROFF;
            break;

        case DP_ePM_POWEROFF_NoUsedPort:
            edp_pm_mode = mhal_ePM_INVAILD;
            break;

        case DP_ePM_INVAILD:
            edp_pm_mode = mhal_ePM_POWERON;
            break;

        default:
            edp_pm_mode = mhal_ePM_INVAILD;
            break;
    }

    mhal_DPRx_PHYPowerModeSetting(edp_pm_mode, dprx_id, dprx_phy_id);

    return;
}
#endif // _MDRV_DPRX_C_

