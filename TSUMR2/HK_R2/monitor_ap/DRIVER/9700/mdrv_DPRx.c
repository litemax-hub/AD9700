///////////////////////////////////////////////////////////////////////////////////////////////////
///
/// file    mdrv_DPRx.c
/// @author MStar Semiconductor _Inc.
/// @brief  DP Rx driver Function
///////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _MDRV_DPRX_C_
#define _MDRV_DPRX_C_

//-------------------------------------------------------------------------------------------------
//  Include Files
//-------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>
#include <types.h>
#include "dpCommon.h"
#include "mhal_DPRx.h"
#include "mhal_DPRx_phy.h"
#include "mdrv_DPRx.h"
#include "HdcpHandler.h"
#include "msEread.h"

#if (ENABLE_DP_INPUT == 0x1)
//-------------------------------------------------------------------------------------------------
//  Local Defines
//-------------------------------------------------------------------------------------------------
#define DP_DRV_DEBUG_MESSAGE		0

#if (DP_DEBUG_MESSAGE && DP_DRV_DEBUG_MESSAGE)
#define DP_DRV_DPUTSTR(str)			printf(str)
#define DP_DRV_DPRINTF(str, x)		printf(str, x)
#else
#define DP_DRV_DPUTSTR(str)
#define DP_DRV_DPRINTF(str, x)
#endif

//-------------------------------------------------------------------------------------------------
//  Global Variables
//-------------------------------------------------------------------------------------------------
extern BYTE XDATA ucDPFunctionEnableIndex;
extern BYTE XDATA ucDPTPCFunctionEnableIndex;
BYTE XDATA glucAudioPath[DPRx_ID_MAX] = {0};  //To indicate which RxID should update the mask count.

BYTE glubRxDataQueue[DPRx_ID_MAX][DPRx_PROGRAM_DPCD_MAX][DP_AUX_COMMAND_MAX_LENGTH];
BYTE glubRx_XDataQueue[DPRx_ID_MAX][DPRx_XDATAPROGRAM_DPCD_MAX][DPRX_XDataQueue];

DPRx_DecoderINFO XDATA glDPRxDecoderInfo[DPRx_DECODER_ID_MAX];

BOOL XDATA glubTypeCHPDCtrl[DP_TYPE_C_PORT_NUM] = {FALSE};
BOOL XDATA glubTypeCShortHPD[DP_TYPE_C_PORT_NUM] = {FALSE};
BOOL XDATA glubTriggerTypeCHPDFlag[DP_TYPE_C_PORT_NUM] = {FALSE};

#if (DPRX_HDCP14_Repeater_ENABLE == 1)
DPRx_HDCP14AKSVReceived_CB_FUNC pmdrv_DP_HDCP14AKSVReceived = NULL;
DPRx_HDCP14_CHECK_VPRIME_CB_FUNC pmdrv_DPRx_HDCP14CheckVprime = NULL;
#endif

#if(DPRX_HDCP2_ENABLE == 0x1)
DPRx_HDCP2_CB_FUNC pmdrv_DP_HDCP2RxEventProc = NULL;
DPRX_HDCP2_Config_Repeater_CB_FUNC pmdrv_DPRX_HDCP2_Config_Repeater_CB_FUNC = NULL;
BYTE ucHDCPData[DP_HDCP2_RX_QUEUE_SIZE] = {0};
BOOL bHDCP22RepPairEnable[DPRx_ID_MAX] = {0};
#endif

DPRx_INFO XDATA glDPRxInfo[DPRx_ID_MAX];
extern volatile ST_HDCP_HANDLER XDATA g_stHdcpHandler[DEF_HDCP_PORT_NUM];

extern BYTE XDATA glLastRxID;

extern BYTE glTypeC_PhyLaneSwap[DPRx_ID_MAX];
extern BYTE glTypeC_MacPNswap[DPRx_ID_MAX];

BOOL XDATA glHPEllitePatchEnable[DPRx_ID_MAX] = {0x0};

extern WORD usInfo1;
extern BYTE ubInfo2;

const BYTE EDID_DPRX_PORT0[DP_EDID_SIZE_512] =
{
#if 1 // 1080P
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3E, 0x93, 0x08, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x15, 0x01, 0x04, 0xA5, 0x33, 0x1D, 0x78, 0x22, 0x1E, 0x55, 0xA0, 0x59, 0x56, 0x9F, 0x27,
    0x0D, 0x50, 0x54, 0xBD, 0x4B, 0x00, 0xD1, 0xC0, 0x81, 0x80, 0x95, 0x0F, 0x95, 0x00, 0xB3, 0x00,
    0x81, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0xFD, 0x1E, 0x11, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x0A, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x56,
    0x53, 0x32, 0x33, 0x30, 0x50, 0x47, 0x4C, 0x57, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x53, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x6E,

    0x02, 0x03, 0x0C, 0xC1, 0x23, 0x09, 0x17, 0x07, 0x83, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60
#endif

#if 0 // 1080P 144
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3E, 0x93, 0x08, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x15, 0x01, 0x04, 0xA5, 0x33, 0x1D, 0x78, 0x22, 0x1E, 0x55, 0xA0, 0x59, 0x56, 0x9F, 0x27,
    0x0D, 0x50, 0x54, 0xBD, 0x4B, 0x00, 0xD1, 0xC0, 0x81, 0x80, 0x95, 0x0F, 0x95, 0x00, 0xB3, 0x00,
    0x81, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x38, 0x8B, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0xFD, 0x1E, 0x11, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x0A, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x56,
    0x53, 0x32, 0x33, 0x30, 0x50, 0x47, 0x4C, 0x57, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x53, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xE7,
    0x02, 0x03, 0x0C, 0xC1, 0x23, 0x09, 0x17, 0x07, 0x83, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
#endif

#if 0 // QHD, 2560x1440
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x36, 0x74, 0x3A, 0x41, 0x01, 0x01, 0x01, 0x01,
    0x31, 0x1A, 0x01, 0x04, 0xB5, 0x37, 0x1F, 0x78, 0x3E, 0xEE, 0x95, 0xA3, 0x54, 0x4C, 0x99, 0x26,
    0x0F, 0x50, 0x54, 0xA5, 0x4B, 0x00, 0x71, 0x4F, 0xA9, 0x40, 0x81, 0x80, 0xD1, 0xC0, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x56, 0x5E, 0x00, 0xA0, 0xA0, 0xA0, 0x29, 0x50, 0x30, 0x20,
    0x35, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x4D, 0x53, 0x54,
    0x41, 0x52, 0x5F, 0x44, 0x45, 0x4D, 0x4F, 0x0A, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4D,
    0x53, 0x54, 0x41, 0x52, 0x5F, 0x44, 0x45, 0x4D, 0x4F, 0x0A, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x5A, 0x19, 0x01, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xB1,
    0x02, 0x03, 0x1C, 0xF1, 0x4F, 0x90, 0x05, 0x04, 0x03, 0x02, 0x07, 0x16, 0x01, 0x06, 0x11, 0x12,
    0x15, 0x13, 0x14, 0x1F, 0x23, 0x09, 0x1F, 0x07, 0x83, 0x01, 0x00, 0x00, 0x02, 0x3A, 0x80, 0x18,
    0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C, 0x45, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1E, 0x7E, 0x39,
    0x00, 0xA0, 0x80, 0x38, 0x1F, 0x40, 0x30, 0x20, 0x3A, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1A,
    0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0x29, 0x37, 0x21, 0x00,
    0x00, 0x1E, 0xBF, 0x16, 0x00, 0xA0, 0x80, 0x38, 0x13, 0x40, 0x30, 0x20, 0x3A, 0x00, 0x29, 0x37,
    0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86
#endif

#if 0 // Test YUV420
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x10,	0xAC,	0xB6,	0x40,	0x53,	0x37,	0x36,	0x35,
    0x2A,	0x1A,	0x01,	0x04,	0xC5,	0x3C,	0x22,	0x78,	0x3A,	0x8A,	0xA0,	0xAC,	0x50,	0x32,	0xB7,	0x25,
    0x0B,	0x50,	0x52,	0x21,	0x08,	0x00,	0x81,	0x00,	0xB3,	0x00,	0xD1,	0x00,	0xA9,	0x40,	0x81,	0x80,
    0xD1,	0xC0,	0x00,	0x00,	0x00,	0x00,	0x08,	0xE8,	0x00,	0x30,	0xF2,	0x70,	0x5A,	0x80,	0xB0,	0x58,
    0x8A,	0x00,	0xBA,	0x89,	0x21,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x44,	0x58,	0x58,
    0x58,	0x52,	0x34,	0x38,	0x34,	0x35,	0x36,	0x37,	0x53,	0x0A,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x44,
    0x45,	0x4C,	0x4C,	0x20,	0x55,	0x50,	0x32,	0x37,	0x31,	0x38,	0x4B,	0x0A,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x1D,	0x4B,	0x1F,	0xB4,	0x6C,	0x01,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x92,
    0x02,	0x03,	0x23,	0xF2,	0x4C,	0x05,	0x84,	0x03,	0x02,	0x01,	0x12,	0x93,	0x14,	0x16,	0x07,	0x61,
    0x90,	0x23,	0x09,	0x07,	0x07,	0x83,	0x01,	0x00,	0x00,	0x65,	0x03,	0x0C,	0x00,	0x10,	0x00,	0xE3,
    0x0F,	0x00,	0x0C,	0x8C,	0x0A,	0xD0,	0x8A,	0x20,	0xE0,	0x2D,	0x10,	0x10,	0x3E,	0x96,	0x00,	0xC4,
    0x8E,	0x21,	0x00,	0x00,	0x18,	0x8C,	0x0A,	0xA0,	0x14,	0x51,	0xF0,	0x16,	0x00,	0x26,	0x7C,	0x43,
    0x00,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x98,	0x01,	0x1D,	0x00,	0xBC,	0x52,	0xD0,	0x1E,	0x20,	0xB8,
    0x28,	0x55,	0x40,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x97
#endif

#if 0 // Freesync FHD 40~70Hz
    0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x05,0xA4,0x30,0x00,0x02,0x00,0x00,0x00,
    0x01,0x18,0x01,0x04,0x80,0x73,0x41,0x78,0x0B,0xCF,0x74,0xA7,0x55,0x46,0x98,0x24,
    0x10,0x49,0x4B,0x21,0x08,0x00,0x81,0x80,0x95,0x00,0x90,0x40,0xA9,0xC0,0xA9,0x40,
    0xB3,0x00,0x61,0x40,0x71,0x40,0x37,0x45,0x80,0x4A,0x71,0x38,0x2D,0x40,0x30,0x20,
    0x35,0x00,0x35,0xAD,0x10,0x00,0x00,0x1E,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x00,0x46,
    0x52,0x45,0x45,0x53,0x59,0x4E,0x43,0x37,0x30,0x2D,0x34,0x30,0x00,0x00,0x00,0xFD,
    0x00,0x28,0x46,0x6B,0x6B,0x1E,0x01,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x01,0x0C,
    0x02,0x03,0x31,0xF3,0x4D,0x01,0x03,0x84,0x05,0x07,0x10,0x12,0x93,0x14,0x16,0x1F,
    0x20,0x22,0x29,0x09,0x07,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x83,0x01,0x00,0x00,
    0x67,0x03,0x0C,0x00,0x10,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x8C,0x0A,0xD0,0x8A,0x20,0xE0,0x2D,0x10,0x10,0x3E,0x96,0x00,0xC4,0x8E,0x21,
    0x00,0x00,0x18,0x02,0x3A,0x80,0x18,0x71,0x38,0x2D,0x40,0x58,0x2C,0x45,0x00,0xC4,
    0x8E,0x21,0x00,0x00,0x1E,0x01,0x1D,0x00,0xBC,0x52,0xD0,0x1E,0x20,0xB8,0x28,0x55,
    0x40,0xC4,0x8E,0x21,0x00,0x00,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07
#endif

#if 0 // DELL P2719HC
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x10, 0xAC, 0x86, 0x41, 0x53, 0x51, 0x30, 0x30,
    0x02, 0x1C, 0x01, 0x04, 0xA5, 0x3C, 0x22, 0x78, 0x3A, 0x48, 0x15, 0xA7, 0x56, 0x52, 0x9C, 0x27,
    0x0F, 0x50, 0x54, 0xA5, 0x4B, 0x00, 0x71, 0x4F, 0x81, 0x80, 0xA9, 0xC0, 0xD1, 0xC0, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0x56, 0x50, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x48, 0x38, 0x43,
    0x4A, 0x32, 0x4E, 0x46, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x44,
    0x45, 0x4C, 0x4C, 0x20, 0x50, 0x32, 0x37, 0x31, 0x39, 0x48, 0x43, 0x0A, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x53, 0x11, 0x01, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0xFB
#endif

#if 0 // 4K // Mstar EDID (3840x2160@60Hz Audio) Reduce Blanking

    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x36, 0x74, 0x30, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x2C, 0x12, 0x01, 0x04, 0xA5, 0x00, 0x00, 0x78, 0xFA, 0x9F, 0xA3, 0xA3, 0x56, 0x4B, 0xB0, 0x23,
    0x09, 0x48, 0x4A, 0x21, 0x08, 0x00, 0x81, 0xC0, 0xA9, 0x40, 0xD1, 0xC0, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x34, 0xD0, 0x00, 0xA0, 0xF0, 0x70, 0x3E, 0x80, 0x30, 0x20,
    0x35, 0x00, 0x06, 0x44, 0x21, 0x00, 0x00, 0x1A, 0xD0, 0x39, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40,
    0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4D,
    0x53, 0x74, 0x61, 0x72, 0x20, 0x44, 0x65, 0x6D, 0x6F, 0x0A, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x3B, 0x3C, 0x1F, 0x46, 0x07, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xB9,

    0x02, 0x03, 0x1D, 0xF2, 0x4A, 0x05, 0x84, 0x03, 0x02, 0x01, 0x12, 0x93, 0x14, 0x16, 0x07, 0x23,
    0x0F, 0x7F, 0x07, 0x83, 0x01, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0,
    0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x18, 0x8C,
    0x0A, 0xA0, 0x14, 0x51, 0xF0, 0x16, 0x00, 0x26, 0x7C, 0x43, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00,
    0x99, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 0x21,
    0x00, 0x00, 0x1F, 0x01, 0x1D, 0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4,
    0x8E, 0x21, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEA
#endif
};

const BYTE EDID_DPRX_PORT1[DP_EDID_SIZE_512] =
{
#if 1 // 1080P
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3E, 0x93, 0x08, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x15, 0x01, 0x04, 0xA5, 0x33, 0x1D, 0x78, 0x22, 0x1E, 0x55, 0xA0, 0x59, 0x56, 0x9F, 0x27,
    0x0D, 0x50, 0x54, 0xBD, 0x4B, 0x00, 0xD1, 0xC0, 0x81, 0x80, 0x95, 0x0F, 0x95, 0x00, 0xB3, 0x00,
    0x81, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0xFD, 0x1E, 0x11, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x0A, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x56,
    0x53, 0x32, 0x33, 0x30, 0x50, 0x47, 0x4C, 0x57, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x53, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x6E,
    0x02, 0x03, 0x0C, 0xC1, 0x23, 0x09, 0x17, 0x07, 0x83, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60
#endif

#if 0 // 1080P 144
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3E, 0x93, 0x08, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x15, 0x01, 0x04, 0xA5, 0x33, 0x1D, 0x78, 0x22, 0x1E, 0x55, 0xA0, 0x59, 0x56, 0x9F, 0x27,
    0x0D, 0x50, 0x54, 0xBD, 0x4B, 0x00, 0xD1, 0xC0, 0x81, 0x80, 0x95, 0x0F, 0x95, 0x00, 0xB3, 0x00,
    0x81, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x38, 0x8B, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0xFD, 0x1E, 0x11, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x0A, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x56,
    0x53, 0x32, 0x33, 0x30, 0x50, 0x47, 0x4C, 0x57, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x53, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xE7,
    0x02, 0x03, 0x0C, 0xC1, 0x23, 0x09, 0x17, 0x07, 0x83, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
#endif

#if 0 // QHD, 2560x1440
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x36, 0x74, 0x3A, 0x41, 0x01, 0x01, 0x01, 0x01,
    0x31, 0x1A, 0x01, 0x04, 0xB5, 0x37, 0x1F, 0x78, 0x3E, 0xEE, 0x95, 0xA3, 0x54, 0x4C, 0x99, 0x26,
    0x0F, 0x50, 0x54, 0xA5, 0x4B, 0x00, 0x71, 0x4F, 0xA9, 0x40, 0x81, 0x80, 0xD1, 0xC0, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x56, 0x5E, 0x00, 0xA0, 0xA0, 0xA0, 0x29, 0x50, 0x30, 0x20,
    0x35, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x4D, 0x53, 0x54,
    0x41, 0x52, 0x5F, 0x44, 0x45, 0x4D, 0x4F, 0x0A, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4D,
    0x53, 0x54, 0x41, 0x52, 0x5F, 0x44, 0x45, 0x4D, 0x4F, 0x0A, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x5A, 0x19, 0x01, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xB1,
    0x02, 0x03, 0x1C, 0xF1, 0x4F, 0x90, 0x05, 0x04, 0x03, 0x02, 0x07, 0x16, 0x01, 0x06, 0x11, 0x12,
    0x15, 0x13, 0x14, 0x1F, 0x23, 0x09, 0x1F, 0x07, 0x83, 0x01, 0x00, 0x00, 0x02, 0x3A, 0x80, 0x18,
    0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C, 0x45, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1E, 0x7E, 0x39,
    0x00, 0xA0, 0x80, 0x38, 0x1F, 0x40, 0x30, 0x20, 0x3A, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1A,
    0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0x29, 0x37, 0x21, 0x00,
    0x00, 0x1E, 0xBF, 0x16, 0x00, 0xA0, 0x80, 0x38, 0x13, 0x40, 0x30, 0x20, 0x3A, 0x00, 0x29, 0x37,
    0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86
#endif

#if 0 // Test YUV420
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x10,	0xAC,	0xB6,	0x40,	0x53,	0x37,	0x36,	0x35,
    0x2A,	0x1A,	0x01,	0x04,	0xC5,	0x3C,	0x22,	0x78,	0x3A,	0x8A,	0xA0,	0xAC,	0x50,	0x32,	0xB7,	0x25,
    0x0B,	0x50,	0x52,	0x21,	0x08,	0x00,	0x81,	0x00,	0xB3,	0x00,	0xD1,	0x00,	0xA9,	0x40,	0x81,	0x80,
    0xD1,	0xC0,	0x00,	0x00,	0x00,	0x00,	0x08,	0xE8,	0x00,	0x30,	0xF2,	0x70,	0x5A,	0x80,	0xB0,	0x58,
    0x8A,	0x00,	0xBA,	0x89,	0x21,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x44,	0x58,	0x58,
    0x58,	0x52,	0x34,	0x38,	0x34,	0x35,	0x36,	0x37,	0x53,	0x0A,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x44,
    0x45,	0x4C,	0x4C,	0x20,	0x55,	0x50,	0x32,	0x37,	0x31,	0x38,	0x4B,	0x0A,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x1D,	0x4B,	0x1F,	0xB4,	0x6C,	0x01,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x92,
    0x02,	0x03,	0x23,	0xF2,	0x4C,	0x05,	0x84,	0x03,	0x02,	0x01,	0x12,	0x93,	0x14,	0x16,	0x07,	0x61,
    0x90,	0x23,	0x09,	0x07,	0x07,	0x83,	0x01,	0x00,	0x00,	0x65,	0x03,	0x0C,	0x00,	0x10,	0x00,	0xE3,
    0x0F,	0x00,	0x0C,	0x8C,	0x0A,	0xD0,	0x8A,	0x20,	0xE0,	0x2D,	0x10,	0x10,	0x3E,	0x96,	0x00,	0xC4,
    0x8E,	0x21,	0x00,	0x00,	0x18,	0x8C,	0x0A,	0xA0,	0x14,	0x51,	0xF0,	0x16,	0x00,	0x26,	0x7C,	0x43,
    0x00,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x98,	0x01,	0x1D,	0x00,	0xBC,	0x52,	0xD0,	0x1E,	0x20,	0xB8,
    0x28,	0x55,	0x40,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x97
#endif

#if 0 // Freesync FHD 40~70Hz
    0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x05,0xA4,0x30,0x00,0x02,0x00,0x00,0x00,
    0x01,0x18,0x01,0x04,0x80,0x73,0x41,0x78,0x0B,0xCF,0x74,0xA7,0x55,0x46,0x98,0x24,
    0x10,0x49,0x4B,0x21,0x08,0x00,0x81,0x80,0x95,0x00,0x90,0x40,0xA9,0xC0,0xA9,0x40,
    0xB3,0x00,0x61,0x40,0x71,0x40,0x37,0x45,0x80,0x4A,0x71,0x38,0x2D,0x40,0x30,0x20,
    0x35,0x00,0x35,0xAD,0x10,0x00,0x00,0x1E,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x00,0x46,
    0x52,0x45,0x45,0x53,0x59,0x4E,0x43,0x37,0x30,0x2D,0x34,0x30,0x00,0x00,0x00,0xFD,
    0x00,0x28,0x46,0x6B,0x6B,0x1E,0x01,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x01,0x0C,
    0x02,0x03,0x31,0xF3,0x4D,0x01,0x03,0x84,0x05,0x07,0x10,0x12,0x93,0x14,0x16,0x1F,
    0x20,0x22,0x29,0x09,0x07,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x83,0x01,0x00,0x00,
    0x67,0x03,0x0C,0x00,0x10,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x8C,0x0A,0xD0,0x8A,0x20,0xE0,0x2D,0x10,0x10,0x3E,0x96,0x00,0xC4,0x8E,0x21,
    0x00,0x00,0x18,0x02,0x3A,0x80,0x18,0x71,0x38,0x2D,0x40,0x58,0x2C,0x45,0x00,0xC4,
    0x8E,0x21,0x00,0x00,0x1E,0x01,0x1D,0x00,0xBC,0x52,0xD0,0x1E,0x20,0xB8,0x28,0x55,
    0x40,0xC4,0x8E,0x21,0x00,0x00,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07
#endif

#if 0 // 4K // Mstar EDID (3840x2160@60Hz Audio) Reduce Blanking
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x36, 0x74, 0x30, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x2C, 0x12, 0x01, 0x04, 0xA5, 0x00, 0x00, 0x78, 0xFA, 0x9F, 0xA3, 0xA3, 0x56, 0x4B, 0xB0, 0x23,
    0x09, 0x48, 0x4A, 0x21, 0x08, 0x00, 0x81, 0xC0, 0xA9, 0x40, 0xD1, 0xC0, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x34, 0xD0, 0x00, 0xA0, 0xF0, 0x70, 0x3E, 0x80, 0x30, 0x20,
    0x35, 0x00, 0x06, 0x44, 0x21, 0x00, 0x00, 0x1A, 0xD0, 0x39, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40,
    0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4D,
    0x53, 0x74, 0x61, 0x72, 0x20, 0x44, 0x65, 0x6D, 0x6F, 0x0A, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x3B, 0x3C, 0x1F, 0x46, 0x07, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xB9,

    0x02, 0x03, 0x1D, 0xF2, 0x4A, 0x05, 0x84, 0x03, 0x02, 0x01, 0x12, 0x93, 0x14, 0x16, 0x07, 0x23,
    0x0F, 0x7F, 0x07, 0x83, 0x01, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0,
    0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x18, 0x8C,
    0x0A, 0xA0, 0x14, 0x51, 0xF0, 0x16, 0x00, 0x26, 0x7C, 0x43, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00,
    0x99, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 0x21,
    0x00, 0x00, 0x1F, 0x01, 0x1D, 0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4,
    0x8E, 0x21, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEA
#endif

#if 0 // 2560x1440@60Hz
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x4C, 0x2D, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    0x2F, 0x1A, 0x01, 0x03, 0x80, 0x3C, 0x22, 0x78, 0x2A, 0x64, 0xAD, 0xA4, 0x54, 0x4D, 0x9A, 0x26,
    0x0F, 0x47, 0x4A, 0xBF, 0xEF, 0x80, 0x71, 0x4F, 0x81, 0x00, 0x81, 0xC0, 0x81, 0x80, 0x95, 0x00,
    0xA9, 0xC0, 0xB3, 0x00, 0x01, 0x01, 0xEB, 0x60, 0x00, 0x78, 0xA0, 0xA0, 0x67, 0x50, 0x08, 0x20,
    0x98, 0x04, 0x56, 0x50, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x30, 0x3C, 0x1E,
    0xDF, 0x19, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x46,
    0x72, 0x65, 0x65, 0x53, 0x79, 0x6E, 0x63, 0x5F, 0x34, 0x38, 0x36, 0x30, 0x00, 0x00, 0x00, 0xFF,
    0x00, 0x48, 0x31, 0x41, 0x4B, 0x35, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0A, 0x20, 0x20, 0x01, 0x72,
    0x02, 0x03, 0x5A, 0xF0, 0x53, 0x5F, 0x10, 0x1F, 0x04, 0x13, 0x05, 0x14, 0x20, 0x21, 0x22, 0x5D,
    0x5E, 0x62, 0x63, 0x64, 0x07, 0x16, 0x03, 0x12, 0x29, 0x09, 0x07, 0x07, 0x15, 0x07, 0x50, 0x3D,
    0x04, 0xC0, 0x83, 0x01, 0x00, 0x00, 0xE2, 0x00, 0x0F, 0x6E, 0x03, 0x0C, 0x00, 0x20, 0x00, 0xB8,
    0x3C, 0x20, 0x00, 0x80, 0x01, 0x02, 0x03, 0x04, 0x67, 0xD8, 0x5D, 0xC4, 0x01, 0x78, 0x80, 0x00,
    0x68, 0x1A, 0x00, 0x00, 0x01, 0x01, 0x30, 0x3C, 0x00, 0xE3, 0x05, 0x03, 0x01, 0xE5, 0x0E, 0x60,
    0x61, 0x65, 0x66, 0xE6, 0x06, 0x05, 0x01, 0xFF, 0xFF, 0x00, 0x01, 0x1D, 0x80, 0xD0, 0x72, 0x1C,
    0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0x50, 0x1D, 0x74, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94
#endif
};

const BYTE EDID_DPRX_PORT2[DP_EDID_SIZE_512] =
{
#if 1 // 1080P
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3E, 0x93, 0x08, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x15, 0x01, 0x04, 0xA5, 0x33, 0x1D, 0x78, 0x22, 0x1E, 0x55, 0xA0, 0x59, 0x56, 0x9F, 0x27,
    0x0D, 0x50, 0x54, 0xBD, 0x4B, 0x00, 0xD1, 0xC0, 0x81, 0x80, 0x95, 0x0F, 0x95, 0x00, 0xB3, 0x00,
    0x81, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0xFD, 0x1E, 0x11, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x0A, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x56,
    0x53, 0x32, 0x33, 0x30, 0x50, 0x47, 0x4C, 0x57, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x53, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x6E,

    0x02, 0x03, 0x0C, 0xC1, 0x23, 0x09, 0x17, 0x07, 0x83, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60
#endif

#if 0 // 1080P 144
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3E, 0x93, 0x08, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x15, 0x01, 0x04, 0xA5, 0x33, 0x1D, 0x78, 0x22, 0x1E, 0x55, 0xA0, 0x59, 0x56, 0x9F, 0x27,
    0x0D, 0x50, 0x54, 0xBD, 0x4B, 0x00, 0xD1, 0xC0, 0x81, 0x80, 0x95, 0x0F, 0x95, 0x00, 0xB3, 0x00,
    0x81, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x38, 0x8B, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0xFD, 0x1E, 0x11, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x0A, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x56,
    0x53, 0x32, 0x33, 0x30, 0x50, 0x47, 0x4C, 0x57, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x53, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xE7,
    0x02, 0x03, 0x0C, 0xC1, 0x23, 0x09, 0x17, 0x07, 0x83, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
#endif

#if 0 // QHD, 2560x1440
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x36, 0x74, 0x3A, 0x41, 0x01, 0x01, 0x01, 0x01,
    0x31, 0x1A, 0x01, 0x04, 0xB5, 0x37, 0x1F, 0x78, 0x3E, 0xEE, 0x95, 0xA3, 0x54, 0x4C, 0x99, 0x26,
    0x0F, 0x50, 0x54, 0xA5, 0x4B, 0x00, 0x71, 0x4F, 0xA9, 0x40, 0x81, 0x80, 0xD1, 0xC0, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x56, 0x5E, 0x00, 0xA0, 0xA0, 0xA0, 0x29, 0x50, 0x30, 0x20,
    0x35, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x4D, 0x53, 0x54,
    0x41, 0x52, 0x5F, 0x44, 0x45, 0x4D, 0x4F, 0x0A, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4D,
    0x53, 0x54, 0x41, 0x52, 0x5F, 0x44, 0x45, 0x4D, 0x4F, 0x0A, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x5A, 0x19, 0x01, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xB1,
    0x02, 0x03, 0x1C, 0xF1, 0x4F, 0x90, 0x05, 0x04, 0x03, 0x02, 0x07, 0x16, 0x01, 0x06, 0x11, 0x12,
    0x15, 0x13, 0x14, 0x1F, 0x23, 0x09, 0x1F, 0x07, 0x83, 0x01, 0x00, 0x00, 0x02, 0x3A, 0x80, 0x18,
    0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C, 0x45, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1E, 0x7E, 0x39,
    0x00, 0xA0, 0x80, 0x38, 0x1F, 0x40, 0x30, 0x20, 0x3A, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1A,
    0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0x29, 0x37, 0x21, 0x00,
    0x00, 0x1E, 0xBF, 0x16, 0x00, 0xA0, 0x80, 0x38, 0x13, 0x40, 0x30, 0x20, 0x3A, 0x00, 0x29, 0x37,
    0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86
#endif

#if 0 // Test YUV420
    0x00,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0xFF,	0x00,	0x10,	0xAC,	0xB6,	0x40,	0x53,	0x37,	0x36,	0x35,
    0x2A,	0x1A,	0x01,	0x04,	0xC5,	0x3C,	0x22,	0x78,	0x3A,	0x8A,	0xA0,	0xAC,	0x50,	0x32,	0xB7,	0x25,
    0x0B,	0x50,	0x52,	0x21,	0x08,	0x00,	0x81,	0x00,	0xB3,	0x00,	0xD1,	0x00,	0xA9,	0x40,	0x81,	0x80,
    0xD1,	0xC0,	0x00,	0x00,	0x00,	0x00,	0x08,	0xE8,	0x00,	0x30,	0xF2,	0x70,	0x5A,	0x80,	0xB0,	0x58,
    0x8A,	0x00,	0xBA,	0x89,	0x21,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0xFF,	0x00,	0x44,	0x58,	0x58,
    0x58,	0x52,	0x34,	0x38,	0x34,	0x35,	0x36,	0x37,	0x53,	0x0A,	0x00,	0x00,	0x00,	0xFC,	0x00,	0x44,
    0x45,	0x4C,	0x4C,	0x20,	0x55,	0x50,	0x32,	0x37,	0x31,	0x38,	0x4B,	0x0A,	0x00,	0x00,	0x00,	0xFD,
    0x00,	0x1D,	0x4B,	0x1F,	0xB4,	0x6C,	0x01,	0x0A,	0x20,	0x20,	0x20,	0x20,	0x20,	0x20,	0x01,	0x92,
    0x02,	0x03,	0x23,	0xF2,	0x4C,	0x05,	0x84,	0x03,	0x02,	0x01,	0x12,	0x93,	0x14,	0x16,	0x07,	0x61,
    0x90,	0x23,	0x09,	0x07,	0x07,	0x83,	0x01,	0x00,	0x00,	0x65,	0x03,	0x0C,	0x00,	0x10,	0x00,	0xE3,
    0x0F,	0x00,	0x0C,	0x8C,	0x0A,	0xD0,	0x8A,	0x20,	0xE0,	0x2D,	0x10,	0x10,	0x3E,	0x96,	0x00,	0xC4,
    0x8E,	0x21,	0x00,	0x00,	0x18,	0x8C,	0x0A,	0xA0,	0x14,	0x51,	0xF0,	0x16,	0x00,	0x26,	0x7C,	0x43,
    0x00,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x98,	0x01,	0x1D,	0x00,	0xBC,	0x52,	0xD0,	0x1E,	0x20,	0xB8,
    0x28,	0x55,	0x40,	0xC4,	0x8E,	0x21,	0x00,	0x00,	0x1E,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
    0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x97
#endif

#if 0 // Freesync FHD 40~70Hz
    0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x05,0xA4,0x30,0x00,0x02,0x00,0x00,0x00,
    0x01,0x18,0x01,0x04,0x80,0x73,0x41,0x78,0x0B,0xCF,0x74,0xA7,0x55,0x46,0x98,0x24,
    0x10,0x49,0x4B,0x21,0x08,0x00,0x81,0x80,0x95,0x00,0x90,0x40,0xA9,0xC0,0xA9,0x40,
    0xB3,0x00,0x61,0x40,0x71,0x40,0x37,0x45,0x80,0x4A,0x71,0x38,0x2D,0x40,0x30,0x20,
    0x35,0x00,0x35,0xAD,0x10,0x00,0x00,0x1E,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x00,0x46,
    0x52,0x45,0x45,0x53,0x59,0x4E,0x43,0x37,0x30,0x2D,0x34,0x30,0x00,0x00,0x00,0xFD,
    0x00,0x28,0x46,0x6B,0x6B,0x1E,0x01,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x01,0x0C,
    0x02,0x03,0x31,0xF3,0x4D,0x01,0x03,0x84,0x05,0x07,0x10,0x12,0x93,0x14,0x16,0x1F,
    0x20,0x22,0x29,0x09,0x07,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x83,0x01,0x00,0x00,
    0x67,0x03,0x0C,0x00,0x10,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x8C,0x0A,0xD0,0x8A,0x20,0xE0,0x2D,0x10,0x10,0x3E,0x96,0x00,0xC4,0x8E,0x21,
    0x00,0x00,0x18,0x02,0x3A,0x80,0x18,0x71,0x38,0x2D,0x40,0x58,0x2C,0x45,0x00,0xC4,
    0x8E,0x21,0x00,0x00,0x1E,0x01,0x1D,0x00,0xBC,0x52,0xD0,0x1E,0x20,0xB8,0x28,0x55,
    0x40,0xC4,0x8E,0x21,0x00,0x00,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07
#endif

#if 0 // 4K // Mstar EDID (3840x2160@60Hz Audio) Reduce Blanking
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x36, 0x74, 0x30, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x2C, 0x12, 0x01, 0x04, 0xA5, 0x00, 0x00, 0x78, 0xFA, 0x9F, 0xA3, 0xA3, 0x56, 0x4B, 0xB0, 0x23,
    0x09, 0x48, 0x4A, 0x21, 0x08, 0x00, 0x81, 0xC0, 0xA9, 0x40, 0xD1, 0xC0, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x34, 0xD0, 0x00, 0xA0, 0xF0, 0x70, 0x3E, 0x80, 0x30, 0x20,
    0x35, 0x00, 0x06, 0x44, 0x21, 0x00, 0x00, 0x1A, 0xD0, 0x39, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40,
    0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4D,
    0x53, 0x74, 0x61, 0x72, 0x20, 0x44, 0x65, 0x6D, 0x6F, 0x0A, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x3B, 0x3C, 0x1F, 0x46, 0x07, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xB9,

    0x02, 0x03, 0x1D, 0xF2, 0x4A, 0x05, 0x84, 0x03, 0x02, 0x01, 0x12, 0x93, 0x14, 0x16, 0x07, 0x23,
    0x0F, 0x7F, 0x07, 0x83, 0x01, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0,
    0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x18, 0x8C,
    0x0A, 0xA0, 0x14, 0x51, 0xF0, 0x16, 0x00, 0x26, 0x7C, 0x43, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00,
    0x99, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 0x21,
    0x00, 0x00, 0x1F, 0x01, 0x1D, 0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4,
    0x8E, 0x21, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEA
#endif
};

const BYTE EDID_DPRX_PORT3[DP_EDID_SIZE_512] =
{
#if 1 // 1080P
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3E, 0x93, 0x08, 0xC0, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x15, 0x01, 0x04, 0xA5, 0x33, 0x1D, 0x78, 0x22, 0x1E, 0x55, 0xA0, 0x59, 0x56, 0x9F, 0x27,
    0x0D, 0x50, 0x54, 0xBD, 0x4B, 0x00, 0xD1, 0xC0, 0x81, 0x80, 0x95, 0x0F, 0x95, 0x00, 0xB3, 0x00,
    0x81, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0xFD, 0x1E, 0x11, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x0A, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x56,
    0x53, 0x32, 0x33, 0x30, 0x50, 0x47, 0x4C, 0x57, 0x0A, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x53, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x6E,
    0x02, 0x03, 0x0C, 0xC1, 0x23, 0x09, 0x17, 0x07, 0x83, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60
#endif

#if 0 // QHD, 2560x1440
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x36, 0x74, 0x3A, 0x41, 0x01, 0x01, 0x01, 0x01,
    0x31, 0x1A, 0x01, 0x04, 0xB5, 0x37, 0x1F, 0x78, 0x3E, 0xEE, 0x95, 0xA3, 0x54, 0x4C, 0x99, 0x26,
    0x0F, 0x50, 0x54, 0xA5, 0x4B, 0x00, 0x71, 0x4F, 0xA9, 0x40, 0x81, 0x80, 0xD1, 0xC0, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x56, 0x5E, 0x00, 0xA0, 0xA0, 0xA0, 0x29, 0x50, 0x30, 0x20,
    0x35, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x4D, 0x53, 0x54,
    0x41, 0x52, 0x5F, 0x44, 0x45, 0x4D, 0x4F, 0x0A, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4D,
    0x53, 0x54, 0x41, 0x52, 0x5F, 0x44, 0x45, 0x4D, 0x4F, 0x0A, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x38, 0x4C, 0x1E, 0x5A, 0x19, 0x01, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xB1,
    0x02, 0x03, 0x1C, 0xF1, 0x4F, 0x90, 0x05, 0x04, 0x03, 0x02, 0x07, 0x16, 0x01, 0x06, 0x11, 0x12,
    0x15, 0x13, 0x14, 0x1F, 0x23, 0x09, 0x1F, 0x07, 0x83, 0x01, 0x00, 0x00, 0x02, 0x3A, 0x80, 0x18,
    0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C, 0x45, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1E, 0x7E, 0x39,
    0x00, 0xA0, 0x80, 0x38, 0x1F, 0x40, 0x30, 0x20, 0x3A, 0x00, 0x29, 0x37, 0x21, 0x00, 0x00, 0x1A,
    0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0x29, 0x37, 0x21, 0x00,
    0x00, 0x1E, 0xBF, 0x16, 0x00, 0xA0, 0x80, 0x38, 0x13, 0x40, 0x30, 0x20, 0x3A, 0x00, 0x29, 0x37,
    0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86
#endif

#if 0
    // Test YUV420
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x10, 0xAC, 0xB6, 0x40, 0x53, 0x37, 0x36, 0x35,
    0x2A, 0x1A, 0x01, 0x04, 0xB5, 0x3C, 0x22, 0x78, 0x3A, 0x8A, 0xA0, 0xAC, 0x50, 0x32, 0xB7, 0x25,
    0x0B, 0x50, 0x52, 0x21, 0x08, 0x00, 0x81, 0x00, 0xB3, 0x00, 0xD1, 0x00, 0xA9, 0x40, 0x81, 0x80,
    0xD1, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x24, 0xEA, 0x00, 0x30, 0xF2, 0x70, 0x5A, 0x80, 0xB0, 0x58,
    0x8A, 0x00, 0xBA, 0x89, 0x21, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x44, 0x58, 0x58,
    0x58, 0x52, 0x34, 0x38, 0x34, 0x35, 0x36, 0x37, 0x53, 0x0A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x44,
    0x45, 0x4C, 0x4C, 0x20, 0x55, 0x50, 0x32, 0x37, 0x31, 0x38, 0x4B, 0x0A, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x1D, 0x4B, 0x1F, 0xB4, 0x6C, 0x01, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x84,
    0x70, 0x12, 0x6B, 0x00, 0x00, 0x12, 0x00, 0x16, 0x82, 0x10, 0x00, 0x00, 0xFF, 0x0E, 0xDF, 0x10,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x45, 0x4C, 0x1A, 0x41, 0x58, 0x44, 0x36, 0x35, 0x03, 0x01,
    0x28, 0x70, 0x92, 0x01, 0x84, 0xFF, 0x1D, 0x2B, 0x01, 0x75, 0x80, 0x1F, 0x00, 0xDF, 0x10, 0x3D,
    0x00, 0x02, 0x00, 0x04, 0x00, 0x80, 0xA0, 0x01, 0x04, 0xFF, 0x0E, 0x9F, 0x00, 0x2F, 0x80, 0x1F,
    0x00, 0xDF, 0x10, 0x7A, 0x00, 0x02, 0x00, 0x09, 0x00, 0x07, 0x00, 0x0A, 0x08, 0x81, 0x00, 0x08,
    0x04, 0x00, 0x04, 0x02, 0x10, 0x00, 0x81, 0x00, 0x17, 0x26, 0x09, 0x07, 0x07, 0x11, 0x07, 0x06,
    0x83, 0x01, 0x00, 0x00, 0xE3, 0x05, 0x1F, 0x00, 0xE3, 0x06, 0x07, 0xFB, 0xE3, 0x0E, 0x61, 0xC7,
    0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90
#endif

#if 0 // 4K // Mstar EDID (3840x2160@60Hz Audio) Reduce Blanking
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x36, 0x74, 0x30, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x2C, 0x12, 0x01, 0x04, 0xA5, 0x00, 0x00, 0x78, 0xFA, 0x9F, 0xA3, 0xA3, 0x56, 0x4B, 0xB0, 0x23,
    0x09, 0x48, 0x4A, 0x21, 0x08, 0x00, 0x81, 0xC0, 0xA9, 0x40, 0xD1, 0xC0, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x34, 0xD0, 0x00, 0xA0, 0xF0, 0x70, 0x3E, 0x80, 0x30, 0x20,
    0x35, 0x00, 0x06, 0x44, 0x21, 0x00, 0x00, 0x1A, 0xD0, 0x39, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40,
    0x58, 0x2C, 0x45, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x4D,
    0x53, 0x74, 0x61, 0x72, 0x20, 0x44, 0x65, 0x6D, 0x6F, 0x0A, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x3B, 0x3C, 0x1F, 0x46, 0x07, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xB9,

    0x02, 0x03, 0x1D, 0xF2, 0x4A, 0x05, 0x84, 0x03, 0x02, 0x01, 0x12, 0x93, 0x14, 0x16, 0x07, 0x23,
    0x0F, 0x7F, 0x07, 0x83, 0x01, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x8C, 0x0A, 0xD0,
    0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00, 0x18, 0x8C,
    0x0A, 0xA0, 0x14, 0x51, 0xF0, 0x16, 0x00, 0x26, 0x7C, 0x43, 0x00, 0xC4, 0x8E, 0x21, 0x00, 0x00,
    0x99, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20, 0xB8, 0x28, 0x55, 0x40, 0xC4, 0x8E, 0x21,
    0x00, 0x00, 0x1F, 0x01, 0x1D, 0x80, 0xD0, 0x72, 0x1C, 0x16, 0x20, 0x10, 0x2C, 0x25, 0x80, 0xC4,
    0x8E, 0x21, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEA
#endif
};

//-------------------------------------------------------------------------------------------------
//  Local Functions Prototype
//-------------------------------------------------------------------------------------------------
void ________PROTOTYPE________(void);
void _mdrv_DPRx_MuxSelect(DPRx_ID dprx_id, DPRx_AUX_ID dprx_aux_id);
BOOL _mdrv_DPRx_CheckSquelch(DPRx_ID dprx_id);
void _mdrv_DPRx_VSCPayload(DPRx_ID dprx_id, BYTE Payload);
BOOL _mdrv_DPRx_CheckInputTiming(DPRx_ID dprx_id);
void _mdrv_DPRx_NormalModeSetting(DPRx_ID dprx_id);
void _mdrv_DPRx_ShortHPD(DPRx_ID dprx_id);
void _mdrv_DPRx_LongHPD(DPRx_ID dprx_id);
BOOL _mdrv_DPRx_CheckVPLLBigChange(DPRx_ID dprx_id);
void _mdrv_DPRx_SetReferenceClock(DPRx_ID dprx_id, DPRx_DECODER_ID dprx_decoder_id);
void _mdrv_DPRx_HPDPollingEvent(DPRx_ID dprx_id);
BOOL _mdrv_DPRx_StateHandler(DPRx_ID dprx_id);
void _mdrv_DPRx_Regen_Sync(DPRx_ID dprx_id);
void _mdrv_DPRx_StablePolling(DPRx_ID dprx_id);
void _mdrv_DPRx_PollingPacket(DPRx_ID dprx_id);
void _mdrv_DPRx_CableDisconnectReset(DPRx_ID dprx_id);
void _mdrv_DPRx_CheckCableDetection(DPRx_ID dprx_id);
BOOL _mdrv_DPRx_CTSCheck(DPRx_ID dprx_id);
void _mdrv_DPRx_ClearFakeTrainingLockStatus(DPRx_ID dprx_id);
void _mdrv_DPRx_HDCP14Handler(DPRx_ID dprx_id);
void _mdrv_DPRx_AudioHandler(DPRx_ID dprx_id);
void _mdrv_DPRx_SetAudioMaskCount(DPRx_ID dprx_id);
#if (DPRX_HDCP2_ENABLE == 0x1)
BOOL _mdrv_DPRx_HDCP2GetRxData(DPRx_ID dprx_id, BYTE ucMessageID, BYTE *pHDCPData);
void _mdrv_DPRx_HDCP2SetTxData(DPRx_ID dprx_id, BYTE ucMessageID, BYTE *pHDCPData);
void _mdrv_DPRx_HDCP2Handler(DPRx_ID dprx_id);
#endif
void _mdrv_DPRx_MSCHIP_ScreenMute(void);
DPRx_ID _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(BYTE ucInputPort);
BYTE _mdrv_DPRx_MSCHIP_DPRxID2PortNumber(DPRx_ID dprx_id);
DPRx_AUX_ID _mdrv_DPRx_MSCHIP_DPRxID2AuxID(DPRx_ID dprx_id);
DPRx_DECODER_ID _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(DPRx_ID dprx_id);
DPRx_PHY_ID _mdrv_DPRx_MSCHIP_DPRxID2PhyID(DPRx_ID dprx_id);
DPRx_ID _mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(DPRx_ID dprx_id);
extern void MuteVideoAndAudio(void);
void _mdrv_DPRx_Timer_variable_Reset(void);

//-------------------------------------------------------------------------------------------------
//  Local Functions
//-------------------------------------------------------------------------------------------------
//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_MuxSelect()
//  [Description]
//					_mdrv_DPRx_MuxSelect
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_MuxSelect(DPRx_ID dprx_id, DPRx_AUX_ID dprx_aux_id)
{
    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    mhal_DPRx_MuxSelect(dprx_id, dprx_aux_id);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_CheckSquelch()
//  [Description]
//                  _mdrv_DPRx_CheckSquelch
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL _mdrv_DPRx_CheckSquelch(DPRx_ID dprx_id)
{
	if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    if(dprx_id == DPRx_ID_3)
    {
        return mhal_DPRx_TypeC_CheckSquelch(dprx_id, glDPRxInfo[dprx_id].ubTypeC_PinAssign, glDPRxInfo[dprx_id].ubTypeC_CC);
    }
    else
    {
        return mhal_DPRx_CheckSquelch(dprx_id);
    }
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_VSCPayload()
//  [Description]
//					_mdrv_DPRx_VSCPayload
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_VSCPayload(DPRx_ID dprx_id, BYTE Payload)
{
    BYTE ucFormat = Payload >> 4;
    BYTE ucPayload = Payload & 0x0F;
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    if(ucFormat == 0)
    {
        switch(ucPayload)
        {
            case 3:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_ADOBERBG;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_MAX;
                break;

            case 6:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_BT2020RGBYCbCr;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_EC;
                break;

            default:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_NONE;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_MAX;
                break;
        }
    }
    else
    {
        switch(ucPayload)
        {
            case 0:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_ITU601;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU601;
                break;

            case 1:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_ITU709;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU709;
                break;

            case 2:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_xvYCC601;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU601;
                break;

            case 3:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_xvYCC709;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU709;
                break;

            case 4:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_sYCC601;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU601;
                break;

            case 5:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_ADOBEYCC601;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU601;
                break;

            case 6:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_BT2020YcCbcCrc;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_EC;
                break;

            case 7:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_BT2020RGBYCbCr;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_EC;
                break;

            default:
                glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_NONE;
                glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_MAX;
                break;
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_CheckInputTiming()
//  [Description]
//					_mdrv_DPRx_CheckInputTiming
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL _mdrv_DPRx_CheckInputTiming(DPRx_ID dprx_id)
{
    BOOL XDATA bCheckFinish = FALSE;
    BOOL XDATA bInterlace = FALSE;
    BYTE XDATA uctemp = 0;
    DWORD XDATA ulPixelClock = 0;
    WORD XDATA usVTotal = 0;
    WORD XDATA usVWidth = 0;
    WORD XDATA usTimingInfo[DPRX_CHECK_TIMING_QUEUE_SIZE] = {0};
    BYTE XDATA ubStableTimes = 0x0;
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;

    // For freesync on, we should use regen timing SW mode
    WORD XDATA usBlank = 0;
    WORD XDATA usWidth = 0;
    WORD XDATA usFrontPorch = 0;
    WORD XDATA usBackPorch = 0;

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
        {
            //When VPLL big change, we need to re-check timing, so we can clear all VPLL big change events before we re-check timing actions.
            mhal_DPRx_ClrVideoBigChgFlag(dprx_decoder_id);
            glDPRxDecoderInfo[dprx_decoder_id].bDPVPLLBIGChange = FALSE;

            for(uctemp = 0; uctemp < DPRX_CHECK_TIMING_COUNTER; uctemp++)
            {
                ulPixelClock = mhal_DPRx_GetTimingPixelClock(dprx_id, dprx_decoder_id);

                bInterlace = mhal_DPRx_GetTimingInformation(dprx_decoder_id, usTimingInfo);

                glDPRxDecoderInfo[dprx_decoder_id].bDPInterlace = bInterlace;
                glDPRxDecoderInfo[dprx_decoder_id].uwDPHtotal = usTimingInfo[0];
                glDPRxDecoderInfo[dprx_decoder_id].uwDPHWidth = usTimingInfo[2];
                glDPRxDecoderInfo[dprx_decoder_id].uwDPVtotal = usTimingInfo[1];
                glDPRxDecoderInfo[dprx_decoder_id].uwDPVWidth = usTimingInfo[3];
                glDPRxDecoderInfo[dprx_decoder_id].uwDPPixel = ulPixelClock;

                if(bInterlace)
                {
                    usVTotal = usTimingInfo[1] << 1;
                    usVWidth = usTimingInfo[3] << 1;
                }
                else
                {
                    usVTotal = usTimingInfo[1];
                    usVWidth = usTimingInfo[3];
                }

                glDPRxDecoderInfo[dprx_decoder_id].uwDPHStart = usTimingInfo[4];
                glDPRxDecoderInfo[dprx_decoder_id].uwDPVStart = usTimingInfo[5];
                glDPRxDecoderInfo[dprx_decoder_id].uwDPHPWS = usTimingInfo[6] & 0x7FFF;
                glDPRxDecoderInfo[dprx_decoder_id].bDPHPol = (usTimingInfo[6] & BIT15)? TRUE : FALSE;
                glDPRxDecoderInfo[dprx_decoder_id].uwDPVPWS = usTimingInfo[7] & 0x7FFF;
                glDPRxDecoderInfo[dprx_decoder_id].bDPVPol = (usTimingInfo[7] & BIT15)? TRUE : FALSE;

                // For freesync on, we should use regen timing SW mode
                // V parameter
                usBlank = glDPRxDecoderInfo[dprx_decoder_id].uwDPVtotal - glDPRxDecoderInfo[dprx_decoder_id].uwDPVWidth;
                usWidth = usBlank / 2;
                usFrontPorch = (usBlank - usWidth) / 2;
                usBackPorch = usBlank - usWidth - usFrontPorch;

                usTimingInfo[0] = usWidth - 0x2; //RD suggest fix hsw = 2(> XC Limitation), If value is too large will impact hw mask hsync behavior when source send vblank is too small
                usTimingInfo[1] = usFrontPorch;
                usTimingInfo[2] = usBackPorch;

                if(usBlank < 0x400)
                {
                    if((glDPRxDecoderInfo[dprx_decoder_id].uwDPHWidth > 3000) || (glDPRxDecoderInfo[dprx_decoder_id].uwDPVWidth > 3000) || (glDPRxDecoderInfo[dprx_decoder_id].uwDPPixel > 300))
                    {
                        usWidth = 0x34;
                    }
                    else
                    {
                        usWidth = 0x2C;
                    }

                    usTimingInfo[3] = usWidth;

                    mhal_DPRx_RegenTimingInformation(dprx_decoder_id, usTimingInfo);
                }

                DP_DRV_DPRINTF("\r\nDP Input : Rx ID %d ", dprx_id);
                DP_DRV_DPRINTF("\r\nDP Input : Rx DecodeID %d ", dprx_decoder_id);
                DP_DRV_DPRINTF("\r\nDP Input : Pixel_Clock %d Mhz", ulPixelClock);
                DP_DRV_DPRINTF("\r\nDP Input : Link Rate  %d ", mhal_DPRx_GetLinkRate(dprx_id));
                DP_DRV_DPRINTF("\r\nDP Input : HTT  %d ", glDPRxDecoderInfo[dprx_decoder_id].uwDPHtotal);
                DP_DRV_DPRINTF("\r\nDP Input : VTT  %d ", glDPRxDecoderInfo[dprx_decoder_id].uwDPVtotal);
                DP_DRV_DPRINTF("\r\nDP Input : HDE  %d ", glDPRxDecoderInfo[dprx_decoder_id].uwDPHWidth);
                DP_DRV_DPRINTF("\r\nDP Input : VDE  %d ", glDPRxDecoderInfo[dprx_decoder_id].uwDPVWidth);

                if((glDPRxDecoderInfo[dprx_decoder_id].uwDPHWidth < DPRX_MAX_VALID_HDE) && (usVWidth < DPRX_MAX_VALID_VDE) &&
                   (glDPRxDecoderInfo[dprx_decoder_id].uwDPHWidth > DPRX_MIN_VALID_HDE) && (usVWidth > DPRX_MIN_VALID_VDE) &&
                   (ulPixelClock > DPRX_MIN_PIX_ClOCK) && (ulPixelClock < DPRX_MAX_PIX_ClOCK) &&
                   (glDPRxDecoderInfo[dprx_decoder_id].uwDPHtotal > glDPRxDecoderInfo[dprx_decoder_id].uwDPHWidth) && (usVTotal > usVWidth))
                {
                    ubStableTimes++;

                    // 1000ms/fps = (1000 / pixel clk * 1000000) * VTT * HTT
					glDPRxDecoderInfo[dprx_decoder_id].ulFrameTime = (DWORD)(glDPRxDecoderInfo[dprx_decoder_id].uwDPVtotal * glDPRxDecoderInfo[dprx_decoder_id].uwDPHtotal) / glDPRxDecoderInfo[dprx_decoder_id].uwDPPixel / 1000 + 1;

                    DP_DRV_DPRINTF("\r\n===> DP timing Pass: %x\r\n", 0);
                }
                else
                {
                    ubStableTimes = 0;

                    DP_DRV_DPRINTF( "\r\n===> DP timing Fail:%x \r\n", 0);
                    break;
                }
            }

            if(ubStableTimes == DPRX_CHECK_TIMING_COUNTER)
            {
                bCheckFinish = TRUE;
            }
        }
    }

    return bCheckFinish;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_NormalModeSetting()
//  [Description]
//					_mdrv_DPRx_NormalModeSetting
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_NormalModeSetting(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    BOOL XDATA FsynEnable = mhal_DPRx_GetDRRFlag(dprx_aux_id);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    if(FsynEnable)
    {
        mhal_DPRx_EnableVspHwRegen(dprx_decoder_id, FALSE);
        mhal_DPRx_EnableAutoInterlace(dprx_decoder_id, FALSE);
    }
    else
    {
        mhal_DPRx_EnableVspHwRegen(dprx_decoder_id, TRUE);
        mhal_DPRx_EnableAutoInterlace(dprx_decoder_id, TRUE);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_ShortHPD()
//  [Description]
//					_mdrv_DPRx_ShortHPD
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_ShortHPD(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    WORD XDATA i = 0;

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    if(glDPRxInfo[dprx_id].bDPHpdState == FALSE)
    {
        return;
    }

    if(_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id) != DPRx_ID_MAX)
    {
        glubTypeCShortHPD[_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id)] = TRUE;
        return;
    }

    if(mhal_DPRx_IsHwHPDControlEnable(dprx_aux_id) == TRUE) // HW mode
    {
        for(i = 0x0; i < 0xA; i++)
        {
            if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
            {
                break;
            }

            mhal_DPRx_DELAY_NOP(300 + i*150);
        }

        if(mhal_DPRx_CheckHPDBusy(dprx_aux_id))
        {
            printf("** --- HPD event busy\r\n");
        }
        else
        {
            mhal_DPRx_HwShortHPDTrigger(dprx_aux_id);
        }
    }
    else // SW mode
    {
        for(i = 0x0; i < 0xA; i++)
        {
            if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
            {
                break;
            }

            mhal_DPRx_DELAY_NOP(300 + i*150);
        }

        mhal_DPRx_HPDControl(dprx_aux_id, FALSE);

        for(i = 0 ; i < (4 * 750); i++)
        {
            mhal_DPRx_DELAY_NOP(5);
        }

        mhal_DPRx_HPDControl(dprx_aux_id, TRUE);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_LongHPD()
//  [Description]
//					_mdrv_DPRx_LongHPD
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_LongHPD(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    BYTE ucInputPort = _mdrv_DPRx_MSCHIP_DPRxID2PortNumber(dprx_id);
    WORD XDATA i = 0;

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    if(mhal_DPRx_CheckHPDBusy(dprx_aux_id))
    {
        printf("** --- HPD event busy\r\n");
    }
    else
    {
        for(i = 0x0; i < 0xA; i++)
        {
            if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
            {
                break;
            }

            mhal_DPRx_DELAY_NOP(300 + i*150);
        }

        mdrv_DPRx_HPDControl(ucInputPort, FALSE);
        ForceDelay1ms(650);
        mdrv_DPRx_HPDControl(ucInputPort, TRUE);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_CheckVPLLBigChange()
//  [Description]
//					_mdrv_DPRx_CheckVPLLBigChange
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL _mdrv_DPRx_CheckVPLLBigChange(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;
    BOOL XDATA bVPLLBigChange = FALSE;

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        if(glDPRxDecoderInfo[dprx_decoder_id].bDPVPLLBIGChange)
        {
            if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
            {
                DP_DRV_DPRINTF("glDPRxInfo[dprx_id].bDPVPLLBIGChange = 0x%x\r\n", glDPRxDecoderInfo[dprx_decoder_id].bDPVPLLBIGChange);
                DP_DRV_DPRINTF("mhal_DPRx_CheckVPLLBigChange = 0x%x\r\n", mhal_DPRx_CheckVPLLBigChange(dprx_decoder_id));

                glDPRxDecoderInfo[dprx_decoder_id].bDPVPLLBIGChange = FALSE;
                bVPLLBigChange = TRUE;

                mhal_DPRx_UpdateMVIDValue(dprx_decoder_id);
                mhal_DPRx_ClrVideoBigChgFlag(dprx_decoder_id);

                //Tx send idle pattern, we will set bRxDecodeStable_R = FALSE
                {
                    glDPRxInfo[dprx_id].bRxDecodeStable = FALSE;
                }
            }
        }
    }

    return bVPLLBigChange;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_SetReferenceClock()
//  [Description]
//					_mdrv_DPRx_SetReferenceClock
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_SetReferenceClock(DPRx_ID dprx_id, DPRx_DECODER_ID dprx_decoder_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    BYTE XDATA usLSClock = mhal_DPRx_GetDPCDLinkRate(dprx_aux_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return;
    }

    switch(usLSClock)
    {
        case DP_LINKRATE_RBR:
            mhal_DPRx_SetReferenceClock(dprx_decoder_id, DPRX_RBR_REFERCLOCK);
            mhal_DPRx_PLLOven(dprx_decoder_id, FALSE);
            break;

        case DP_LINKRATE_HBR:
            mhal_DPRx_SetReferenceClock(dprx_decoder_id, DPRX_HBR_REFERCLOCK);
            mhal_DPRx_PLLOven(dprx_decoder_id, TRUE);
            break;

        case DP_LINKRATE_HBR2:
            mhal_DPRx_SetReferenceClock(dprx_decoder_id, DPRX_HBR2_REFERCLOCK);
            mhal_DPRx_PLLOven(dprx_decoder_id, TRUE);
            break;

        case DP_LINKRATE_HBR25:
            mhal_DPRx_SetReferenceClock(dprx_decoder_id, DPRX_HBR25_REFERCLOCK);
            mhal_DPRx_PLLOven(dprx_decoder_id, FALSE);
            break;

        case DP_LINKRATE_HBR3:
            mhal_DPRx_SetReferenceClock(dprx_decoder_id, DPRX_HBR3_REFERCLOCK);
            mhal_DPRx_PLLOven(dprx_decoder_id, FALSE);
            break;
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_HPDPollingEvent()
//  [Description]
//					_mdrv_DPRx_HPDPollingEvent
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_HPDPollingEvent(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);
    WORD XDATA i = 0;
    BOOL XDATA bTrainingFlag = mhal_DPRx_GetTrainingPatternFlag(dprx_id);
    static BYTE ubTimerOffset[DPRx_ID_MAX] = {0x0};

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    // CDR lose lock
    if(glDPRxInfo[dprx_id].bDPLoseCDRLockIRQ)
    {
        if((glDPRxInfo[dprx_id].uwCDRHPDCnt == 0) && (!bTrainingFlag))
        {
            if(mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort))
            {
                glDPRxInfo[dprx_id].bDPLoseCDRLockIRQ = FALSE;
            }
            else
            {
                glDPRxInfo[dprx_id].bDPLoseCDRLockIRQ = FALSE;

                if(mhal_DPRx_CheckLossCDRStatus(dprx_aux_id))
                {
                    DP_DRV_DPRINTF("** ---2 HPD event %d", dprx_id);

                    mhal_DPRx_PHYCDRDetectEnable(dprx_phy_id, FALSE);
                    mhal_DPRx_HPDControl(dprx_aux_id, FALSE);
                    mhal_DPRx_SymbolEQResetEnable(dprx_id, TRUE);
                    mhal_DPRx_SymbolEQResetEnable(dprx_id, FALSE);
                    mhal_DPRx_PowerDownEQEnable(dprx_phy_id, TRUE);

                    for(i = 0; i < 750; i++)
                    {
                        mhal_DPRx_DELAY_NOP(25); // For CTS1.4 5.3.2.1 IRQ HPD Pulse Due to CDR Loss Lock (UCD-400)
                    }

                    mhal_DPRx_PowerDownEQEnable(dprx_phy_id, FALSE);
                    mhal_DPRx_PHYCDRDetectEnable(dprx_phy_id, TRUE);

                    // For type-C port, use mailbox to trigger short HPD event
                    if(_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id) != DPRx_ID_MAX)
                    {
                        glubTypeCShortHPD[_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id)] = TRUE;
                    }

                    if(glDPRxInfo[dprx_id].bDPHpdState == TRUE)
                    {
                        mhal_DPRx_HPDControl(dprx_aux_id, TRUE);
                    }

                    mhal_DPRx_HDCP22SoftReset(dprx_id);
                }
            }
        }
    }

    // Interlane skew lose
    if(glDPRxInfo[dprx_id].bDPInterlaneSkewLoseIRQ)
    {
        if(!mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort))
        {
            glDPRxInfo[dprx_id].bDPInterlaneSkewLoseIRQ = FALSE;
        }
        else if((glDPRxInfo[dprx_id].uwSkewHPDCnt == 0) && (!bTrainingFlag))
        {
            glDPRxInfo[dprx_id].bDPInterlaneSkewLoseIRQ = FALSE;

            if(mhal_DPRx_CheckInterlaneSkewStatus(dprx_id, dprx_aux_id)) // Lock
            {
                DP_DRV_DPRINTF("** ---InterlaneSkewIRQ HPD event %d", dprx_id);

                _mdrv_DPRx_ShortHPD(dprx_id);
            }
        }
    }

    // HDCP Integrity
    if((!bTrainingFlag) && (mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort)) && (mhal_DPRx_GetHDCPIntegrity(dprx_id)))
    {
        if(glDPRxInfo[dprx_id].bDPHDCPIRQ == FALSE)
        {
            glDPRxInfo[dprx_id].bDPHDCPIRQ = TRUE;

            if(glDPRxInfo[dprx_id].uwHDCPCnt < 1000)
            {
                glDPRxInfo[dprx_id].uwHDCPCnt = 1000 + (ubTimerOffset[dprx_id] * 1000);
            }
        }
        else if(glDPRxInfo[dprx_id].uwHDCPCnt == 0)
        {
            DP_DRV_DPRINTF("** ---HDCPIntegrity HPD event %d", dprx_id);

            mhal_DPRx_SetCPIRQ(dprx_aux_id);
            _mdrv_DPRx_ShortHPD(dprx_id);

            glDPRxInfo[dprx_id].bDPHDCPIRQ = FALSE;

            ubTimerOffset[dprx_id]++;
        }
    }
    else
    {
        glDPRxInfo[dprx_id].bDPHDCPIRQ = FALSE;
        glDPRxInfo[dprx_id].uwHDCPCnt = 0;
        ubTimerOffset[dprx_id] = 0x0;
    }

    if(glDPRxInfo[dprx_id].bHDCPLongHPDTrigger == TRUE)
    {
        if(glDPRxInfo[dprx_id].ucHDCPLongHPDTimer == 0)
        {
            if(_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id) != DPRx_ID_MAX)
            {
                glubTriggerTypeCHPDFlag[_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id)] = TRUE;
                glubTypeCHPDCtrl[_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id)] = TRUE;
            }
            else
            {
                mdrv_DPRx_HPDControl(SrcInputType, TRUE);
            }

            glDPRxInfo[dprx_id].bHDCPLongHPDTrigger = FALSE;
            DP_DRV_DPUTSTR("****** Long HPD set high********\r\n");
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_StateHandler()
//  [Description]
//					_mdrv_DPRx_StateHandler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL _mdrv_DPRx_StateHandler(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);
    BOOL XDATA bSignalStable = FALSE;
    BOOL XDATA bCDRLockFlag = mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort);
    DPRx_AudioStream DPRX_AUDIO_SELECT = mhal_DPRx_GetAudioStream(dprx_id);
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;
    DPRx_DECODER_ID dprx_decoder_id2 = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    static BYTE ucEncryptChkCnt[DPRx_ID_MAX] = {0};
    //static BYTE ucUnStableTimes[DPRx_DECODER_ID_MAX] = {0};
    WORD usRegOffsetDecoderByID = DP_REG_OFFSET100(dprx_decoder_id2);
    BYTE ubPM_DPCD202 = 0x0;
    BYTE ubCheckSquelchTimer = 0x0;
    BOOL XDATA bTriggerShortHPDFlag = FALSE;
    BOOL bRxPortAtOffline = FALSE;
    WORD usMSAChgInterruptEvent = 0x0;

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    _mdrv_DPRx_HPDPollingEvent(dprx_id);

    switch(glDPRxInfo[dprx_id].ucState)
    {
        case DPRx_STATE_STARTUP:
            DP_DRV_DPRINTF("\r\n** DP CDR lock check %d\r\n", dprx_id);

            glDPRxInfo[dprx_id].ucState = DPRx_STATE_CKECKLOCK;

            for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
            {
                if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
                {
                    glDPRxInfo[dprx_id].bRxDecodeStable = FALSE;
                }
            }
            break;

        case DPRx_STATE_CKECKLOCK:
            bTriggerShortHPDFlag = FALSE;

            if(bCDRLockFlag)
            {
                if(glDPRxInfo[dprx_id].bChkEncryptionState == TRUE)
                {
                    if(glDPRxInfo[dprx_id].uwChkEncryptionTime == 0)
                    {
                        // Training lock but data encryption, we have to set integrity fail
                        if(mhal_DPRx_CheckHDCPEncryption(dprx_id) != DP_HDCP_NO_ENCRYPTION)
                        {
                            if(ucEncryptChkCnt[dprx_id] < DPRX_STATE_CHECK_ENCRYPT_CNT)
                            {
                                glDPRxInfo[dprx_id].uwChkEncryptionTime = 20;
                                ucEncryptChkCnt[dprx_id]++;
                            }
                            else
                            {
                                if(((glDPRxInfo[dprx_id].decoderID_Info) & (BIT0 << DPRx_DECODER_ID_MAX)) != (BIT0 << DPRx_DECODER_ID_MAX)) // Check decoder allocate ready
                                {

                                    if(glDPRxInfo[dprx_id].bForceIntegrityFail == TRUE)
                                    {
                                        //HDCP un-decrypt 2nd short HPD: Force Loss loxck
                                        mhal_DPRx_OverWriteDPCD202_203(dprx_id, TRUE, 0x0000);
                                        glDPRxInfo[dprx_id].bOverWriteLockStatus = TRUE;
                                        bTriggerShortHPDFlag = TRUE;
                                    }
                                    else
                                    {
                                        if(glDPRxInfo[dprx_id].bHdcpStartAuth == FALSE)
                                        {
                                            //HDCP un-decrypt 1st short HPD: Force Integrity Fail
                                            mhal_DPRx_ForceHDCP13IntegrityFail(dprx_id, TRUE);
                                            mhal_DPRx_ForceHDCP22IntegrityFail(dprx_id, TRUE);
                                            glDPRxInfo[dprx_id].bForceIntegrityFail = TRUE;

                                            mhal_DPRx_HDCPLinkFailReset(dprx_id);
                                            mhal_DPRx_HDCP14SoftReset(dprx_id);
                                            mhal_DPRx_HDCP22SoftReset(dprx_id);
                                            mhal_DPRx_SetCPIRQ(dprx_aux_id);
                                            bTriggerShortHPDFlag = TRUE;
                                        }
                                    }
                                }

                                ucEncryptChkCnt[dprx_id] = 0;
                                glDPRxInfo[dprx_id].uwHDCPCnt = 0xFFFF; // When force Integrity Fail, set HDCP fail check count as MAX value to avoid trigger CP_IRQ cycle
                                glDPRxInfo[dprx_id].DPCheckModeCnt = 0;
                                glDPRxInfo[dprx_id].ucState = DPRx_STATE_MEASURE;
                                glDPRxInfo[dprx_id].bChkEncryptionState = FALSE;

                                if(ubInfo2 < 2)
                                {
                                    // Only for TSUMR2
                                    // Due to HW restriction, we need to enable MN update overwrite
                                    msWriteByteMask(REG_DPRX_DECODER_E0_28_L + usRegOffsetDecoderByID, BIT6, BIT6);
                                    mhal_DPRx_DELAY_NOP(1000);
                                    msWriteByteMask(REG_DPRX_DECODER_E0_28_L + usRegOffsetDecoderByID, 0, BIT6);
                                }

                                DP_DRV_DPRINTF("\r\n** DP fast training lock check but data encryption-> measure! port %d\r\n", dprx_id);
                            }
                        }
                        else
                        {
                            glDPRxInfo[dprx_id].DPCheckModeCnt = 0;
                            glDPRxInfo[dprx_id].ucState = DPRx_STATE_MEASURE;
                            glDPRxInfo[dprx_id].bChkEncryptionState = FALSE;

                            DP_DRV_DPRINTF("\r\n** DP fast training lock check -> measure! port %d\r\n", dprx_id);
                        }
                    }
                }
                else
                {
                    if(mhal_DPRx_CheckHWFastTrainingLock(dprx_id) == TRUE)
                    {
                        glDPRxInfo[dprx_id].bChkEncryptionState = TRUE;
                        glDPRxInfo[dprx_id].uwChkEncryptionTime = 20;
                    }
                    else
                    {
                        glDPRxInfo[dprx_id].DPCheckModeCnt = 0;
                        glDPRxInfo[dprx_id].ucState = DPRx_STATE_MEASURE;
                        glDPRxInfo[dprx_id].bChkEncryptionState = FALSE;

                        DP_DRV_DPRINTF("** DP CDR lock check -> measure! port %d", dprx_id);
                    }
                }

                for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
                {
                    if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
                    {
                        _mdrv_DPRx_SetReferenceClock(dprx_id, dprx_decoder_id); // VPLL initial must before check input timing

                        glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable = TRUE; // Set bAudioEnable TRUE to run audio handler when lock
                    }
                }
            }
            else // Unlock & no SQ -> trigger short HPD
            {
                if((glDPRxInfo[dprx_id].bDPcableConnent == TRUE) && (glHPEllitePatchEnable[dprx_id] == TRUE)) // For HP Elite book issues patch code, the source would disable main link signal after wake-up training lock
                {
                    ubPM_DPCD202 = mhal_DPRx_GetFakeTrainingDPCD20x(dprx_aux_id, DPCD_00202);

                    if((ubPM_DPCD202 & 0x7) == 0x7) // During offline mode training lock but source disable signal detected, we need to trigger one short HPD
                    {
                        ubCheckSquelchTimer = 10;

                        while(ubCheckSquelchTimer > 0)
                        {
                            if(_mdrv_DPRx_CheckSquelch(dprx_id) != 0x0)
                            {
                                break;
                            }

                            ForceDelay1ms(1);
                            ubCheckSquelchTimer--;
                        }

                        if(ubCheckSquelchTimer == 0x0)
                        {
                            bRxPortAtOffline = mhal_DPRx_IsAuxAtOffLine(dprx_aux_id);

                            // Clean fake training lock status, only software reset works, it need at offline mode
                            mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, TRUE);
                            _mdrv_DPRx_ClearFakeTrainingLockStatus(dprx_id);

                            if(bRxPortAtOffline == FALSE)
                            {
                                mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, FALSE);
                            }

                            bTriggerShortHPDFlag = TRUE;
                            glHPEllitePatchEnable[dprx_id] = FALSE;
                        }
                    }
                }

                if((glDPRxInfo[dprx_id].bOverWriteLockStatus == TRUE) && (glDPRxInfo[dprx_id].bForceIntegrityFail == TRUE) &&
                    (glDPRxInfo[dprx_id].bHDCPLongHPDTrigger == FALSE)) //HDCP un-decrypt 3rd pull long HPD
                {
                    mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, FALSE);
                    glDPRxInfo[dprx_id].bForceIntegrityFail = FALSE;
                    glDPRxInfo[dprx_id].ucHDCPLongHPDTimer = DPRX_HDCP14_LONGHPD_WDT;
                    glDPRxInfo[dprx_id].bHDCPLongHPDTrigger = TRUE;
                    glDPRxInfo[dprx_id].bDPLoseCDRLockIRQ = FALSE; // Avoid HPD conflict with CDR loss lock event

                    if(_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id) != DPRx_ID_MAX)
                    {
                        glubTriggerTypeCHPDFlag[_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id)] = TRUE;
                        glubTypeCHPDCtrl[_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id)] = FALSE;
                    }
                    else
                    {
                        mdrv_DPRx_HPDControl(SrcInputType, FALSE);
                    }
                }
            }

            // Avoid triger short HPD multi times
            if(bTriggerShortHPDFlag == TRUE)
            {
                _mdrv_DPRx_ShortHPD(dprx_id);
            }

            if(mhal_DPRx_HWFastTrainingPeriod(dprx_id) == TRUE)
            {
                mhal_DPRx_SetCDRLossLockInterrupt(dprx_id, TRUE);
                mhal_DPRx_SetInterlaneSkewLoseInterrupt(dprx_id, TRUE);
                mhal_DPRx_SetInterlaneSkewDoneInterrupt(dprx_id, TRUE);
            }
            break;

        case DPRx_STATE_MEASURE:
            // HP Ellite book patch code, we need to make sure it would enter only one time when DPMS wake-up or AC on
            // So, when lock one time, we don'e need the patch code
            glHPEllitePatchEnable[dprx_id] = FALSE;

            if(ubInfo2 < 2)
            {
                if(mhal_DPRx_GetHTT(dprx_decoder_id2) - (msRead2Byte(REG_DPRX_DECODER_E0_3C_L + usRegOffsetDecoderByID) & 0x7FFF) > (mhal_DPRx_GetHTT(dprx_decoder_id2)  >> 2))
                {
                    msWriteByteMask(REG_DPRX_DECODER_E0_28_L + usRegOffsetDecoderByID, BIT6, BIT6);
                }
            }

            if(_mdrv_DPRx_CheckInputTiming(dprx_id))
            {
                if(ubInfo2 < 2)
                {
                    if((msRead2Byte(REG_DPRX_DECODER_E0_28_L + usRegOffsetDecoderByID) & BIT6))
                    {
                        msWriteByteMask(REG_DPRX_DECODER_E0_28_L + usRegOffsetDecoderByID, 0, BIT6);
                    }
                }

                for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
                {
                    if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
                    {
                        mhal_DPRx_DecoderIsrDetectEnable(dprx_decoder_id, TRUE);

                        mhal_DPRx_UpdateMVIDValue(dprx_decoder_id);
                        mhal_DPRx_EnableVspHwRegen(dprx_decoder_id, TRUE);
                        mhal_DPRx_EnableAutoInterlace(dprx_decoder_id, TRUE);

                        if(mhal_DPRx_GetDRRFlag(dprx_aux_id) == TRUE)
                        {
                            // Adaptive sync/freesync should ignore VTT change
                            usMSAChgInterruptEvent = DPRx_MISC1|DPRx_MISC0|DPRx_VDE|DPRx_HDE|DPRx_HTT;
                            mhal_DPRx_MSAChgInterruptEvent_Enable(dprx_decoder_id, usMSAChgInterruptEvent);
                        }
                        else
                        {
                            usMSAChgInterruptEvent = DPRx_MISC1|DPRx_MISC0|DPRx_VDE|DPRx_HDE|DPRx_VTT|DPRx_HTT;
                            mhal_DPRx_MSAChgInterruptEvent_Enable(dprx_decoder_id, usMSAChgInterruptEvent);
                        }

                        if(glDPRxInfo[dprx_id].bSDPSplitEnable == TRUE)
                        {
                            mhal_DPRx_EnableSEReplaceByBE(dprx_decoder_id, FALSE);
                        }
                        else
                        {
                            mhal_DPRx_EnableSEReplaceByBE(dprx_decoder_id, TRUE);
                        }

                        glDPRxDecoderInfo[dprx_decoder_id].bAudioMute = TRUE;
                        glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange = TRUE;
                        glDPRxDecoderInfo[dprx_decoder_id].DPAudioFreq = 0;
                        glDPRxDecoderInfo[dprx_decoder_id].ucAudioCTS_UCD400 = 0;
                        glucAudioPath[dprx_decoder_id] = TRUE;
                    }
                }

                glDPRxInfo[dprx_id].bDPTrainingFlag = FALSE;
                glDPRxInfo[dprx_id].bDPTrainingP1T = FALSE;
                glDPRxInfo[dprx_id].bDPTrainingP234T = FALSE;
                glDPRxInfo[dprx_id].bHdcpStartAuth = FALSE;
                glDPRxInfo[dprx_id].bAudioRecoverCnt = DPRX_AUDIO_RECOVER_CNT;

                glDPRxInfo[dprx_id].ucState = DPRx_STATE_NORMAL;
                glDPRxInfo[dprx_id].uwDPRxStableTimeout = DPRX_STATE_STABLE_DEBOUNCE_TIME;

                DP_DRV_DPRINTF("\r\n** DP mode pass measure -> normal! port %d\r\n", dprx_id);
            }
            else if(glDPRxInfo[dprx_id].DPCheckModeCnt > DPRX_MEASURE_TIMING_COUNTER)
            {
                glDPRxInfo[dprx_id].ucState = DPRx_STATE_CKECKLOCK;

                DP_DRV_DPRINTF("\r\n** DP mode fail measure -> check! port %d\r\n", dprx_id);
            }
            else
            {
                glDPRxInfo[dprx_id].DPCheckModeCnt++;
            }
            break;

        case DPRx_STATE_NORMAL:
            if(!bCDRLockFlag)
            {
                for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
                {
                    if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
                    {
                        mhal_DPRx_DecoderIsrDetectEnable(dprx_decoder_id, FALSE);

                        glDPRxInfo[dprx_id].bRxDecodeStable = FALSE;
                        glDPRxInfo[dprx_id].uwDPRxStableTimeout = DPRX_STATE_STABLE_DEBOUNCE_TIME;
                    }
                }

                mhal_DPRx_HDCPLinkFailReset(dprx_id);
                mhal_DPRx_HDCP14SoftReset(dprx_id);
                mhal_DPRx_HDCP22SoftReset(dprx_id);
                mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, TRUE);

                glDPRxInfo[dprx_id].ucState = DPRx_STATE_CKECKLOCK;

                glDPRxInfo[dprx_id].bHdcpStartAuth = FALSE;
                DP_DRV_DPRINTF("\r\n** DP loss lock normal -> check! port %d\r\n", dprx_id);
            }
            else if(_mdrv_DPRx_CheckVPLLBigChange(dprx_id))
            {
                glDPRxInfo[dprx_id].ucState = DPRx_STATE_MEASURE;
                glDPRxInfo[dprx_id].DPCheckModeCnt = 0;
                glDPRxInfo[dprx_id].uwDPRxStableTimeout = DPRX_STATE_STABLE_DEBOUNCE_TIME;
                mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, TRUE);
                glDPRxInfo[dprx_id].bHdcpStartAuth = FALSE;

                DP_DRV_DPRINTF("\r\n** DP VPLL change normal -> measure! port %d\r\n", dprx_id);
            }
            else
            {
                for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
                {
                    if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
                    {
#if 1
                        glDPRxInfo[dprx_id].bRxDecodeStable = TRUE;
#else
                        // Avoid upstream data from garbage to normal, we have to output normal data
                        if(mhal_DPRx_IsInputStreamValid(dprx_decoder_id) == TRUE)
                        {
                            glDPRxInfo[dprx_id].bRxDecodeStable = TRUE;
                        }

                        if(glDPRxInfo[dprx_id].bRxDecodeStable == TRUE)
                        {
                            if(mhal_DPRx_GetHwHtotalLearningStable(dprx_aux_id, dprx_decoder_id) == FALSE)
                            {
                                if(ucUnStableTimes[dprx_decoder_id] < 10)
                                {
                                    ucUnStableTimes[dprx_decoder_id]++;
                                }
                            }
                            else
                            {
                                ucUnStableTimes[dprx_decoder_id] = 0;
                            }

                            if(ucUnStableTimes[dprx_decoder_id] == 10)
                            {
                                glDPRxInfo[dprx_id].bRxDecodeStable = FALSE;
                            }
                        }
#endif
                    }
                }

                _mdrv_DPRx_NormalModeSetting(dprx_id);
                _mdrv_DPRx_Regen_Sync(dprx_id);

                bSignalStable = TRUE;
            }
            break;

        default:
            break;
    }

    if(glDPRxInfo[dprx_id].ucPreState != glDPRxInfo[dprx_id].ucState)
    {
        glDPRxInfo[dprx_id].ucPreState = glDPRxInfo[dprx_id].ucState;

        if(glDPRxInfo[dprx_id].ucState == DPRx_STATE_CKECKLOCK)
        {
            for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
            {
                if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
                {
                    mhal_DPRx_UpdateAudioMNCode(dprx_decoder_id, 0, 0);
                }
            }
        }
    }

    return bSignalStable;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_Regen_Sync()
//  [Description]
//					_mdrv_DPRx_Regen_Sync
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_Regen_Sync(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    mhal_DPRx_EnableRegenSync(dprx_decoder_id, FALSE);
    mhal_DPRx_SetRegenSync(dprx_id, (BIT0 << dprx_id));

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_StablePolling()
//  [Description]
//					_mdrv_DPRx_StablePolling
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_StablePolling(DPRx_ID dprx_id)
{
    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    _mdrv_DPRx_PollingPacket(dprx_id);
    mdrv_DPRx_PollingColorimetry(dprx_id);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_PollingPacket()
//  [Description]
//					_mdrv_DPRx_PollingPacket
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_PollingPacket(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;
    static BYTE ucPrePacketTimer[DPRx_DECODER_ID_MAX] = {0};

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
        {
            if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketTimer == 0)
            {
                // 1000ms/fps = (1000 / pixel clk * 100000) * VTT * HTT
                if(glDPRxDecoderInfo[dprx_decoder_id].uwDPPixel != 0)
                {
                    glDPRxDecoderInfo[dprx_decoder_id].ucPacketTimer = glDPRxDecoderInfo[dprx_decoder_id].ulFrameTime;
                    ucPrePacketTimer[dprx_decoder_id] = glDPRxDecoderInfo[dprx_decoder_id].ucPacketTimer;
                }
                else
                {
                    glDPRxDecoderInfo[dprx_decoder_id].ucPacketTimer = ucPrePacketTimer[dprx_decoder_id];
                }

                glDPRxDecoderInfo[dprx_decoder_id].uwInputPacketStatus = mhal_DPRx_GetPacketStatus(dprx_decoder_id);
                break; // Temp solution for 1 port using 1 decoder case
            }
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_CableDisconnectReset()
//  [Description]
//					_mdrv_DPRx_CableDisconnectReset
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_CableDisconnectReset(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    BOOL bRxPortAtOffline = FALSE;

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    DP_DRV_DPUTSTR("Rx cable disconnect Reset \r\n");
    mhal_DPRx_CableDisconectResetDPCD(dprx_id, dprx_aux_id);
    glDPRxInfo[dprx_id].bHdcpStartAuth = FALSE;
    glDPRxInfo[dprx_id].bOverWriteLockStatus = FALSE;
    mhal_DPRx_OverWriteDPCD202_203(dprx_id, FALSE, 0x0000);

    bRxPortAtOffline = mhal_DPRx_IsAuxAtOffLine(dprx_aux_id);

    // Clear fake training status need at DP offline mode
    mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, TRUE);
    _mdrv_DPRx_ClearFakeTrainingLockStatus(dprx_id);

    if(bRxPortAtOffline == FALSE)
    {
        mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, FALSE);
        mhal_DPRx_SetCDRLossLockInterrupt(dprx_id, FALSE);
        mhal_DPRx_SetInterlaneSkewLoseInterrupt(dprx_id, FALSE);
        mhal_DPRx_SetInterlaneSkewDoneInterrupt(dprx_id, FALSE);
    }

    glDPRxInfo[dprx_id].ucState = DPRx_STATE_STARTUP;
    glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable = FALSE;

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_CheckCableDetection()
//  [Description]
//					_mdrv_DPRx_CheckCableDetection
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_CheckCableDetection(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    static BYTE ubDisconnectDebouce[DPRx_ID_MAX] = {0x0};

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

#if (SET_DPC_PORT_AS_DP_PORT == 0x0) // For DPRx_ID_3 is not DPC port case
    if(dprx_id != DPRx_ID_3) // DPRx_ID_3 is DPC port, cable detect is different from DP port
#endif
    {
        if(mhal_DPRx_CableGND_Level(dprx_aux_id) == FALSE) // GND detected
        {
            glDPRxInfo[dprx_id].bDPcableConnent = TRUE;
            ubDisconnectDebouce[dprx_id] = 0x0;
        }
        else
        {
            ubDisconnectDebouce[dprx_id]++;

            if((ubDisconnectDebouce[dprx_id] > 0x20) && (mhal_DPRx_AUX_N_Level(dprx_aux_id) == FALSE)) // Connect --> disconnect, double confirm AUX_N disappear
            {
                if(glDPRxInfo[dprx_id].bDPcableConnent == TRUE)
                {
                    _mdrv_DPRx_CableDisconnectReset(dprx_id);
                }

                mhal_DPRx_OverWriteDPCD202_203(dprx_id, FALSE, 0x0000);
                glDPRxInfo[dprx_id].bOverWriteLockStatus = FALSE;

                glDPRxInfo[dprx_id].bDPcableConnent = FALSE;
            }
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_CTSCheck()
//  [Description]
//					_mdrv_DPRx_CTSCheck
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL _mdrv_DPRx_CTSCheck(DPRx_ID dprx_id)
{
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    BOOL XDATA bCTSFlag = FALSE;

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    if(glDPRxInfo[dprx_id].bDPAutoTestEn)
    {
        glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;

        mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);

        bCTSFlag = TRUE;

		if((glDPRxInfo[dprx_id].ubTypeC_PinAssign == BIT2)&& //pin C
			(glDPRxInfo[dprx_id].ubTypeC_CC != 0x2))
		{
			//T.B.D
		}
		else if((glDPRxInfo[dprx_id].ubTypeC_PinAssign == BIT3)&& //pin D
			(glDPRxInfo[dprx_id].ubTypeC_CC != 0x2))
		{
			if(glDPRxInfo[dprx_id].ubTypeC_CC == 0x0)
			{
				//T.B.D
			}
			else if(glDPRxInfo[dprx_id].ubTypeC_CC == 0x1)
			{
				//T.B.D
			}
		}
		else if((glDPRxInfo[dprx_id].ubTypeC_PinAssign == BIT4)&& //pin E
		(glDPRxInfo[dprx_id].ubTypeC_CC != 0x2))
		{
			//T.B.D
		}

        if(glDPRxInfo[dprx_id].DPVersion == DP_VERSION_11)
        {
            mhal_DPRx_SetInternalDPVersion(dprx_id, dprx_aux_id, 0x1, DP_VERSION_11); // DP_VERSION_11 is only for HW internal version, not DPCD value
        }
        else
        {
            mhal_DPRx_SetInternalDPVersion(dprx_id, dprx_aux_id, 0x4, DP_VERSION_14); // DP_VERSION_14 is only for HW internal version, not DPCD value
        }
    }
    else
    {
        // Default set to the highest supported DP version because of some HW restriction by DP version
        mhal_DPRx_SetInternalDPVersion(dprx_id, dprx_aux_id, 0x4, DP_VERSION_14);
    }

    return bCTSFlag;
}
//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_FakeTrainingLockStatus_Set()
//  [Description]
//					_mdrv_DPRx_FakeTrainingLockStatus_Set
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_FakeTrainingLockStatus_Set(DPRx_AUX_ID dprx_aux_id, BYTE ubLinkRate, BYTE ubLaneCount)
{
    if(dprx_aux_id == DPRx_AUX_ID_MAX)
    {
        return;
    }

    BYTE i = 0x0;
    BYTE ubState = 0x0;

    for(i = 0x0; i < 0x50; i++)
    {
        switch(ubState)
        {
            case 0:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00100, ubLinkRate);
                    ubState = 1;
                }
                break;

            case 1:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00101, ubLaneCount);
                    ubState = 2;
                }
                break;

            case 2:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00102, 0x21);
                    ubState = 3;
                }
                break;

            case 3:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00103, (Faketrain_pre << 3) + Faketrain_swing);
                    ubState = 4;
                }
                break;

            case 4:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00104, (Faketrain_pre << 3) + Faketrain_swing);
                    ubState = 5;
                }
                break;

            case 5:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00105, (Faketrain_pre << 3) + Faketrain_swing);
                    ubState = 6;
                }
                break;

            case 6:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00106, (Faketrain_pre << 3) + Faketrain_swing);
                    ubState = 7;
                }
                break;

            case 7:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00102, 0x23);
                    ubState = 8;
                }
                break;

            default:
                break;
        }

        if(ubState == 8)
        {
            break;
        }

        mhal_DPRx_DELAY_NOP(300 + i*150);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
// 				 	_mdrv_DP_ClearFakeTrainingLockStatus()
//  [Description]
//					_mdrv_DP_ClearFakeTrainingLockStatus
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_ClearFakeTrainingLockStatus(DPRx_ID dprx_id)
{
    BYTE i = 0x0;
    BYTE ubState = 0x0;
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    for(i = 0x0; i < 0x50; i++)
    {
        switch(ubState)
        {
            case 0:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00103, 0x0);
                    ubState = 1;
                }
                break;

            case 1:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00104, 0x0);
                    ubState = 2;
                }
                break;

            case 2:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00105, 0x0);
                    ubState = 3;
                }
                break;

            case 3:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00106, 0x0);
                    ubState = 4;
                }
                break;
			case 4:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00102, 0x1);
                    ubState = 5;
                }
                break;
            case 5:
                if(!mhal_DPRx_GetAuxValid(dprx_aux_id))
                {
                    mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00102, 0x0);
                    ubState = 6;
                }
                break;
            default:
                break;
        }

        if(ubState == 6)
        {
            break;
        }

        mhal_DPRx_DELAY_NOP(300 + i*150);
    }

    return;
}

#if 1//(DPRX_HDCP14_Repeater_ENABLE == 0x1)
//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_HDCP14Handler()
//  [Description]
//					_mdrv_DPRx_HDCP14Handler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_HDCP14Handler(DPRx_ID dprx_id)
{
    //DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    return;
}
#endif

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_MSCHIP_ScreenMute()
//  [Description]
//                  _mdrv_DPRx_MSCHIP_ScreenMute
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_MSCHIP_ScreenMute(void)
{
    if((INPUT_IS_DISPLAYPORT(SrcInputType) == TRUE) || (INPUT_IS_USBTYPEC(SrcInputType) == TRUE))
    {
         MuteVideoAndAudio();
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_MSCHIP_DPRxID2PortNumber()
//  [Description]
//					_mdrv_DPRx_MSCHIP_DPRxID2PortNumber
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE _mdrv_DPRx_MSCHIP_DPRxID2PortNumber(DPRx_ID dprx_id)
{
    if(dprx_id == DPRx_ID_MAX)
    {
        return Input_Nothing;
    }

    switch(dprx_id)
    {
        case DPRx_ID_0:
            return Input_Displayport_C1;
            break;

        case DPRx_ID_1:
            return Input_Displayport_C2;
            break;

        case DPRx_ID_2:
            return Input_Displayport_C3;
            break;

        case DPRx_ID_3:
            if(Input_Displayport_C4 != Input_Nothing)
            {
                return Input_Displayport_C4;
            }
            else
            {
                return Input_UsbTypeC_C4;
            }
            break;

        default:
            return Input_Nothing;
            break;
    }

    return Input_Nothing;
}

//**************************************************************************
//  [Function Name]:
//				  	_mdrv_DPRx_MSCHIP_DPRxID2DecodeID()
//  [Description]
//					_mdrv_DPRx_MSCHIP_DPRxID2DecodeID
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
DPRx_DECODER_ID _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(DPRx_ID dprx_id)
{
    if(dprx_id == DPRx_ID_MAX)
    {
        return DPRx_DECODER_ID_MAX;
    }
    else
    {
        return DPRx_DECODER_ID_0;
    }
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID()
//  [Description]
//					_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
DPRx_ID _mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(DPRx_ID dprx_id)
{
    if(Input_UsbTypeC4 != Input_Nothing)
    {
        if((dprx_id >= DPRx_ID_3) && (dprx_id < DPRx_ID_MAX))
        {
            return (dprx_id - DPRx_ID_3);
        }
    }

    return DPRx_ID_MAX;
}

void ________INIT________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_Initial()
//  [Description]
//					mdrv_DPRx_Initial
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_Initial(void)
{
    DPRx_ID dprx_id = DPRx_ID_MAX;
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    DPRx_PHY_ID dprx_phy_id = DPRx_PHY_ID_MAX;
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;

    msEread_Init(&usInfo1, &ubInfo2);
    mdrv_DPRx_InitValue();
    mhal_DPRx_EDIDOffsetSetting();
    mhal_DPRx_SetAuxClockGating(FALSE);

    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        mhal_DPRx_Initial_Decoder(dprx_decoder_id);
    }

    for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
    {
        dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
        dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

        if(GET_DPRx_FUNCTION_ENABLE_PORT(dprx_id))
        {
            if(dprx_id == DPRx_ID_0)
            {
                mhal_DPRx_Load_EDID(dprx_id, dprx_aux_id, EDID_DPRX_PORT0);
            }
            else if(dprx_id == DPRx_ID_1)
            {
                mhal_DPRx_Load_EDID(dprx_id, dprx_aux_id, EDID_DPRX_PORT1);
            }
            else if(dprx_id == DPRx_ID_2)
            {
                mhal_DPRx_Load_EDID(dprx_id, dprx_aux_id, EDID_DPRX_PORT2);
            }
            else if(dprx_id == DPRx_ID_3)
            {
                mhal_DPRx_Load_EDID(dprx_id, dprx_aux_id, EDID_DPRX_PORT3);
            }

            printf("[DPRx] dprx_id => %x \r\n", dprx_id);
            printf("[DPRx] dprx_aux_id => %x \r\n", dprx_aux_id);
            printf("[DPRx] dprx_phy_id => %x \r\n", dprx_phy_id);

            mhal_DPRx_Initial(dprx_id, dprx_aux_id, dprx_phy_id);

            if(_mdrv_DPRx_MSCHIP_DPRxID2PortNumber(dprx_id) == Input_UsbTypeC_C4)
            {
                mhal_DPRx_SetHwHPDControlEnable(dprx_aux_id, FALSE);
            }
            else
            {
                mhal_DPRx_SetHwHPDControlEnable(dprx_aux_id, TRUE);
            }

            #if (DP_RX_FT_TIMER_A_WAIT_SQ_SIGNAL == 0x0)
            mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);
            #endif

            glHPEllitePatchEnable[dprx_id] = TRUE;
        }
        else
        {
            glHPEllitePatchEnable[dprx_id] = FALSE;
        }
    }

    // Search invalid AUX_ID for power down setting
    for(dprx_aux_id = DPRx_AUX_ID_0; dprx_aux_id < DPRx_AUX_ID_MAX; dprx_aux_id++)
    {
        if((DPRx_C1_AUX == dprx_aux_id) || (DPRx_C2_AUX == dprx_aux_id) || (DPRx_C3_AUX == dprx_aux_id) || (DPRx_C4_AUX == dprx_aux_id))
        {
            // Power on for used port
        }
        else
        {
            // 1. For get more power-saving benefit, we should turn-off some HW for non-DP port
            // 2. For HDMI use case, also need this setting
            mhal_DPRx_SetPowerDownControl(DPRx_ID_MAX, dprx_aux_id, DP_ePM_POWEROFF_NoUsedPort);
        }
    }

    // Power down PHY1 if DPC port is not used
    if(DPRx_C4_AUX == AUX_None)
    {
        mhal_DPRx_PHYPowerModeSetting(mhal_ePM_POWEROFF, DPRx_ID_3, DPRx_PHY_ID_1);
    }

    mdrv_DPRx_SetAuxPMClock(TRUE); // Set PM Aux clock to Xtal check aux idle need after aux initial

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_InitValue()
//  [Description]
//					mdrv_DPRx_InitValue
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_InitValue(void)
{
    DPRx_ID dprx_id = DPRx_ID_MAX;
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;

    glLastRxID = 0xFF;

    memset(&glDPRxInfo, 0, sizeof(glDPRxInfo));

    for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
    {
        glDPRxInfo[dprx_id].ucState = DPRx_STATE_STARTUP;
        glDPRxInfo[dprx_id].decoderID_Info = (BIT0 << DPRx_DECODER_ID_0);
        glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;
        glDPRxInfo[dprx_id].OnlinePort = DPRx_ID_MAX;
        glTypeC_PhyLaneSwap[dprx_id] = 0xE4;
    }

    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable = TRUE;
    }

    if(Input_Displayport_C1 != Input_Nothing)
    {
        ucDPFunctionEnableIndex |= BIT0;
    }

    if(Input_Displayport_C2 != Input_Nothing)
    {
        ucDPFunctionEnableIndex |= BIT1;
    }

    if(Input_Displayport_C3 != Input_Nothing)
    {
        ucDPFunctionEnableIndex |= BIT2;
    }

    if((Input_Displayport_C4 != Input_Nothing) || (Input_UsbTypeC_C4 != Input_Nothing))
    {
        ucDPFunctionEnableIndex |= BIT3;
    }

    ucDPTPCFunctionEnableIndex = 0; // T.B.D

    printf("[DPRx] ucDPFunctionEnableIndex => %x \r\n", ucDPFunctionEnableIndex);
    printf("[DPRx] ucDPTPCFunctionEnableIndex => %x \r\n", ucDPTPCFunctionEnableIndex);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRX_PortConfigSetting()
//  [Description]
//					mdrv_DPRX_PortConfigSetting
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRX_PortConfigSetting(BYTE *ucDPFunctionPtr, BYTE *ucDPTPCFunctionPtr)
{
    // DP port check
    if(Input_Displayport_C1 != Input_Nothing)
    {
        *ucDPFunctionPtr |= BIT0;
    }

    if(Input_Displayport_C2 != Input_Nothing)
    {
        *ucDPFunctionPtr |= BIT1;
    }

    if(Input_Displayport_C3 != Input_Nothing)
    {
        *ucDPFunctionPtr |= BIT2;
    }

    // TpyeC port check
    if(Input_UsbTypeC_C3 != Input_Nothing)
    {
        *ucDPTPCFunctionPtr |= DP_TYPEC_PORT0;
        *ucDPFunctionPtr |= BIT3;
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_VersionSetting()
//  [Description]
//					mdrv_DPRx_VersionSetting
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_VersionSetting(BYTE ucInputPort, BYTE ucVersion)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX) || (dprx_phy_id == DPRx_PHY_ID_MAX))
    {
        return;
    }

    glDPRxInfo[dprx_id].DPVersion = ucVersion;

    mhal_DPRx_VersionSetting(dprx_id, dprx_aux_id, ucVersion);
    mhal_DPRx_Switch_Training_Setting(dprx_phy_id, mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_00001), glDPRxInfo[dprx_id].bDPAutoTestEn);

    #if(DP_VESA_ADAPTIVE_SYNC_SDP_SUPPORT == 0x1)
    if(glDPRxInfo[dprx_id].DPVersion >= DP_VERSION_14)
    {
        mdrv_DPRx_SetVESA_AdaptiveSyncSDPEanble(ucInputPort, TRUE);
    }
    else
    {
        mdrv_DPRx_SetVESA_AdaptiveSyncSDPEanble(ucInputPort, FALSE);
    }
    #endif

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetupInputPort_DisplayPort()
//  [Description]
//					mdrv_DPRx_SetupInputPort_DisplayPort
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetupInputPort_DisplayPort(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    BYTE ubCheckAuxIdleTimes;
    BYTE ubLinkRate;
    BYTE ubLaneCount;
    DPRx_ID dprx_temp_id;

    // Avoid waste time to do the same settings
    if(dprx_id != DPRx_ID_MAX)
    {
        mhal_DPRx_OverWriteDPCD202_203(dprx_id, FALSE, 0x0000);
        glDPRxInfo[dprx_id].bOverWriteLockStatus = FALSE;
        glDPRxInfo[dprx_id].OnlinePort = dprx_id;
    }

    if((glLastRxID == dprx_id) || (dprx_id == DPRx_ID_MAX))
    {
        return;
    }

    ubCheckAuxIdleTimes = 0x0;

    while(ubCheckAuxIdleTimes < 10)
    {
        if(mhal_DPRx_GetAuxValid(dprx_aux_id) == FALSE) // Aux idle
        {
            break;
        }

        mhal_DPRx_DELAY_NOP(100 + (ubCheckAuxIdleTimes * 70));

        ubCheckAuxIdleTimes++;
    }

    // Disable interrupt during switch port
    mhal_DPRx_DecoderIsrDetectEnable(dprx_decoder_id, FALSE);
    mhal_DPRx_EnableReceiverInterrupt(dprx_id, FALSE);
    mhal_DPRx_SetCDRLossLockInterrupt(dprx_id, FALSE);
    mhal_DPRx_SetInterlaneSkewLoseInterrupt(dprx_id, FALSE);
    mhal_DPRx_SetInterlaneSkewDoneInterrupt(dprx_id, FALSE);

    #if((SET_DPC_PORT_AS_DP_PORT == 0x1) && (SET_DP_C4_LANE02_PN_SWAP == 0x1))
    if(dprx_id == DPRx_ID_3)
    {
        mhal_DPRx_SetAuxPNSwapEnable(dprx_aux_id, FALSE);
        mhal_DPRx_SetLanePNSwapEnable(dprx_id, TRUE, 0x5);
    }
    else
    {
        mhal_DPRx_SetAuxPNSwapEnable(dprx_aux_id, FALSE);
        mhal_DPRx_SetLanePNSwapEnable(dprx_id, TRUE, 0);
    }
    #else
    mhal_DPRx_SetLanePNSwapEnable(dprx_id, TRUE, glTypeC_MacPNswap[dprx_id]);
    #endif

	if(glLastRxID != 0xFF)
	{
		if((mhal_DPRx_GetDPCDValueByRIU(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPCD_00202) & 0x0F) != 0x7) // online -> offline
		{
			mhal_DPRx_SetOffLine(glLastRxID, _mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), TRUE);
			_mdrv_DPRx_ClearFakeTrainingLockStatus(glLastRxID);
		}
		else
		{
			ubLinkRate = mhal_DPRx_GetDPCDValueByRIU(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPCD_00100);
			ubLaneCount = mhal_DPRx_GetDPCDValueByRIU(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPCD_00101);
			mhal_DPRx_SetOffLine(glLastRxID, _mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), TRUE);
			_mdrv_DPRx_FakeTrainingLockStatus_Set(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), ubLinkRate, ubLaneCount);
		}

		glDPRxInfo[glLastRxID].bHdcpStartAuth = FALSE;
        mhal_DPRx_SetProgrammableDPCDEnable(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), FALSE); // diable offline dpcd

        if(ubInfo2 < 2) // programmable dpcd i2c 0x30 need keep open during offline
        {
            mhal_DPRx_SetProgramDPCD(TRUE, _mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPRx_PROGRAM_DPCD_0, DPRX_PROGRAM_DPCD0_ADDERSS, FALSE);
            mhal_DPRx_SetProgramDPCDInterrupt(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPRx_PROGRAM_DPCD_0, TRUE);
        }
	}
    else
    {
        for(dprx_temp_id = DPRx_ID_0; dprx_temp_id < DPRx_ID_MAX; dprx_temp_id++)
        {
            mhal_DPRx_SetProgrammableDPCDEnable(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_temp_id), FALSE); // diable offline dpcd

            if(ubInfo2 < 2) // programmable dpcd i2c 0x30 need keep open during offline
            {
	            mhal_DPRx_SetProgramDPCD(TRUE,_mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_temp_id), DPRx_PROGRAM_DPCD_0, DPRX_PROGRAM_DPCD0_ADDERSS, FALSE);
	            mhal_DPRx_SetProgramDPCDInterrupt(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_temp_id), DPRx_PROGRAM_DPCD_0, TRUE);
            }
        }
    }

    mhal_DPRx_SetupInputPort(dprx_id, dprx_aux_id, TRUE);
    _mdrv_DPRx_MuxSelect(dprx_id, dprx_aux_id);

    mhal_DPRx_ResetAsyncFIFO(dprx_id, dprx_aux_id);
    mhal_DPRx_SetProgrammableDPCDEnable(dprx_aux_id, TRUE);
    mhal_DPRx_Switch_Training_Setting(dprx_phy_id, mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_00100), glDPRxInfo[dprx_id].bDPAutoTestEn);

	if((mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_00202) & 0x0F) != 0x7) // offline -> online
	{
		mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, FALSE);
	}
	else
	{
		#if (DPRX_OFFLINE_TO_ONLINE_KEEP_LOCK == 0x1)
		//keep offline wait fast train
		#else
		mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, FALSE);
		#endif
	}

	mhal_DPRx_SetGPIOforAUX(dprx_aux_id, TRUE);

	// Enable interrupt after switch port
	mhal_DPRx_EnableReceiverInterrupt(dprx_id, TRUE);

    #if(DP_VESA_ADAPTIVE_SYNC_SDP_SUPPORT == 0x1)
    if(glDPRxInfo[dprx_id].DPVersion >= DP_VERSION_14)
    {
        mdrv_DPRx_SetVESA_AdaptiveSyncSDPEanble(ucInputPort, TRUE);
    }
    else
    {
        mdrv_DPRx_SetVESA_AdaptiveSyncSDPEanble(ucInputPort, FALSE);
    }
    #endif

    // Check have been do HDCP14 on offline port, if yes request Tx do reauth
    if((mhal_DPRx_HDCP14CheckAKSVStatus(dprx_aux_id)) || (mhal_DPRx_HDCP14CheckAnStatus(dprx_aux_id)))
    {
        mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, FALSE);
        DP_DRV_DPUTSTR("******HDCP Long HPD set Low********\r\n");
        glDPRxInfo[dprx_id].ucHDCPLongHPDTimer = DPRX_HDCP14_LONGHPD_WDT;
        glDPRxInfo[dprx_id].bHDCPLongHPDTrigger = TRUE;
        glDPRxInfo[dprx_id].bDPLoseCDRLockIRQ = FALSE; // Avoid HPD conflict with CDR loss lock event

        if(_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id) != DPRx_ID_MAX)
        {
            glubTriggerTypeCHPDFlag[_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id)] = TRUE;
            glubTypeCHPDCtrl[_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id)] = FALSE;
        }
        else
        {
            mhal_DPRx_HPDControl(dprx_aux_id, FALSE);
        }
    }

	glLastRxID = dprx_id;

    if(dprx_id == DPRx_ID_MAX) // For non DP port case, all port set offline
    {
        glLastRxID = 0xFF;
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_Switch_Port_Check()
//  [Description]
//					mdrv_DPRx_Switch_Port_Check
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_Switch_Port_Check(void)
{
    BYTE ubLinkRate;
    BYTE ubLaneCount;

    if(glLastRxID != 0xFF)
	{
		if((mhal_DPRx_GetDPCDValueByRIU(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPCD_00202) & 0x0F) != 0x7) // online -> offline
		{
			mhal_DPRx_SetOffLine(glLastRxID, _mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), TRUE);
			_mdrv_DPRx_ClearFakeTrainingLockStatus(glLastRxID);
		}
		else
		{
			ubLinkRate = mhal_DPRx_GetDPCDValueByRIU(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPCD_00100);
			ubLaneCount = mhal_DPRx_GetDPCDValueByRIU(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), DPCD_00101);
			mhal_DPRx_SetOffLine(glLastRxID, _mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), TRUE);
			_mdrv_DPRx_FakeTrainingLockStatus_Set(_mdrv_DPRx_MSCHIP_DPRxID2AuxID(glLastRxID), ubLinkRate, ubLaneCount);
		}

		glDPRxInfo[glLastRxID].bHdcpStartAuth = FALSE;
		glDPRxInfo[glLastRxID].OnlinePort = DPRx_ID_MAX;
		glLastRxID = 0xFF;
	}

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_Not_DisplayPort()
//  [Description]
//					mdrv_DPRx_Not_DisplayPort
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_Not_DisplayPort(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;

    for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
    {
        dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
        dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

        glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;
        glDPRxInfo[dprx_id].OnlinePort = DPRx_ID_MAX;

        mhal_DPRx_SetupInputPort(dprx_id, dprx_aux_id, FALSE);

        #if (DP_RX_FT_TIMER_A_WAIT_SQ_SIGNAL == 0x0)
        mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);
        #endif

        mhal_DPRx_SetProgrammableDPCDEnable(dprx_aux_id, FALSE);

        // Disable interrupt for non-DP port
        mhal_DPRx_DecoderIsrDetectEnable(dprx_decoder_id, FALSE);
        mhal_DPRx_EnableReceiverInterrupt(dprx_id, FALSE);
        mhal_DPRx_SetCDRLossLockInterrupt(dprx_id, FALSE);
        mhal_DPRx_SetInterlaneSkewLoseInterrupt(dprx_id, FALSE);
        mhal_DPRx_SetInterlaneSkewDoneInterrupt(dprx_id, FALSE);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_AUX_N_Level()
//  [Description]
//					mdrv_DPRx_AUX_N_Level
//  [Arguments]:
//
//  [Return]:   	1: Cable connect
//					0: Cable disconnect
//
//**************************************************************************
BOOL mdrv_DPRx_AUX_N_Level(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    switch(dprx_id)
    {
        case DPRx_ID_0:
            return mhal_DPRx_AUX_N_Level(dprx_aux_id);;

        case DPRx_ID_1:
            return mhal_DPRx_AUX_N_Level(dprx_aux_id);

        case DPRx_ID_2:
            return mhal_DPRx_AUX_N_Level(dprx_aux_id);

        case DPRx_ID_3:
#if(SET_DPC_PORT_AS_DP_PORT == 0x0) // For DPRx_ID_3 is not DPC port case
            return mhal_DPRx_TypeC_AUX_N_Level(dprx_id, glDPRxInfo[dprx_id].ubTypeC_PinAssign, glDPRxInfo[dprx_id].ubTypeC_CC);
#else
            return mhal_DPRx_AUX_N_Level(dprx_aux_id);
#endif

        default:
            return FALSE;
    }

    return FALSE;
}

void ________VIDEO________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetLaneCount()
//  [Description]
//					mdrv_DPRx_SetLaneCount
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetLaneCount(BYTE ucInputPort, BYTE ubLaneCount)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    BYTE uctemp = 0;

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    if((ubLaneCount == DP_LANECOUNT_1) || (ubLaneCount == DP_LANECOUNT_2) || (ubLaneCount == DP_LANECOUNT_4))
    {
        uctemp = ((mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_00002) & 0xE0) | ubLaneCount);
        mhal_DPRx_SetDPCDValueByRIU(dprx_id, dprx_aux_id, DPCD_00002, uctemp);

        uctemp = ((mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_02202) & 0xE0) | ubLaneCount);
        mhal_DPRx_SetDPCDValueByRIU(dprx_id, dprx_aux_id, DPCD_02202, uctemp);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetDPVersion()
//  [Description]
//					mdrv_DPRx_GetDPVersion
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_GetDPVersion(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return 0x0;
    }

    return mhal_DPRx_GetDPVersion(dprx_aux_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetDPCDLinkRate()
//  [Description]
//					mdrv_DPRx_GetDPCDLinkRate
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_GetDPCDLinkRate(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    WORD ucLockStatus;

    if(dprx_id == DPRx_ID_MAX)
    {
        return 0;
    }

    ucLockStatus = ((mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_00203) << 8) | mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_00202));

    if(ucLockStatus != 0x7 && ucLockStatus != 0x77 && ucLockStatus != 0x7777)
    {
        return 0;
    }

    return mhal_DPRx_GetDPCDLinkRate(dprx_aux_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetDPLaneCnt()
//  [Description]
//					mdrv_DPRx_GetDPLaneCnt
//  [Arguments]:
//
//	[Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_GetDPLaneCnt(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    WORD ucLockStatus;

    if(dprx_id == DPRx_ID_MAX)
    {
        return 0;
    }

    ucLockStatus = ((mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_00203) << 8) | mhal_DPRx_GetDPCDValueByRIU(dprx_aux_id, DPCD_00202));

    if(ucLockStatus != 0x7 && ucLockStatus != 0x77 && ucLockStatus != 0x7777)
    {
        return 0;
    }

    return mhal_DPRx_GetDPLaneCnt(dprx_aux_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetHVInformation()
//  [Description]
//					mdrv_DPRx_GetHVInformation
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_GetHVInformation(BYTE ucInputPort, WORD *usHTotalValue, WORD *usVTotalValue)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return;
    }

    *usHTotalValue = glDPRxDecoderInfo[dprx_decoder_id].uwDPHtotal;
    *usVTotalValue = glDPRxDecoderInfo[dprx_decoder_id].uwDPVtotal;

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetHVDEInformation()
//  [Description]
//					mdrv_DPRx_GetHVDEInformation
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_GetHVDEInformation(BYTE ucInputPort, WORD *usHDE, WORD *usVDE)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return;
    }

    *usHDE = glDPRxDecoderInfo[dprx_decoder_id].uwDPHWidth;
    *usVDE = glDPRxDecoderInfo[dprx_decoder_id].uwDPVWidth;

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetPixelClock()
//  [Description]
//					mdrv_DPRx_GetPixelClock
//  [Arguments]:
//
//  [Return]:
//                  Pixel clock = xxx MHz
//**************************************************************************
WORD mdrv_DPRx_GetPixelClock(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return mhal_DPRx_GetTimingPixelClock(dprx_id, dprx_decoder_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetPixelClock10K()
//  [Description]
//					mdrv_DPRx_GetPixelClock10K
//  [Arguments]:
//
//  [Return]:
//                  Pixel clock = xxx MHz
//**************************************************************************
WORD mdrv_DPRx_GetPixelClock10K(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return mhal_DPRx_GetTimingPixelClock10K(dprx_id, dprx_decoder_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetMSAChgFlag()
//  [Description]
//					mdrv_DPRx_GetMSAChgFlag
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetMSAChgFlag(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return FALSE;
    }

    return glDPRxDecoderInfo[dprx_decoder_id].bDPMSAChange;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_ClrMSAChgFlag()
//  [Description]
//					mdrv_DPRx_ClrMSAChgFlag
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_ClrMSAChgFlag(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return;
    }

    glDPRxDecoderInfo[dprx_decoder_id].bDPMSAChange = FALSE;

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_PollingColorimetry()
//  [Description]
//					mdrv_DPRx_PollingColorimetry
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_PollingColorimetry(DPRx_ID dprx_id)
{
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    BYTE usPollingInfo[DPRX_STABLE_POLLING_QUEUE_SIZE] = {0};
    BYTE usColorSpace = DP_COLOR_FORMAT_UNKNOWN;
    BYTE ucColorFormat = DP_COLOR_FORMAT_UNKNOWN;

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return;
    }

    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
        {
            mhal_DPRx_GetMISC01(dprx_decoder_id, usPollingInfo);

            glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 = usPollingInfo[0];
            glDPRxDecoderInfo[dprx_decoder_id].DPMISC1 = usPollingInfo[1];

            if(glDPRxDecoderInfo[dprx_decoder_id].DPMISC1 & BIT6) // Ignore MISC 0
            {
                mhal_DPRx_GetVSCSDP(dprx_id, usPollingInfo);

                // VSC SDP DB16 --> Pixel Encoding and Colorimetry Formats
                //==========================================================================================
                // Bit 7:4 --> Pixel Encoding
                //******************************************************************************************
                // 0: RGB
                // 1: YCbCr444
                // 2: YCbCr422
                // 3: YCbCr420
                // 4: Y-only
                // 5: RAW
                //==========================================================================================
                switch(usPollingInfo[0] >> 4)
                {
                    case 0:
                        glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_RGB;
                        break;

                    case 1:
                        glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_YUV_444;
                        break;

                    case 2:
                        glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_YUV_422;
                        break;

                    case 3:
                        glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_YUV_420;
                        break;

                    case 4:
                        glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_YONLY;
                        break;

                    case 5:
                        glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_RAW;
                        break;

                    default:
                        glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_UNKNOWN;
                        break;
                }

                // VSC SDP DB16 --> Pixel Encoding and Colorimetry Formats
                //==========================================================================================
                // Bit 3:0 --> Colorimetry Formats
                //******************************************************************************************
                // RGB                                  YCbCr444/422/420
                // 0: sRGB                              0: ITU-R BT601
                // 1: RGB wide gamut fixed point        1: ITU-R BT709
                // 2: RGB wide gamut floating point     2: xvYCC601
                // 3: Adobe RGB                         3: xvYCC709
                // 4: DCI-P3                            4: sYCC601
                // 5: Custom color profile              5: Adobe YCC601
                // 6: ITU-R BT2020 RGB                  6: ITU-R BT2020 YcCbcCrc
                //                                      7: ITU-R BT2020 YcCbCr
                //==========================================================================================
                _mdrv_DPRx_VSCPayload(dprx_id, usPollingInfo[0]);

                // VSC SDP DB17 --> Dynamic Range and Component Bit Depth Type
                //==========================================================================================
                // Bit 7 --> Dynamic Range
                //******************************************************************************************
                // 0: VESA range
                // 1: CEA range
                //==========================================================================================
                if(usPollingInfo[1] & BIT7)
                {
                    glDPRxDecoderInfo[dprx_decoder_id].ucDPRangeFormat = DP_COLOR_RANGE_LIMIT;
                }
                else
                {
                    glDPRxDecoderInfo[dprx_decoder_id].ucDPRangeFormat = DP_COLOR_RANGE_FULL;
                }

                // VSC SDP DB17 --> Dynamic Range and Component Bit Depth Type
                //==========================================================================================
                // Bit 2:0 --> Component Bit Depth Type
                //******************************************************************************************
                // RGB          YCbCr444/422/420
                // 0: 6bpc
                // 1: 8bpc      1: 8bpc
                // 2: 10bpc     2: 10bpc
                // 3: 12bpc     3: 12bpc
                // 4: 16bpc     4: 16bpc
                //==========================================================================================
    			glDPRxDecoderInfo[dprx_decoder_id].ucDPColorDepth = usPollingInfo[1] & (BIT2|BIT1|BIT0);
            }
            else // Reference MISC0
            {
                glDPRxDecoderInfo[dprx_decoder_id].ucDPColorDepth = glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 >> 5;

                //==========================================================================================
                // MISC0[4:1] --> Pixel Encoding and Colorimetry Formats
                //******************************************************************************************
                // 0000: RGB    (MISC1[7] = 0)
                // 0000: Y-only (MISC1[7] = 1)
                // 0100: sRGB
                // 0011: RGB wide gamut fixed point
                // 1011: RGB wide gamut floating point
                // 0001: RAW
                // 0101: YCbCr422 ITU-R BT601
                // 1101: YCbCr422 ITU-R BT709
                // 0110: YCbCr444 ITU-R BT601
                // 1110: YCbCr444 ITU-R BT709
                // 0001: YCbCr422 xvYCC601
                // 1001: YCbCr422 xvYCC709
                // 0010: YCbCr444 xvYCC601
                // 1010: YCbCr444 xvYCC709
                // 1100: Adobe RGB
                //==========================================================================================
                if((glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 & (BIT1|BIT2|BIT3|BIT4)) == (BIT3|BIT4))
                {
                    glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_RGB;
                    glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_ADOBERBG;
                    glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_MAX;
                }
                else
                {
                    usColorSpace = (glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 & (BIT1|BIT2)) >> 1;

                    switch(usColorSpace)
                    {
                        case 0: // RGB
                            glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_RGB;
                            break;

                        case 1: // YCbCr422
                            glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_YUV_422;
                            break;

                        case 2: // YCbCr444
                            glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_YUV_444;
                            break;

                        default:
                            glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_UNKNOWN;
                            break;
                    }

                    if(glDPRxDecoderInfo[dprx_decoder_id].DPMISC1 & BIT7)
                    {
                        if(glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 & BIT1) // RAW
                        {
                            glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_RAW;
                        }
                        else // Y-only
                        {
                            glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat = DP_COLOR_FORMAT_YONLY;
                        }
                    }
                    else
                    {
                        if(glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 & (BIT1|BIT2)) // YCbCr444/422
                        {
                            if(glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 & BIT3) // YCbCr
                            {
                                if((glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 & BIT4) == BIT4) // ITU-R BT709
                                {
                                    glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_ITU709;
                                    glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU709;
                                }
                                else // ITU-R BT601
                                {
                                    glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_ITU601;
                                    glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU601;
                                }
                            }
                            else // xvYCC
                            {
                                if((glDPRxDecoderInfo[dprx_decoder_id].DPMISC0 & BIT4) == BIT4) // xvYCC709
                                {
                                    glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_xvYCC709;
                                    glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU709;
                                }
                                else // xvYCC601
                                {
                                    glDPRxDecoderInfo[dprx_decoder_id].ucColorType = DP_COLORIMETRY_xvYCC601;
                                    glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry = DP_YUV_COLORIMETRY_ITU601;
                                }
                            }
                        }
                    }
                }
            }

            switch(usPollingInfo[0] & (BIT1|BIT2|BIT3|BIT4))
            {
                case 0: // RGB
                case (BIT3|BIT4): // Adobe RGB
                case (BIT1|BIT2): // RGB wild
                case (BIT1|BIT2|BIT4): // RGB wild
                    glDPRxDecoderInfo[dprx_decoder_id].ucDPRangeFormat = DP_COLOR_RANGE_FULL;
                    break;

                default:
                    glDPRxDecoderInfo[dprx_decoder_id].ucDPRangeFormat = DP_COLOR_RANGE_LIMIT;
                    break;
            }
        }
    }

    // Only for TSUMR2
    // Overwrite VBlanking data to scalar for 640x480 Vblanking data abnormal issue
    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
        {
            if(ucColorFormat != glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat)
            {
                ucColorFormat = glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat;

                mhal_DPRx_OverwriteVBlankingData(dprx_decoder_id, glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat, glDPRxDecoderInfo[dprx_decoder_id].ucDPRangeFormat);
            }
        }
    }
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetYuvColorimetry()
//  [Description]
//					mdrv_DPRx_GetYuvColorimetry
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_GetYuvColorimetry(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return glDPRxDecoderInfo[dprx_decoder_id].ucYuvColorimetry;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetColorSpace()
//  [Description]
//					mdrv_DPRx_GetColorSpace
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_GetColorSpace(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return glDPRxDecoderInfo[dprx_decoder_id].ucDPColorFormat;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetColorRange()
//  [Description]
//					mdrv_DPRx_GetColorRange
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_GetColorRange(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return glDPRxDecoderInfo[dprx_decoder_id].ucDPRangeFormat;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetColorimetry()
//  [Description]
//					mdrv_DPRx_GetColorimetry
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_GetColorimetry(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return glDPRxDecoderInfo[dprx_decoder_id].ucColorType;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetColorDepthInfo()
//  [Description]
//					mdrv_DPRx_GetColorDepthInfo
//  [Arguments]:
//
//  [Return]:
//  				pPacketData[0] --> [7:5] bit
//  				000: 6 bit
//  				001: 8 bit
//  				010: 10 bit
//  				011: 12 bit
//  				100: 16 bit
//**************************************************************************
BYTE mdrv_DPRx_GetColorDepthInfo(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return glDPRxDecoderInfo[dprx_decoder_id].ucDPColorDepth & (BIT2|BIT1|BIT0);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetInterlaceFlag()
//  [Description]
//					mdrv_DPRx_GetInterlaceFlag
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetInterlaceFlag(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return FALSE;
    }

    return mhal_DPRx_GetInterlaceFlag(dprx_decoder_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_Get_Misc()
//  [Description]
//					mdrv_DPRx_Get_Misc
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_Get_Misc(BYTE ucInputPort, BYTE *pPacketData)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return FALSE;
    }

    pPacketData[0] = glDPRxDecoderInfo[dprx_decoder_id].DPMISC0;
    pPacketData[1] = glDPRxDecoderInfo[dprx_decoder_id].DPMISC1;

    if(glDPRxInfo[dprx_id].bRxDecodeStable)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_EnableDRRFunction()
//  [Description]
//					mdrv_DPRx_EnableDRRFunction
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_EnableDRRFunction(BYTE ucInputPort, BOOL bEnable)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    mhal_DPRx_EnableDRRFunction(dprx_aux_id, bEnable);

	if(bEnable == FALSE)
	{
		mdrv_DPRx_ClearFreeSyncFlag(ucInputPort);
	}

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetDRRFlag()
//  [Description]
//					mdrv_DPRx_GetDRRFlag
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetDRRFlag(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return FALSE;
    }

    return mhal_DPRx_GetDRRFlag(dprx_aux_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetPacketData()
//  [Description]
//                  mdrv_DPRx_GetPacketData
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetPacketData(BYTE ucInputPort, WORD PacketReceiveType, BYTE *pucPacketData, BYTE ucPacketLength)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    BYTE ubHeader[DP_SDP_PACKET_MAX_HEAD_LENGTH] = {0x0};
    BOOL bPktReceived = FALSE;

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return FALSE;
    }

    // Step1: find correct decoder for this Rx port
    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
        {
            break; // Temp solution for 1 port using 1 decoder case
        }
    }

    if(ucPacketLength > DP_SDP_PACKET_MAX_DATA_LENGTH)
    {
        ucPacketLength = DP_SDP_PACKET_MAX_DATA_LENGTH;
    }

    switch(PacketReceiveType)
    {
        case DP_HDR_PACKET:
            bPktReceived = mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_DRM, ubHeader, pucPacketData, ucPacketLength);

            #if (ENABLE_DP_OUTPUT == 0x0)
            mhal_DPRx_ClearPacketStatus(dprx_decoder_id, DP_SDP_SEL_DRM);
            #endif
            break;

        case DP_AVI_PACKET:
            bPktReceived = mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_AVI, ubHeader, pucPacketData, ucPacketLength);

            #if (ENABLE_DP_OUTPUT == 0x0)
            mhal_DPRx_ClearPacketStatus(dprx_decoder_id, DP_SDP_SEL_AVI);
            #endif
            break;

        case DP_SPD_PACKET:
            bPktReceived = mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_SPD, ubHeader, pucPacketData, ucPacketLength);
            #if (ENABLE_DP_OUTPUT == 0x0)
            mhal_DPRx_ClearPacketStatus(dprx_decoder_id, DP_SDP_SEL_SPD);
            #endif
            break;

        case DP_AUDIO_PACKET:
            bPktReceived = mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_AUI, ubHeader, pucPacketData, ucPacketLength);

            #if (ENABLE_DP_OUTPUT == 0x0)
            mhal_DPRx_ClearPacketStatus(dprx_decoder_id, DP_SDP_SEL_AUI);
            #endif
            break;

        case DP_AUDIO_TIMESTAMP:
            bPktReceived = mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_AUDIO_TIMESTAMP, ubHeader, pucPacketData, ucPacketLength);

            #if (ENABLE_DP_OUTPUT == 0x0)
            mhal_DPRx_ClearPacketStatus(dprx_decoder_id, DP_SDP_SEL_AUDIO_TIMESTAMP);
            #endif
            break;

        case DP_AUDIO_TIMESREAM:
            bPktReceived = mhal_DPRx_GetPacketData(dprx_decoder_id, DP_SDP_SEL_AUDIO_STREAM, ubHeader, pucPacketData, ucPacketLength);

            #if (ENABLE_DP_OUTPUT == 0x0)
            mhal_DPRx_ClearPacketStatus(dprx_decoder_id, DP_SDP_SEL_AUDIO_STREAM);
            #endif
            break;

        default:
            return FALSE;
    }

    return bPktReceived;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_CheckDPLock()
//  [Description]
//					mdrv_DPRx_CheckDPLock
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_CheckDPLock(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX) || (dprx_phy_id == DPRx_PHY_ID_MAX))
    {
        return FALSE;
    }

    return mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_CheckSourceLock()
//  [Description]
//					mdrv_DPRx_CheckSourceLock
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_CheckSourceLock(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    BOOL bSourceLock = FALSE;

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    if((glDPRxInfo[dprx_id].ucState > DPRx_STATE_CKECKLOCK) && (glDPRxInfo[dprx_id].ucState <= DPRx_STATE_NORMAL))
    {
        bSourceLock = TRUE;
    }

    return bSourceLock;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_CheckDPTimingStable()
//  [Description]
//					mdrv_DPRx_CheckDPTimingStable
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_CheckDPTimingStable(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    BOOL XDATA bStableFlag = FALSE;

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return FALSE;
    }

    if(dprx_decoder_id < DPRx_DECODER_ID_MAX)
    {
        if((glDPRxInfo[dprx_id].ucState == DPRx_STATE_NORMAL) && (glDPRxInfo[dprx_id].uwDPRxStableTimeout == 0x0))
        {
            bStableFlag = glDPRxInfo[dprx_id].bRxDecodeStable;
        }
    }

    return bStableFlag;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_CheckIgnoreDPMS()
//  [Description]
//					mdrv_DPRx_CheckIgnoreDPMS
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_CheckIgnoreDPMS(BYTE ucInputPort)
{
    BOOL bIgnoreFlag = FALSE;

    ucInputPort = 0;

    return bIgnoreFlag;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DP_DP_GetDPState()
//  [Description]
//                  mdrv_DP_DP_GetDPState
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetDPStable(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    BOOL bNormalState = FALSE;

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    if((glDPRxInfo[dprx_id].ucState == DPRx_STATE_NORMAL) && (glDPRxInfo[dprx_id].uwDPRxStableTimeout == 0x0))
    {
        bNormalState = TRUE;
    }

    return bNormalState;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetVideoStreamCRC(), for SST stream only !!!
//  [Description]
//
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetVideoStreamCRC(BYTE ucInputPort, BYTE* pCRC_Data)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    BYTE i = 0x0;

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    mhal_DPRx_MCUWriteNonPMDPCD(dprx_id, dprx_aux_id, DPCD_00270, 0x1);
    ForceDelay1ms(150);  //wait HW calculate 1~2 frames

    for(i = 0x0; i < 6; i++)
    {
        pCRC_Data[i] = mhal_DPRx_MCUReadNonPMDPCD(dprx_id, dprx_aux_id, DPCD_00240 + i);
    }

    /*
    printf("CRC_R_CR0 = 0x%x\r\n", pCRC_Data[0]);
    printf("CRC_R_CR1 = 0x%x\r\n", pCRC_Data[1]);
    printf("CRC_G_Y0 = 0x%x\r\n", pCRC_Data[2]);
    printf("CRC_G_Y1 = 0x%x\r\n", pCRC_Data[3]);
    printf("CRC_B_CB0 = 0x%x\r\n", pCRC_Data[4]);
    printf("CRC_B_CB1 = 0x%x\r\n", pCRC_Data[5]);
    */

    mhal_DPRx_MCUWriteNonPMDPCD(dprx_id, dprx_aux_id, DPCD_00270, 0x0);

    return TRUE;
}

void ________AUDIO________(void);
//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_SetAudioMaskCount()
//  [Description]
//					_mdrv_DPRx_SetAudioMaskCount
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_SetAudioMaskCount(DPRx_ID dprx_id)
{
    DWORD ulAudioHblank = 0x0;
    DWORD ulAudioMaskCount = 0x0;
    DPRx_AudioStream DPRX_AUDIO_SELECT = mhal_DPRx_GetAudioStream(dprx_id);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX) || (DPRX_AUDIO_SELECT == DPRx_AUD_STREAM_MAX))
    {
        return;
    }

    if(glucAudioPath[dprx_decoder_id] == TRUE)
    {
        if(glDPRxDecoderInfo[dprx_decoder_id].uwDPPixel > 0)
        {
            ulAudioHblank = ((((DWORD)1000*(glDPRxDecoderInfo[dprx_decoder_id].uwDPHWidth)) / glDPRxDecoderInfo[dprx_decoder_id].uwDPPixel) * 85) / 100;

            ulAudioMaskCount = (ulAudioHblank / (1000000 / XTAL_CLOCK_KHZ)) - DPRX_AUDIO_MASK_OFFSET;

            if(ulAudioMaskCount > 0xF0)
            {
                ulAudioMaskCount = 0xF0;
            }
        }
        else
        {
            ulAudioMaskCount = 0x20;
        }

        mhal_DPRx_SetAudioMaskCount(dprx_id, (BYTE)ulAudioMaskCount);

        msWriteByteMask(REG_DPRX_ALOCK0_00_L + DP_REG_OFFSET100(DPRX_AUDIO_SELECT), 0, BIT0);
        mhal_DPRx_DELAY_NOP(15);
        msWriteByteMask(REG_DPRX_ALOCK0_00_L + DP_REG_OFFSET100(DPRX_AUDIO_SELECT), BIT0, BIT0);

        glucAudioPath[dprx_decoder_id] = FALSE;
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_AudioHandler()
//  [Description]
//					_mdrv_DPRx_AudioHandler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_AudioHandler(DPRx_ID dprx_id)
{
    DPRx_AudioStream DPRX_AUDIO_SELECT = mhal_DPRx_GetAudioStream(dprx_id);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    Bool bIVSChangeFlag = FALSE;

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX) || (DPRX_AUDIO_SELECT == DPRx_AUD_STREAM_MAX))
    {
        return;
    }

    if(glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable)
    {
        _mdrv_DPRx_SetAudioMaskCount(dprx_id);

        if(mhal_DPRx_CheckAudioAbsent(dprx_decoder_id, DPRX_AUDIO_CheckAudioAbsent_CNT)) // No audio
        {
            mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, TRUE);
            mhal_DPRx_AudioAlockReset(DPRX_AUDIO_SELECT);

            glDPRxDecoderInfo[dprx_decoder_id].bAudioMute = TRUE;
            glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange = TRUE;
            glDPRxDecoderInfo[dprx_decoder_id].DPAudioFreq = 0;
            glDPRxDecoderInfo[dprx_decoder_id].ucAudioCTS_UCD400 = 0;
            glDPRxInfo[dprx_id].bAudioRecoverCnt = DPRX_AUDIO_RECOVER_CNT;
        }
        else
        {
            if(mhal_DPRx_CheckLossAlignment(dprx_id)) // Check alignment
            {
                if(mhal_DPRx_CalAudioFreqByIVS(dprx_id) != glDPRxDecoderInfo[dprx_decoder_id].ucAudioFreqByIVS)// compare IVS change
                {
                    if(mhal_DPRx_CalAudioFreqByIVS(dprx_id) != DPRx_AUD_FREQ_ERROR)
                    {
                        mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, TRUE);
                        glDPRxDecoderInfo[dprx_decoder_id].ucAudioFreqByIVS = mhal_DPRx_CalAudioFreqByIVS(dprx_id);

                        mhal_DPRx_AudioFPLLReset(DPRX_AUDIO_SELECT);
                        bIVSChangeFlag = TRUE;
                    }
                }

                if((mhal_DPRx_CheckAUPLLBigChange(dprx_decoder_id)) || (glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange) || bIVSChangeFlag)
                {
                    glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange = TRUE;
                    msWriteByteMask(REG_DPRX_ALOCK0_00_L + DP_REG_OFFSET100(DPRX_AUDIO_SELECT), BIT0, BIT0);
                    glDPRxDecoderInfo[dprx_decoder_id].DPAudioFreq = mhal_DPRx_CalAudioFreq(dprx_id, dprx_decoder_id);
                }

                if(glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange)
                {
                    glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange = FALSE;
                    glDPRxInfo[dprx_id].bAudioRecoverCnt = DPRX_AUDIO_RECOVER_CNT;
                    mhal_DPRx_ClrAudioBigChgFlag(dprx_decoder_id);
                }

                // Check alock
                if(mhal_DPRx_AudioCheckStable(dprx_id, DPRX_AUDIO_STABLE_CNT) && (glDPRxDecoderInfo[dprx_decoder_id].bAudioMute || mhal_DPRx_GetAudioGlobeMute(dprx_id)))
                {
                    DP_DRV_DPRINTF("** Alock DP audio Unmute %d\r\n", dprx_id);

                    mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, FALSE);

                    glDPRxDecoderInfo[dprx_decoder_id].bAudioMute = FALSE;
                    mhal_DPRx_CalAudioFreq(dprx_id, dprx_decoder_id);
                }

                if(glDPRxInfo[dprx_id].bAudioRecoverCnt == 0)
                {
                    mhal_DPRx_AudioCheckFIFOStatus(dprx_id);
                    glDPRxInfo[dprx_id].bAudioRecoverCnt = DPRX_AUDIO_RECOVER_CNT;
                }
            }
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetAudioFreq()
//  [Description]
//					mdrv_DPRx_GetAudioFreq
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
WORD mdrv_DPRx_GetAudioFreq(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return mhal_DPRx_CalAudioFreq(dprx_id, dprx_decoder_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_CheckAudioStatus()
//  [Description]
//					mdrv_DPRx_CheckAudioStatus
//  [Arguments]:
//
//  [Return]:   	1: Has audio
//                  0: No audio
//
//**************************************************************************
BOOL mdrv_DPRx_CheckAudioStatus(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    BOOL bAudioFlag = FALSE;

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    if(glDPRxDecoderInfo[dprx_decoder_id].uwInputPacketStatus & (BIT0|BIT1))
    {
        bAudioFlag = TRUE;
    }

    return bAudioFlag;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_ConfigAudioPort()
//  [Description]
//					mdrv_DPRx_ConfigAudioPort
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_ConfigAudioPort(BYTE ucInputPort, BOOL bEnable)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    BYTE rx_decoder_id = 0;
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
    DPRx_AudioStream dprx_audio_select = 0;

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return;
    }

    //if(GET_DP_FUNCTION_ENABLE_PORT(dprx_id))
    {
        for(rx_decoder_id = DPRx_DECODER_ID_0; rx_decoder_id < DPRx_DECODER_ID_MAX; rx_decoder_id++)
        {
            glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable = FALSE;
        }

        mhal_DPRx_AudioGlobalMute(dprx_audio_select, TRUE);

        if(bEnable)
        {
            glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable = bEnable;
            glDPRxDecoderInfo[dprx_decoder_id].bAudioMute = TRUE;
            glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange = TRUE;
            glDPRxDecoderInfo[dprx_decoder_id].DPAudioFreq = 0;
            glDPRxDecoderInfo[dprx_decoder_id].ucAudioCTS_UCD400 = 0;
            glucAudioPath[dprx_decoder_id] = TRUE;
            glDPRxInfo[dprx_id].bAudioRecoverCnt = DPRX_AUDIO_RECOVER_CNT;
        }

        //MST9U5 Only has one audio engine
        mhal_DPRx_SetAudioPath(dprx_id, dprx_decoder_id, DPRx_AUD_STREAM_0, bEnable);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_AudioChannelCnt()
//  [Description]
//                  mdrv_DPRx_AudioChannelCnt
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_AudioChannelCnt(BYTE ucInputPort, BYTE *pPacketData)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return 0x0;
    }

    return mhal_DPRx_AudioChannelCnt(dprx_decoder_id, pPacketData);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_CheckAudioAbsent()
//  [Description]
//					mdrv_DPRx_CheckAudioAbsent
//  [Arguments]:
//
//  [Return]:  		1: No audio
//                 	0: Has Audio
//
//**************************************************************************
BOOL mdrv_DPRx_CheckAudioAbsent(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return FALSE;
    }

    return mhal_DPRx_CheckAudioAbsent(dprx_decoder_id, DPRX_AUDIO_CheckAudioAbsent_CNT);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetAudioGlobeMute()
//  [Description]
//					mdrv_DPRx_GetAudioGlobeMute
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetAudioGlobeMute(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    return mhal_DPRx_GetAudioGlobeMute(dprx_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetNoAudioFlag()
//  [Description]
//					mdrv_DPRx_GetNoAudioFlag
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetNoAudioFlag(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return FALSE;
    }

    return mhal_DPRx_GetNoAudioFlag(dprx_decoder_id);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_IsAudioFmtPCM()
//  [Description]
//					mdrv_DPRx_IsAudioFmtPCM
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
DP_AUDIO_FORMAT mdrv_DPRx_IsAudioFmtPCM(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_DECODER_ID dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_decoder_id == DPRx_DECODER_ID_MAX))
    {
        return DP_AUDIO_FMT_UNKNOWN;
    }

    return mhal_DPRx_IsAudioFmtPCM(dprx_decoder_id);
}

void ________AUX________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetOffLine()
//  [Description]
//					mdrv_DPRx_SetOffLine
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetOffLine(BYTE ucInputPort, BOOL bEnable)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, bEnable);

    return;
}

//**************************************************************************
//  [Function Name]:
//					mdrv_DPRx_CheckAuxPhyIdle()
//  [Description]
//					mdrv_DPRx_CheckAuxPhyIdle
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_CheckAuxPhyIdle(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    return mhal_DPRx_CheckAuxPhyIdle(dprx_aux_id);
}

//**************************************************************************
//  [Function Name]:
//					mdrv_DPRx_CheckAuxIdle()
//  [Description]
//					mdrv_DPRx_CheckAuxIdle
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_CheckAuxIdle(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    return mhal_DPRx_CheckAuxIdle(dprx_aux_id);
}

//**************************************************************************
//  [Function Name]:
//					mdrv_DPRx_SetAuxPMClock()
//  [Description]
//					mdrv_DPRx_SetAuxPMClock
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetAuxPMClock(BOOL bIsXtalClk)
{
    DPRx_ID dprx_id = DPRx_ID_0;
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    WORD ubRetryCnt = 0;

    while (dprx_id != DPRx_ID_MAX)
    {
        for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
        {
            dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

            if(GET_DPRx_FUNCTION_ENABLE_PORT(dprx_id))
            {
                if((mhal_DPRx_CheckAuxIdle(dprx_aux_id) == FALSE) || (mhal_DPRx_CheckAuxPhyIdle(dprx_aux_id) == FALSE))
                {
                    break;
                }
            }
        }

        ubRetryCnt ++;

        if(ubRetryCnt == 2000)
        {
            break;
        }
    }

    // Check if Aux is idle for all Rx ports
    if(dprx_id == DPRx_ID_MAX)
    {
        if(bIsXtalClk == TRUE)
        {
            if(mhal_DPRx_GetAuxPMClock() == 0x0)
            {
                mhal_DPRx_SetAuxPMClock(TRUE);
            }
        }
        else
        {
            if(mhal_DPRx_GetAuxPMClock() == BIT2)
            {
                mhal_DPRx_SetAuxPMClock(FALSE);
            }
        }
    }
	else
	{
		printf("SetAuxPMClock Fail!");
	}

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_ClearFreeSyncFlag()
//  [Description]
//					mdrv_DPRx_ClearFreeSyncFlag
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_ClearFreeSyncFlag(BYTE ucInputPort)
{
    BYTE ubTempValue;
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
	DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

	if(dprx_aux_id == DPRx_AUX_ID_MAX)
	{
		return;
	}

    ubTempValue = mhal_DPRx_MCUReadNonPMDPCD(dprx_id, dprx_aux_id, DPCD_00107);

	if((ubTempValue & BIT7) != 0x0)
	{
    	mhal_DPRx_MCUWriteNonPMDPCD(dprx_id, dprx_aux_id, DPCD_00107, ubTempValue & (~BIT7));
	}

	ubTempValue = mhal_DPRx_MCUReadPMDPCD(dprx_aux_id, DPCD_00107);

	if((ubTempValue & BIT7) != 0x0)
	{
		mhal_DPRx_MCUWritePMDPCD(dprx_aux_id, DPCD_00107, ubTempValue & (~BIT7));
	}

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetVESA_AdaptiveSyncSDPEanble()
//  [Description]
//					mdrv_DPRx_SetVESA_AdaptiveSyncSDPEanble
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetVESA_AdaptiveSyncSDPEanble(BYTE ucInputPort, BOOL bEnable)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
	DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    #if(DPRX_PROGRAM_DPCD4_ENABLE == 0x1) && (DP_VESA_ADAPTIVE_SYNC_SDP_SUPPORT == 0x1)
    mhal_DPRx_EnableDRRFunction(dprx_aux_id, bEnable);
    mdrv_DPRx_SetSDPSplitEnable(ucInputPort, bEnable);
	#endif

    #if(DP_VESA_ADAPTIVE_SYNC_SDP_SUPPORT == 0x0)
    dprx_id = DPRx_ID_0;
    bEnable = FALSE;
    dprx_aux_id = DPRx_AUX_ID_0;
    #endif

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetSDPSplitEnable()
//  [Description]
//					mdrv_DPRx_SetSDPSplitEnable
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetSDPSplitEnable(BYTE ucInputPort, BOOL bEnable)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
	DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

	mhal_DPRx_SetProgramDPCD(bEnable, dprx_aux_id, DPRx_PROGRAM_DPCD_4, DPRX_PROGRAM_DPCD4_ADDERSS, TRUE);
	mhal_DPRx_SetProgramDPCDInterrupt(dprx_aux_id, DPRx_PROGRAM_DPCD_4, bEnable);

    glDPRxInfo[dprx_id].bSDPSplitEnable = bEnable;

	return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_Load_EDID()
//  [Description]
//					mdrv_DPRx_Load_EDID
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_Load_EDID(BYTE ucInputPort, BYTE *EdidData)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
	DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

	mhal_DPRx_Load_EDID(dprx_id, dprx_aux_id, EdidData);

	return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetMCCSReplyEnable()
//  [Description]
//                  mdrv_DPRx_SetMCCSReplyEnable
//  [Arguments]:
//
//  [Return]:
//                  TRUE: Reply MCCS normally
//
//**************************************************************************
BOOL mdrv_DPRx_SetMCCSReplyEnable(BYTE ucInputPort, BOOL bEnable)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
	DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    return mhal_DPRx_SetMCCSReplyEnable(dprx_aux_id, bEnable);
}

void ________TRAINING________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetFastTrainingTime()
//  [Description]
//					mdrv_DPRx_SetFastTrainingTime
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetFastTrainingTime(BYTE ucInputPort, BYTE ubTime)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    mhal_DPRx_SetFastTrainingTime(dprx_id, ubTime);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_MaxLinkRate_Set()
//  [Description]
//					mdrv_DPRx_MaxLinkRate_Set
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BYTE mdrv_DPRx_MaxLinkRate_Set(BYTE ucInputPort, BYTE ucMaxLinkRate)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

	if(dprx_id == DPRx_ID_MAX)
	{
		return FALSE;
	}

    if(glDPRxInfo[dprx_id].DPVersion >= DP_VERSION_12_14)
    {
    	switch(ucMaxLinkRate)
        {
            case DP_LINKRATE_RBR:
            case DP_LINKRATE_HBR:
            case DP_LINKRATE_HBR2: //MT9700 only support HBR2
                mhal_DPRx_SetDPCDValueByRIU(dprx_id, dprx_aux_id, DPCD_00001, ucMaxLinkRate);
                mhal_DPRx_SetDPCDValueByRIU(dprx_id, dprx_aux_id, DPCD_02201, ucMaxLinkRate);
                break;
            default:
                printf("[DP] Error Link Rate settings 01 ! \r\n");
                break;
        };
    }
    else if(glDPRxInfo[dprx_id].DPVersion == DP_VERSION_12)
    {
        switch(ucMaxLinkRate)
        {
            case DP_LINKRATE_RBR:
            case DP_LINKRATE_HBR:
            case DP_LINKRATE_HBR2:
                mhal_DPRx_SetDPCDValueByRIU(dprx_id, dprx_aux_id, DPCD_00001, ucMaxLinkRate);
                break;
            default:
                printf("[DP] Error Link Rate settings 02 ! \r\n");
                break;
        };
    }
    else if(glDPRxInfo[dprx_id].DPVersion == DP_VERSION_11)
    {
        switch(ucMaxLinkRate)
        {
            case DP_LINKRATE_RBR:
            case DP_LINKRATE_HBR:
                mhal_DPRx_SetDPCDValueByRIU(dprx_id, dprx_aux_id, DPCD_00001, ucMaxLinkRate);
                break;
            default:
                printf("[DP] Error Link Rate settings 03 ! \r\n");
                break;
        };
    }

    return TRUE;
}

void ________HPD_CONTROL________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_HPDControl()
//  [Description]
//					mdrv_DPRx_HPDControl
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_HPDControl(BYTE ucInputPort, BOOL bSetHPD)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_ID OnLine_dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(SrcInputType);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX) || (dprx_phy_id == DPRx_PHY_ID_MAX))
    {
        return FALSE;
    }

    mhal_DPRx_HPDControl(dprx_aux_id, bSetHPD);
    mhal_DPRx_PHYCDRDetectEnable(dprx_phy_id, bSetHPD);

    if(bSetHPD == 0x0)
    {
        glDPRxInfo[dprx_id].bDPLoseCDRLockIRQ = FALSE;
        glDPRxInfo[dprx_id].uwCDRHPDCnt = 0;
        mhal_DPRx_CableDisconectResetDPCD(dprx_id, dprx_aux_id);
        if(dprx_id == OnLine_dprx_id)
        {
            // For special source HPD low but mainlink data still transmit
            mhal_DPRx_OverWriteDPCD202_203(dprx_id, TRUE, 0x0000);
            glDPRxInfo[dprx_id].bOverWriteLockStatus = TRUE;
        }

        if((dprx_id == DPRx_ID_3) && (dprx_id < DPRx_ID_MAX))
        {
            mhal_DPRx_InternalOverWriteHPD(dprx_id, FALSE);	// For TypeC port fast training set internal hpd high
        }
    }
    else if((bSetHPD == 0x1) && (glDPRxInfo[dprx_id].bDPHpdState == 0x0))
    {
        glDPRxInfo[dprx_id].bDPLoseCDRLockIRQ = FALSE;
        glDPRxInfo[dprx_id].uwCDRHPDCnt = 0;

        mhal_DPRx_OverWriteDPCD202_203(dprx_id, FALSE, 0x0000);
        glDPRxInfo[dprx_id].bOverWriteLockStatus = FALSE;

        if((dprx_id == DPRx_ID_3) && (dprx_id < DPRx_ID_MAX))
        {
            mhal_DPRx_InternalOverWriteHPD(dprx_id, TRUE); // For TypeC port fast training set internal hpd high
        }
    }

    glDPRxInfo[dprx_id].bDPHpdState = bSetHPD;

    return TRUE;
}

void ________HANDLER________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_Handler()
//  [Description]
//					mdrv_DPRx_Handler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_Handler(void)
{
    DPRx_ID dprx_id = DPRx_ID_MAX;
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    DPRx_PHY_ID dprx_phy_id = DPRx_PHY_ID_MAX;
    DPRx_ID OnLine_dprx_id;

    OnLine_dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(SrcInputType);

    for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
    {
        if(GET_DPRx_FUNCTION_ENABLE_PORT(dprx_id))
        {
            _mdrv_DPRx_CheckCableDetection(dprx_id);

            if(dprx_id != OnLine_dprx_id)
            {
                continue;
            }

            if(_mdrv_DPRx_CTSCheck(dprx_id))  // For PHY CTS
            {
                continue;
            }

            dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
            dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

            #if (DP_RX_FT_TIMER_A_WAIT_SQ_SIGNAL == 0x0)
            if((mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort) == TRUE) &&
               (mhal_DPRx_CheckHWNormalTrainingDone(dprx_id) == TRUE))
            {
                glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;

                mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);
            }
            else if(_mdrv_DPRx_CheckSquelch(dprx_id))
            {
                if(glDPRxInfo[dprx_id].ubSQStableTimer == 0x0)
                {
                    mhal_DPRx_HWFastTrainingEnable(dprx_id, TRUE);
                }
            }
            else
            {
                glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;

                mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);
            }
            #endif

            if(_mdrv_DPRx_StateHandler(dprx_id)) // DPRx_STATE_NORMAL
            {
                _mdrv_DPRx_StablePolling(dprx_id);
                _mdrv_DPRx_AudioHandler(dprx_id);
            }

            #if (DPRX_HDCP2_ENABLE == 0x1)
            _mdrv_DPRx_HDCP2Handler(dprx_id);
            #endif

            #if 1//(DPRX_HDCP14_Repeater_ENABLE == 0x1)
            _mdrv_DPRx_HDCP14Handler(dprx_id);
            #endif
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_RX_IRQ_Handler()
//  [Description]
//					mdrv_DPRx_RX_IRQ_Handler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_RX_IRQ_Handler(void)
{
    DPRx_ID dprx_id = DPRx_ID_MAX;
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    DPRx_PHY_ID dprx_phy_id = DPRx_PHY_ID_MAX;
    WORD usRegOffsetAuxByID = 0x0;
    WORD usRegOffsetPHY0ByID = 0x0;
    WORD usRegOffsetDPCD1ByID = 0x0;
    WORD usRegOffsetReceiverByID = 0x0;
    WORD usRegOffsetTransCTRLByID = 0x0;
    WORD usRegOffsetDPCD0ByID = 0x0;
    BYTE ucACDR_lane = 0x0;

    dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(SrcInputType);
    dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

    if(dprx_id == DPRx_ID_MAX)
    {
        dprx_id = DPRx_ID_0;
        dprx_phy_id = DPRx_PHY_ID_0;
    }

    usRegOffsetPHY0ByID = DP_REG_OFFSET400(dprx_phy_id);
    usRegOffsetDPCD1ByID = DP_REG_OFFSET000(dprx_id);
    usRegOffsetReceiverByID = DP_REG_OFFSET000(dprx_id);
    usRegOffsetTransCTRLByID = DP_REG_OFFSET000(dprx_id);
    usRegOffsetDPCD0ByID = DP_REG_OFFSET000(dprx_id);
    usRegOffsetAuxByID = DP_REG_OFFSET300(dprx_aux_id);

#if (DPRx_HDCP2_ISR_MODE == 0x1) && (DPRX_HDCP2_ENABLE == 0x1)
    mdrv_DPRx_HDCP2FetchMsg(_mdrv_DPRx_MSCHIP_DPRxID2PortNumber(dprx_id));
#endif

    if(mhal_DPRx_GetAKSVReceivedFlag(dprx_id))
    {
        glDPRxInfo[dprx_id].bHDCP14R0beRead = FALSE;
        glDPRxInfo[dprx_id].bForceIntegrityFail = FALSE;

        if(mhal_DPRx_CheckHWFastTrainingLock(dprx_id) == TRUE)
        {
            glDPRxInfo[dprx_id].bHdcpStartAuth = TRUE;
        }

        mhal_DPRx_ForceHDCP13IntegrityFail(dprx_id, FALSE);
        mhal_DPRx_ForceHDCP22IntegrityFail(dprx_id, FALSE);
    }

    //==============================================================================
    //==============================================================================
    //==============================================================================
    //================================   Auto EQ   =================================
    //==============================================================================
    //==============================================================================

    //==============================================================================
    if(msReadByte(REG_DPRX_PHY2_44_H + usRegOffsetPHY0ByID) & BIT7) // Auto EQ Done Lane 0
    {
        msWriteByte(REG_DPRX_PHY2_47_H + usRegOffsetPHY0ByID, BIT7);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_PHY2_47_H + usRegOffsetPHY0ByID, 0);
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_PHY2_48_H + usRegOffsetPHY0ByID) & BIT7) // Auto EQ Done Lane 1
    {
        msWriteByte(REG_DPRX_PHY2_4B_H + usRegOffsetPHY0ByID, BIT7);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_PHY2_4B_H + usRegOffsetPHY0ByID, 0);
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_PHY2_4C_H + usRegOffsetPHY0ByID) & BIT7) // Auto EQ Done Lane 2
    {
        msWriteByte(REG_DPRX_PHY2_4F_H + usRegOffsetPHY0ByID, BIT7);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_PHY2_4F_H + usRegOffsetPHY0ByID, 0);
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_PHY2_50_H + usRegOffsetPHY0ByID) & BIT7) // Auto EQ Done Lane 3
    {
        //// For one lane at agc state , RTL issue . odinson2 also happen
        mhal_DPRx_Check_AGC_Reset(dprx_phy_id);
        msWriteByte(REG_DPRX_PHY2_53_H + usRegOffsetPHY0ByID, BIT7);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_PHY2_53_H + usRegOffsetPHY0ByID, 0);
    }

    //==============================================================================
    //==============================================================================
    //==============================================================================
    //=============================   Training ISR	 ===============================
    //==============================================================================
    //==============================================================================
    //==============================================================================

    //==============================================================================
    if(msReadByte(REG_DPRX_DPCD1_39_L + usRegOffsetDPCD1ByID) & BIT5) // TP1
    {
        glDPRxInfo[dprx_id].bDPTrainingP1T = TRUE;
        glDPRxInfo[dprx_id].bDPTrainingFlag = TRUE;
        glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;

        if(mhal_DPRx_GetDPCDLinkRate(dprx_aux_id) == DP_LINKRATE_HBR)
        {
            msWriteByte(REG_DPRX_PHY3_50_L + usRegOffsetPHY0ByID, 0x03);

            if(mhal_DPRx_GetDPLaneCnt(dprx_aux_id) != 0x4)
            {
                msWriteByteMask(REG_DPRX_PHY0_28_L + usRegOffsetPHY0ByID, 0x38, BIT6|BIT5|BIT4|BIT3|BIT2|BIT1|BIT0); // AABA under threshold
            }
        }

        msWriteByte(REG_DPRX_PHY0_29_L + usRegOffsetPHY0ByID, 0x08); // Time out for symbol detect time (us) 20180702

        #if (DP_RX_FT_TIMER_A_WAIT_SQ_SIGNAL == 0x0)
        mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);
        #endif
        //// For one lane at agc state , RTL issue . odinson2 also happen
        mhal_DPRx_Check_AGC_Reset(dprx_phy_id);
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, BIT5);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, 0);

        msWriteByteMask(REG_DPRX_TRANS_CTRL_10_L + usRegOffsetTransCTRLByID, 0x3, BIT0|BIT1|BIT2); // Request counter

        //JL suggest turn off this bit when timer_a = 0 to avoid CR lose irq when unplug cable, only turn on this bit during normal training
        #if (DP_RX_FT_TIMER_A_WAIT_SQ_SIGNAL == 0x0)
        msWriteByteMask(REG_DPRX_PHY0_62_L + usRegOffsetPHY0ByID, BIT7, BIT7);
        #endif

        mhal_DPRx_SetCDRLossLockInterrupt(dprx_id, TRUE);
        mhal_DPRx_SetInterlaneSkewLoseInterrupt(dprx_id, TRUE);
        mhal_DPRx_SetInterlaneSkewDoneInterrupt(dprx_id, TRUE);
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_DPCD1_39_L + usRegOffsetDPCD1ByID) & BIT4) // TP2
    {
        glDPRxInfo[dprx_id].bDPTrainingP234T = TRUE;
        glDPRxInfo[dprx_id].bDPTrainingFlag = TRUE;
        glDPRxInfo[dprx_id].uwSinkStatusCnt = 100; // For link CTS1.4, item 5.2.2.8 ESI Field Mapping
        glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;

        if(mhal_DPRx_GetDPCDLinkRate(dprx_aux_id) == DP_LINKRATE_HBR)
        {
            msWriteByte(REG_DPRX_PHY3_50_L + usRegOffsetPHY0ByID, 0x03);

            if(mhal_DPRx_GetDPLaneCnt(dprx_aux_id) != 0x4)
            {
                msWriteByteMask(REG_DPRX_PHY0_28_L + usRegOffsetPHY0ByID, 0x38, BIT6|BIT5|BIT4|BIT3|BIT2|BIT1|BIT0); // AABA under threshold
            }
        }

        //mhal_DPRx_SetAuxDelayReply(dprx_aux_id, DP_AUX_DELAY_TRAINING); // 280us delay reply

        #if (DP_RX_FT_TIMER_A_WAIT_SQ_SIGNAL == 0x0)
        mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);
        #endif
        //// For one lane at agc state , RTL issue . odinson2 also happen
        mhal_DPRx_Check_AGC_Reset(dprx_phy_id);
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, BIT4);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, 0);

        msWriteByteMask(REG_DPRX_TRANS_CTRL_10_L + usRegOffsetTransCTRLByID, 0x2, BIT0|BIT1|BIT2); // Request counter

        // For link CTS1.4, item 5.2.2.8 ESI Field Mapping, overwrite DPCD 205 and 200F
        msWriteByteMask(REG_DPRX_DPCD1_4D_H + usRegOffsetDPCD1ByID, BIT0|BIT1|BIT2, BIT0|BIT1|BIT2);
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_DPCD1_39_L + usRegOffsetDPCD1ByID) & BIT3) // TP3
    {
        glDPRxInfo[dprx_id].bDPTrainingP234T = TRUE;
        glDPRxInfo[dprx_id].bDPTrainingFlag = TRUE;
        glDPRxInfo[dprx_id].uwSinkStatusCnt = 100; // For link CTS1.4, item 5.2.2.8 ESI Field Mapping
        glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;

        if(mhal_DPRx_GetDPCDLinkRate(dprx_aux_id) == DP_LINKRATE_HBR)
        {
            msWriteByte(REG_DPRX_PHY3_50_L + usRegOffsetPHY0ByID, 0x03);

            if(mhal_DPRx_GetDPLaneCnt(dprx_aux_id) != 0x4)
            {
                msWriteByteMask(REG_DPRX_PHY0_28_L + usRegOffsetPHY0ByID, 0x38, BIT6|BIT5|BIT4|BIT3|BIT2|BIT1|BIT0); // AABA under threshold
            }
        }

        //mhal_DPRx_SetAuxDelayReply(dprx_aux_id, DP_AUX_DELAY_TRAINING); // 280us delay reply

        #if (DP_RX_FT_TIMER_A_WAIT_SQ_SIGNAL == 0x0)
        mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);
        #endif
        //// For one lane at agc state , RTL issue . odinson2 also happen
        mhal_DPRx_Check_AGC_Reset(dprx_phy_id);
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, BIT3);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, 0);

        msWriteByteMask(REG_DPRX_TRANS_CTRL_10_L + usRegOffsetTransCTRLByID, 0x2, BIT0|BIT1|BIT2); // Request counter

        // For link CTS1.4, item 5.2.2.8 ESI Field Mapping, overwrite DPCD 205 and 200F
        msWriteByteMask(REG_DPRX_DPCD1_4D_H + usRegOffsetDPCD1ByID, BIT0|BIT1|BIT2, BIT0|BIT1|BIT2);
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_DPCD1_39_L + usRegOffsetDPCD1ByID) & BIT2) // TP4
    {
        glDPRxInfo[dprx_id].bDPTrainingP234T = TRUE;
        glDPRxInfo[dprx_id].bDPTrainingFlag = TRUE;
        glDPRxInfo[dprx_id].uwSinkStatusCnt = 100; // For link CTS1.4, item 5.2.2.8 ESI Field Mapping
        glDPRxInfo[dprx_id].ubSQStableTimer = DPRX_FAST_TRAINING_SQ_DEBOUNCE_TIME;

        if(mhal_DPRx_GetDPCDLinkRate(dprx_aux_id) == DP_LINKRATE_HBR)
        {
            msWriteByte(REG_DPRX_PHY3_50_L + usRegOffsetPHY0ByID, 0x03);

            if(mhal_DPRx_GetDPLaneCnt(dprx_aux_id) != 0x4)
            {
                msWriteByteMask(REG_DPRX_PHY0_28_L + usRegOffsetPHY0ByID, 0x38, BIT6|BIT5|BIT4|BIT3|BIT2|BIT1|BIT0); // AABA under threshold
            }
        }

        //mhal_DPRx_SetAuxDelayReply(dprx_aux_id, DP_AUX_DELAY_TRAINING); // 280us delay reply

        #if (DP_RX_FT_TIMER_A_WAIT_SQ_SIGNAL == 0x0)
        mhal_DPRx_HWFastTrainingEnable(dprx_id, FALSE);
        #endif
        //// For one lane at agc state , RTL issue . odinson2 also happen
        mhal_DPRx_Check_AGC_Reset(dprx_phy_id);
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, BIT2);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, 0);

        msWriteByteMask(REG_DPRX_TRANS_CTRL_10_L + usRegOffsetTransCTRLByID, 0x2, BIT0|BIT1|BIT2); // Request counter

        // For link CTS1.4, item 5.2.2.8 ESI Field Mapping, overwrite DPCD 205 and 200F
        msWriteByteMask(REG_DPRX_DPCD1_4D_H + usRegOffsetDPCD1ByID, BIT0|BIT1|BIT2, BIT0|BIT1|BIT2);
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_DPCD1_39_L + usRegOffsetDPCD1ByID) & BIT6) // DPCD 270h
    {
        if(msReadByte(REG_DPRX_DPCD0_4B_L + usRegOffsetDPCD0ByID) & BIT7)
        {
            glDPRxInfo[dprx_id].bDPAutoTestEn = 1;

            ucACDR_lane = (msReadByte(REG_DPRX_DPCD0_4B_L + usRegOffsetDPCD0ByID) & (BIT4|BIT5)) >> 4;

            if(ucACDR_lane == 0)
            {
                mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, glTypeC_PhyLaneSwap[dprx_id]&(BIT0|BIT1));
            }
            else if(ucACDR_lane == 1)
            {
                mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, ((glTypeC_PhyLaneSwap[dprx_id]&(BIT2|BIT3)) >> 2));
            }
            else if(ucACDR_lane == 2)
            {
                mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, ((glTypeC_PhyLaneSwap[dprx_id]&(BIT4|BIT5)) >> 4));
            }
            else if(ucACDR_lane == 3)
            {
                mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, ((glTypeC_PhyLaneSwap[dprx_id]&(BIT6|BIT7)) >> 6));
            }

#if (SET_DP_C4_LANE02_PN_SWAP == 0x1)
            msWriteByteMask(REG_DPRX_PHY0_5E_H + usRegOffsetPHY0ByID, 0x50 , 0xF0);
#endif
        }
        else
        {
            glDPRxInfo[dprx_id].bDPAutoTestEn = 0;

            mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, glTypeC_PhyLaneSwap[dprx_id]&(BIT0|BIT1));
        }

#if 0//19072 C1 patch
        if(glDPRxInfo[dprx_id].bDPAutoTestEn == 1)
        {
            if(((msReadByte(REG_DPRX_DPCD0_4B_L + usRegOffsetDPCD0ByID) & (BIT4|BIT5)) >> 4) == 0x0)
            {
                mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, 0x1);
            }
            else if(((msReadByte(REG_DPRX_DPCD0_4B_L + usRegOffsetDPCD0ByID) & (BIT4|BIT5)) >> 4) == 0x1)
            {
                mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, 0x0);
            }
        }
        else
        {
            mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, 1); // Default set ACDR lane to lane 1
        }
#endif

        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, BIT6);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_DPCD1_31_L + usRegOffsetDPCD1ByID, 0);
    }

    //=========================================================================================================================
    //=========================================================================================================================
    //===================================================   Training IRQ   ====================================================
    //=========================================================================================================================
    //=========================================================================================================================
    if(msReadByte(REG_DPRX_DPCD1_39_H + usRegOffsetDPCD1ByID) & BIT6) // DPCD training
    {
        msWriteByte(REG_DPRX_DPCD1_31_H + usRegOffsetDPCD1ByID, BIT6);
		mhal_DPRx_DELAY_NOP(10);
		msWriteByte(REG_DPRX_DPCD1_31_H + usRegOffsetDPCD1ByID, 0);

        // Step1
        // Please clear status of lower layer first, then clear the upper one (Training IRQ)
        // DPCD 102 ~ 106 / 202 ~ 207 / 200C / 200D
        //=========================================================================================================================
        if(msReadByte(REG_DPRX_DPCD0_7A_L + usRegOffsetDPCD0ByID) & BIT0) // DPCD 102
        {
            msWriteByte(REG_DPRX_DPCD0_7D_L + usRegOffsetDPCD0ByID, BIT0);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DPCD0_7D_L + usRegOffsetDPCD0ByID, 0);

            if((mhal_DPRx_GetTrainingPatternFlag(dprx_id) == 0x0) &&
               (mhal_DPRx_GetDPCDLinkRate(dprx_aux_id) == DP_LINKRATE_HBR))
            {
                msWriteByte(REG_DPRX_PHY3_50_L + usRegOffsetPHY0ByID, 0x07);

                if(mhal_DPRx_GetDPLaneCnt(dprx_aux_id) != 0x4)
                {
                    msWriteByteMask(REG_DPRX_PHY0_28_L + usRegOffsetPHY0ByID, 0x20, BIT6|BIT5|BIT4|BIT3|BIT2|BIT1|BIT0); // AABA under threshold
                }
            }
        }

        // When two layer irq should mask off/on to avoid lose irq
        msWriteByteMask(REG_DPRX_DPCD1_2E_H + usRegOffsetDPCD1ByID, BIT6, BIT6);
        msWriteByteMask(REG_DPRX_DPCD0_7B_L + usRegOffsetDPCD0ByID, BIT0, BIT0);

        msWriteByteMask(REG_DPRX_DPCD1_2E_H + usRegOffsetDPCD1ByID, 0, BIT6);
        msWriteByteMask(REG_DPRX_DPCD0_7B_L + usRegOffsetDPCD0ByID, 0, BIT0);
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_DPCD1_3A_L + usRegOffsetDPCD1ByID) & BIT2) // DPCD 160h
    {
        msWriteByte(REG_DPRX_DPCD1_3D_L + usRegOffsetDPCD1ByID, BIT2);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_DPCD1_3D_L + usRegOffsetDPCD1ByID, 0);
    }

    //==============================================================================
    //==============================================================================
    //==============================================================================
    //=============================   MainLink ISR   ===============================
    //==============================================================================
    //==============================================================================
    //==============================================================================

    //==============================================================================
    if(msReadByte(REG_DPRX_RECEIVER_64_L + usRegOffsetReceiverByID) & BIT6) // FT Enter
    {
        if(glDPRxInfo[dprx_id].bDPAutoTestEn == FALSE)
        {
            //mhal_DPRx_MSCHIP_TypeC_PRBS7PNswapforFT(dprx_id, glDPRxInfo[dprx_id].ubTypeC_PinAssign);
            mhal_DPRx_Switch_Training_Setting_FT(dprx_phy_id, glDPRxInfo[dprx_id].bDPAutoTestEn);
        }

        msWriteByte(REG_DPRX_RECEIVER_62_L + usRegOffsetReceiverByID, BIT6);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_RECEIVER_62_L + usRegOffsetReceiverByID, 0);
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_RECEIVER_63_L + usRegOffsetReceiverByID) & BIT0) // cr_lose_lock_irq
    {
        glDPRxInfo[dprx_id].bDPLoseCDRLockIRQ = TRUE;
        glDPRxInfo[dprx_id].uwCDRHPDCnt = 30; // For link CTS1.4, item 5.3.2.1 IRQ HPD Pulse Due to CDR Loss Lock

        msWriteByte(REG_DPRX_RECEIVER_61_L + usRegOffsetReceiverByID, BIT0);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_RECEIVER_61_L + usRegOffsetReceiverByID, 0);

        if(mhal_DPRx_CheckSquelch(dprx_id) == TRUE)
        {
            _mdrv_DPRx_MSCHIP_ScreenMute();
        }
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_RECEIVER_63_L + usRegOffsetReceiverByID) & BIT2) // interlane_skew_done_lose_irq
    {
        glDPRxInfo[dprx_id].bDPInterlaneSkewLoseIRQ = TRUE;
        glDPRxInfo[dprx_id].bDPInterlaneSkewDoneIRQ = FALSE;
        glDPRxInfo[dprx_id].uwSkewHPDCnt = 1000;

        msWriteByte(REG_DPRX_RECEIVER_61_L + usRegOffsetReceiverByID, BIT2);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_RECEIVER_61_L + usRegOffsetReceiverByID, 0);

        if(mhal_DPRx_CheckSquelch(dprx_id) == TRUE)
        {
            _mdrv_DPRx_MSCHIP_ScreenMute();
        }
    }

    //==============================================================================
    if(msReadByte(REG_DPRX_RECEIVER_63_L + usRegOffsetReceiverByID) & BIT3) // interlane_skew_done_irq
    {
        glDPRxInfo[dprx_id].bDPInterlaneSkewDoneIRQ = TRUE;

        msWriteByte(REG_DPRX_RECEIVER_61_L + usRegOffsetReceiverByID, BIT3);
        mhal_DPRx_DELAY_NOP(10);
        msWriteByte(REG_DPRX_RECEIVER_61_L + usRegOffsetReceiverByID, 0);
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_RX2_IRQ_Handler()
//  [Description]
//					mdrv_DPRx_RX2_IRQ_Handler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_RX2_IRQ_Handler(void)
{
    DPRx_ID dprx_id = DPRx_ID_MAX;
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    DPRx_PHY_ID dprx_phy_id = DPRx_PHY_ID_MAX;
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;
    DPRx_AudioStream DPRX_AUDIO_SELECT = DPRx_AUD_STREAM_MAX;
    WORD usRegOffsetDecoderByID = 0x0;
    WORD usRegOffsetSdpByID = 0x0;

    dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(SrcInputType);
    dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

    if((INPUT_IS_DISPLAYPORT(SrcInputType) == FALSE) && (INPUT_IS_USBTYPEC(SrcInputType) == FALSE))
    {
        dprx_id = DPRx_ID_0;
        dprx_aux_id = DPRx_AUX_ID_0;
        dprx_phy_id = DPRx_PHY_ID_0;
    }

    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        DPRX_AUDIO_SELECT = mhal_DPRx_GetAudioStream(dprx_id);
        usRegOffsetDecoderByID = DP_REG_OFFSET100(dprx_decoder_id);
        usRegOffsetSdpByID = DP_REG_OFFSET100(dprx_decoder_id);

        if(msReadByte(REG_DPRX_DECODER_E0_0C_L + usRegOffsetDecoderByID) & BIT0) // Audio MN Change
        {
            if(glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable)
            {
                if(glDPRxDecoderInfo[dprx_decoder_id].ucAudioCTS_UCD400 <= 5)
                {
                    mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, TRUE);

                    msWriteByteMask(REG_DPRX_ALOCK0_00_L + DP_REG_OFFSET100(DPRX_AUDIO_SELECT), 0, BIT0);

                    glDPRxDecoderInfo[dprx_decoder_id].bAudioMute = TRUE;
                    glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange = TRUE;
                    glDPRxDecoderInfo[dprx_decoder_id].DPAudioFreq = 0;
                    glDPRxDecoderInfo[dprx_decoder_id].ucAudioCTS_UCD400++;

                    if(dprx_id < DPRx_ID_MAX)
                    {
                        glDPRxInfo[dprx_id].bAudioRecoverCnt = DPRX_AUDIO_RECOVER_CNT;
                    }
                }
            }

            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, BIT0);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, 0);
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0C_L + usRegOffsetDecoderByID) & BIT1) // Video MN Change
        {
            glDPRxDecoderInfo[dprx_decoder_id].bDPVPLLBIGChange = TRUE;

            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, BIT1);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, 0);

            _mdrv_DPRx_MSCHIP_ScreenMute();

            if(ubInfo2 < 2)
            {
                // Only for TSUMR2
                // Due to HW restriction, we need to enable MN update overwrite
                msWriteByteMask(REG_DPRX_DECODER_E0_28_L + usRegOffsetDecoderByID, BIT6, BIT6);
                mhal_DPRx_DELAY_NOP(1000);
                msWriteByteMask(REG_DPRX_DECODER_E0_28_L + usRegOffsetDecoderByID, 0, BIT6);
            }

            if(mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort) != TRUE)
            {
                msWriteByteMask(REG_DPRX_DECODER_E0_0D_L + usRegOffsetDecoderByID, BIT1, BIT1);
            }
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0C_L + usRegOffsetDecoderByID) & BIT2) // SDP ECC error
        {
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, BIT2);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, 0);
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0C_L + usRegOffsetDecoderByID) & BIT3) // Video buffer overflow
        {
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, BIT3);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, 0);
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0C_L + usRegOffsetDecoderByID) & BIT4) // MSA change
        {
            glDPRxDecoderInfo[dprx_decoder_id].bDPVPLLBIGChange = TRUE;
            glDPRxDecoderInfo[dprx_decoder_id].bDPMSAChange = TRUE; // For system used on 800x600@60Hz switch to 800x600@75Hz, system read/clear this flag

            _mdrv_DPRx_MSCHIP_ScreenMute();

            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, BIT4);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, 0);

            if(mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort) != TRUE)
            {
                msWriteByteMask(REG_DPRX_DECODER_E0_0D_L + usRegOffsetDecoderByID, BIT4, BIT4);
            }
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0C_L + usRegOffsetDecoderByID) & BIT5) // Video mute
        {
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, BIT5);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, 0);
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0C_L + usRegOffsetDecoderByID) & BIT6) // Audio mute
        {
            if(glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable)
            {
                mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, TRUE);

                glDPRxDecoderInfo[dprx_decoder_id].bAudioMute = TRUE;
                glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange = TRUE;
                glDPRxDecoderInfo[dprx_decoder_id].DPAudioFreq = 0;
                glDPRxDecoderInfo[dprx_decoder_id].ucAudioCTS_UCD400 = 0;

                if(dprx_id < DPRx_ID_MAX)
                {
                    glDPRxInfo[dprx_id].bAudioRecoverCnt = DPRX_AUDIO_RECOVER_CNT;
                }
            }

            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, BIT6);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, 0);
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0C_L + usRegOffsetDecoderByID) & BIT7) // Audio channel status change
        {
            if(glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable)
            {
                mhal_DPRx_AudioGlobalMute(DPRX_AUDIO_SELECT, TRUE);

                glDPRxDecoderInfo[dprx_decoder_id].bAudioMute = TRUE;
                glDPRxDecoderInfo[dprx_decoder_id].bDPAUPLLBIGChange = TRUE;
                glDPRxDecoderInfo[dprx_decoder_id].DPAudioFreq = 0;
                glDPRxDecoderInfo[dprx_decoder_id].ucAudioCTS_UCD400 = 0;

                if(dprx_id < DPRx_ID_MAX)
                {
                    glDPRxInfo[dprx_id].bAudioRecoverCnt = DPRX_AUDIO_RECOVER_CNT;
                }
            }

            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, BIT7);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_L + usRegOffsetDecoderByID, 0);
        }

    	if(msReadByte(REG_DPRX_SDP_E0_44_H + usRegOffsetSdpByID) & BIT3) // MISC0 change
        {
            msWriteByte(REG_DPRX_SDP_E0_47_H + usRegOffsetSdpByID, BIT3);
			mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_SDP_E0_47_H + usRegOffsetSdpByID, 0);

            _mdrv_DPRx_MSCHIP_ScreenMute();
		}

    	if(msReadByte(REG_DPRX_SDP_E0_44_H + usRegOffsetSdpByID) & BIT4) // MISC1 change
        {
            msWriteByte(REG_DPRX_SDP_E0_47_H + usRegOffsetSdpByID, BIT4);
			mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_SDP_E0_47_H + usRegOffsetSdpByID, 0);

            _mdrv_DPRx_MSCHIP_ScreenMute();
		}

        if(msReadByte(REG_DPRX_DECODER_E0_0C_H + usRegOffsetDecoderByID) & BIT5) // PPS received ISR
        {
            msWriteByteMask(REG_DPRX_DECODER_E0_0F_H + usRegOffsetDecoderByID, BIT5, BIT5);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByteMask(REG_DPRX_DECODER_E0_0F_H + usRegOffsetDecoderByID, 0, BIT5);
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0C_H + usRegOffsetDecoderByID) & BIT7) // VBID compress flag been updated
        {
            msWriteByteMask(REG_DPRX_DECODER_E0_0F_H + usRegOffsetDecoderByID, BIT7, BIT7);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByteMask(REG_DPRX_DECODER_E0_0F_H + usRegOffsetDecoderByID, 0, BIT7);
        }

        if(msReadByte(REG_DPRX_DECODER_E0_0C_H + usRegOffsetDecoderByID) & BIT2) // vheight_unstable | (~msa_ignore_en & votal_unstable) | (~decompression_en & hwidth_unstable)
        {
            msWriteByte(REG_DPRX_DECODER_E0_0F_H + usRegOffsetDecoderByID, BIT2);
            mhal_DPRx_DELAY_NOP(10);
            msWriteByte(REG_DPRX_DECODER_E0_0F_H + usRegOffsetDecoderByID, 0);

            _mdrv_DPRx_MSCHIP_ScreenMute();
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_IsrAuxHandler()
//  [Description]
//					mdrv_DPRx_IsrAuxHandler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_IsrAuxHandler(void)
{
    DPRx_ID dprx_id = DPRx_ID_MAX;
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    DPRx_PHY_ID dprx_phy_id = DPRx_PHY_ID_MAX;
    BYTE ubProgrammableHw_Index = 0x0;
    BYTE ucInputPort;
#if (DPRX_PROGRAM_DPCD1_ENABLE == 0x1)
    BYTE AuxCmd;
    BYTE AuxLen;
#endif

#if (DPRX_PROGRAM_DPCD5_ENABLE == 0x1)
    BYTE ucDataLen[1];
#endif

    for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
    {
        if(!(GET_DPRx_FUNCTION_ENABLE_PORT(dprx_id)))
        {
            continue;
        }

        dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
        dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);
        ucInputPort = _mdrv_DPRx_MSCHIP_DPRxID2PortNumber(dprx_id);
        if(mhal_DPRx_GetShortHPDIsrFlag(dprx_aux_id)) // Short HPD ISR mode
        {
            if(_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id) != DPRx_ID_MAX)
            {
                glubTypeCShortHPD[_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id)] = TRUE;
            }
        }

#if (DPRx_MCCS_SUPPORT == 0x1)
        mhal_DPRx_GetMCCSReceiveFlag(dprx_aux_id, ucInputPort);
#endif

#if (DPRX_PROGRAM_DPCD0_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_0;

        if(mhal_DPRx_GetProgramDPCD0Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD0Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD1_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_1;

        if(mhal_DPRx_GetProgramDPCD1Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD1Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index], &AuxCmd, &AuxLen);
        }
#endif

#if (DPRX_PROGRAM_DPCD2_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_2;

        if(mhal_DPRx_GetProgramDPCD2Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD2Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD3_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_3;

        if(mhal_DPRx_GetProgramDPCD3Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD3Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD4_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_4;

        if(mhal_DPRx_GetProgramDPCD4Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD4Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD5_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_5;

        if(mhal_DPRx_GetProgramDPCD5Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD5Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index], &ucDataLen[0]);
        }
#endif

#if (DPRX_PROGRAM_DPCD6_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_6;

        if(mhal_DPRx_GetProgramDPCD6Flag(dprx_aux_id))
        {
            glDPRxInfo[dprx_id].bHDCP14R0beRead = TRUE;

#if (DPRX_HDCP14_Repeater_ENABLE == 0x1)
            mhal_DPRx_HDCP14ReadR0(dprx_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);

            if(pmdrv_DPRx_HDCP14CheckVprime != NULL)
            {
                pmdrv_DPRx_HDCP14CheckVprime(_mdrv_DPRx_MSCHIP_DPRxID2PortNumber(dprx_id));
            }
#endif

            mhal_DPRx_ProgramDPCD6Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD7_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_7;

        if(mhal_DPRx_GetProgramDPCD7Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD7Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD8_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_8;

        if(mhal_DPRx_GetProgramDPCD8Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD8Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
            //mhal_DPRx_MSCHIP_TypeC_PRBS7PNswap(dprx_id, glDPRxInfo[dprx_id].ubTypeC_PinAssign);

            mhal_DPRx_OverWriteDPCD202_203(dprx_id, FALSE, 0x0000);
            glDPRxInfo[dprx_id].bOverWriteLockStatus = FALSE;

            switch(mhal_DPRx_GetDPCDLinkRate(dprx_aux_id))
            {
                case DP_LINKRATE_RBR:
                    mhal_DPRx_Switch_Training_Setting(dprx_phy_id, DP_LINKRATE_RBR, glDPRxInfo[dprx_id].bDPAutoTestEn);
                    break;

                case DP_LINKRATE_HBR:
                    mhal_DPRx_Switch_Training_Setting(dprx_phy_id, DP_LINKRATE_HBR, glDPRxInfo[dprx_id].bDPAutoTestEn);
                    break;

                case DP_LINKRATE_HBR2:
                    mhal_DPRx_Switch_Training_Setting(dprx_phy_id, DP_LINKRATE_HBR2, glDPRxInfo[dprx_id].bDPAutoTestEn);
                    break;

                default:
                    break;
            }
        }
#endif

#if (DPRX_PROGRAM_DPCD9_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_9;

        if(mhal_DPRx_GetProgramDPCD9Flag(dprx_aux_id))
        {
            glDPRxInfo[dprx_id].bHDCP14VprimebeRead = TRUE;
            mhal_DPRx_ProgramDPCD9Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD10_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_10;

        if(mhal_DPRx_GetProgramDPCD10Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD10Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_PROGRAM_DPCD11_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_PROGRAM_DPCD_11;

        if(mhal_DPRx_GetProgramDPCD11Flag(dprx_aux_id))
        {
            mhal_DPRx_ProgramDPCD11Proc(dprx_aux_id, glubRxDataQueue[dprx_id][ubProgrammableHw_Index]);
        }
#endif

#if (DPRX_XDATA_PROGRAM_DPCD0_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_XDATAPROGRAM_DPCD_0;

        if(mhal_DPRx_GetXDATAProgramDPCD0Flag(dprx_aux_id))
        {
            mhal_DPRx_XDATAProgramDPCD0Proc(dprx_aux_id);
        }
#endif

#if (DPRX_XDATA_PROGRAM_DPCD1_ENABLE == 0x1)
        ubProgrammableHw_Index = DPRx_XDATAPROGRAM_DPCD_1;

        if(mhal_DPRx_GetXDATAProgramDPCD1Flag(dprx_aux_id))
        {
            mhal_DPRx_XDATAProgramDPCD1Proc(dprx_aux_id);
        }
#endif
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_TimerHandler()
//  [Description]
//					mdrv_DPRx_TimerHandler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_TimerHandler(void)
{
    volatile DPRx_ID dprx_id = DPRx_ID_MAX;
    volatile DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;

    if(mhal_DPRx_GetAuxPMClock()==0)
    {
        return;
    }

    for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
    {
        if(GET_DPRx_FUNCTION_ENABLE_PORT(dprx_id))
        {
            if(glDPRxInfo[dprx_id].uwDPRxStableTimeout > 0)
            {
                glDPRxInfo[dprx_id].uwDPRxStableTimeout--;
            }

            if(glDPRxInfo[dprx_id].uwCDRHPDCnt > 0)
            {
                glDPRxInfo[dprx_id].uwCDRHPDCnt--;
            }

            if(glDPRxInfo[dprx_id].uwSkewHPDCnt > 0)
            {
                glDPRxInfo[dprx_id].uwSkewHPDCnt--;
            }

            if(glDPRxInfo[dprx_id].uwSinkStatusCnt > 0)
            {
                if(glDPRxInfo[dprx_id].uwSinkStatusCnt < 2)
                {
                    // For link CTS1.4, item 5.2.2.8 ESI Field Mapping, disable overwrite DPCD 205 and 200F
                    msWriteByteMask(REG_DPRX_DPCD1_4D_H + DP_REG_OFFSET000(dprx_id), 0, BIT0|BIT1|BIT2);
                }

                glDPRxInfo[dprx_id].uwSinkStatusCnt--;
            }

            if(glDPRxInfo[dprx_id].uwHDCPCnt > 0)
            {
                glDPRxInfo[dprx_id].uwHDCPCnt--;
            }

            if(glDPRxInfo[dprx_id].uwChkEncryptionTime > 0)
            {
                glDPRxInfo[dprx_id].uwChkEncryptionTime--;
            }

            if(glDPRxInfo[dprx_id].uwDPStableCount > 0)
            {
                glDPRxInfo[dprx_id].uwDPStableCount--;
            }

            if(glDPRxInfo[dprx_id].ucInterlaceCount> 0)
            {
                glDPRxInfo[dprx_id].ucInterlaceCount--;
            }

            if(glDPRxInfo[dprx_id].bAudioRecoverCnt> 0)
            {
                glDPRxInfo[dprx_id].bAudioRecoverCnt--;
            }

            if(glDPRxInfo[dprx_id].ubContDownTimer > 0)
            {
                glDPRxInfo[dprx_id].ubContDownTimer--;
            }

            if(glDPRxInfo[dprx_id].ucHDCPLongHPDTimer > 0)
            {
                glDPRxInfo[dprx_id].ucHDCPLongHPDTimer--;
            }

            if(glDPRxInfo[dprx_id].ubSQStableTimer > 0)
            {
                glDPRxInfo[dprx_id].ubSQStableTimer--;
            }

            for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
            {
                if(glDPRxInfo[dprx_id].decoderID_Info & (BIT0 << dprx_decoder_id))
                {
                    if(glDPRxDecoderInfo[dprx_decoder_id].ucPacketTimer > 0)
                    {
                        glDPRxDecoderInfo[dprx_decoder_id].ucPacketTimer--;
                    }
                }
            }
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_Timer_variable_Reset()
//  [Description]
//                  _mdrv_DPRx_Timer_variable_Reset
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_Timer_variable_Reset(void)
{
    DPRx_ID dprx_id = DPRx_ID_MAX;
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;

    for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
    {
        glDPRxInfo[dprx_id].uwDPRxStableTimeout=0;
        glDPRxInfo[dprx_id].uwCDRHPDCnt=0;
        glDPRxInfo[dprx_id].uwSkewHPDCnt=0;
        glDPRxInfo[dprx_id].uwSinkStatusCnt=0;
        glDPRxInfo[dprx_id].uwHDCPCnt=0;
        glDPRxInfo[dprx_id].uwChkEncryptionTime=0;
        glDPRxInfo[dprx_id].uwDPStableCount=0;
        glDPRxInfo[dprx_id].ucInterlaceCount=0;
        glDPRxInfo[dprx_id].bAudioRecoverCnt=0;
        glDPRxInfo[dprx_id].ubContDownTimer=0;
        glDPRxInfo[dprx_id].ucHDCPLongHPDTimer=0;
        glDPRxInfo[dprx_id].ubSQStableTimer=0;
    }

    for(dprx_decoder_id = DPRx_DECODER_ID_0; dprx_decoder_id < DPRx_DECODER_ID_MAX; dprx_decoder_id++)
    {
        glDPRxDecoderInfo[dprx_decoder_id].ucPacketTimer=0;
    }

    return;
}

void ________HDCP________(void);
#if (DPRX_HDCP14_Repeater_ENABLE == 0x1)
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_HDCP14MapDPCDWrite()
//  [Description]
//					mdrv_DPRx_HDCP14MapDPCDWrite
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_HDCP14MapDPCDWrite(BYTE ucInputPort, BYTE u8OffsetAddr, BYTE ucLength, BYTE *pucData)
{
    //DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    //BOOL bRet;

    ucInputPort = ucInputPort;
    u8OffsetAddr = u8OffsetAddr;
    ucLength = 0;
    pucData = pucData;
    /*
    switch(u8OffsetAddr)
    {
        case DPTX_HDCP1_OFFSETADDR_BStatus:
            mhal_DPRx_HDCP14WriteBinfo(dprx_id, pucData[1], pucData[0]);
        	break;

        case DPTX_HDCP1_OFFSETADDR_VPrime:
            mhal_DPRx_HDCP14WriteV(dprx_id, pucData);
        	break;

        case DPTX_HDCP1_OFFSETADDR_BCaps:
            bRet = (pucData[0] & BIT5)? TRUE : FALSE;

            if(bRet == TRUE)
            {
                glDPRxInfo[DPRx_ID_0].bHDCP14TriggerShortHPD = TRUE;
            }
        	break;

        default:
        	break;
    }
    */
    return;
}

//**************************************************************************
//  [Function Name]:
//                  mhal_DPRx_HDCP14WriteKSVFIFO()
//  [Description]
//					mdrv_DPRx_HDCP14WriteKSVFIFO
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_HDCP14WriteKSVFIFO(BYTE ucInputPort, WORD u16length, BYTE *BKSVData)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    mhal_DPRx_HDCP14WriteKSVFIFO(dprx_id, u16length, BKSVData);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_HDCP14ConfigRepeaterPair()
//  [Description]
//					mdrv_DPRx_HDCP14ConfigRepeaterPair
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_HDCP14ConfigRepeaterPair(BYTE ucInputPort, BYTE ucOutputPort, BOOL bEnable)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    static BYTE XDATA ucLASTID;

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    ucOutputPort = ucOutputPort;

    if(bEnable == TRUE)
    {
        mhal_DPRx_HDCP14RepeaterEnable(dprx_id, dprx_aux_id, bEnable);
        ucLASTID = dprx_id;
    }

    return;
}
#endif

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_ClearAKSVFlag()
//  [Description]
//					mdrv_DPRx_ClearAKSVFlag
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_ClearAKSVFlag(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    mhal_DPRx_ClearAKSVFlag(dprx_aux_id);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_CheckHDCPState()
//  [Description]
//                  check HDCP is 1.4 or 2.2 or no encryption
//  [Arguments]:
//
//  [Return]:
//                  HDCP1.4 or HDCP2.2 or no encryption
//
//**************************************************************************
DP_HDCP_STATE mdrv_DPRx_CheckHDCPState(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);

    if(dprx_id == DPRx_ID_MAX)
    {
        return DP_HDCP_NO_ENCRYPTION;
    }

    return mhal_DPRx_CheckHDCPState(dprx_id);
}

#if (DPRX_HDCP2_ENABLE == 0x1)
//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_HDCP2GetRxData()
//  [Description]
//					_mdrv_DPRx_HDCP2GetRxData
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL _mdrv_DPRx_HDCP2GetRxData(DPRx_ID dprx_id, BYTE ucMessageID, BYTE *pHDCPData)
{
    BOOL bGetData = FALSE;

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    switch(ucMessageID)
    {
        case DP_HDCP2_MSG_ID_AKE_INIT:
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_AKE_RTX, pHDCPData);
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_AKE_TXCAPS, &pHDCPData[DP_HDCP2_AKE_RTX_SIZE]);
            break;

        case DP_HDCP2_MSG_ID_AKE_NO_STORED_KM:
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_AKE_EKPUB_KM, pHDCPData);
            break;

        case DP_HDCP2_MSG_ID_AKE_STORED_KM:
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_AKE_EKH_KM_WR, pHDCPData);
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_AKE_M, &pHDCPData[DP_HDCP2_AKE_EKH_KM_WR_SIZE]);
            break;

        case DP_HDCP2_MSG_ID_LC_INIT:
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_LC_RN, pHDCPData);
            break;

        case DP_HDCP2_MSG_ID_SKE_SEND_EKS:
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_SKE_EDKEY_KS, pHDCPData);
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_SKE_RIV, &pHDCPData[DP_HDCP2_SKE_EDKEY_KS_SIZE]);
            break;

        case DP_HDCP2_MSG_ID_REPAUTH_SEND_ACK:
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_ACK_SEND_ACK_V, pHDCPData);
            break;

        case DP_HDCP2_MSG_ID_REPAUTH_STREAM_MANAGE:
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_STREAM_SEQ_NUM_M, pHDCPData);
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_STREAM_k, &pHDCPData[DP_HDCP2_STREAM_SEQ_NUM_M_SIZE]);
            bGetData = mhal_DPRx_HDCP2GetRxData(dprx_id, DP_HDCP2_INFO_STREAM_STREAM_ID_TYPE, &pHDCPData[DP_HDCP2_STREAM_SEQ_NUM_M_SIZE + DP_HDCP2_STREAM_k_SIZE]);
            break;

        default:
            break;
    }

    return bGetData;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_HDCP2SetTxData()
//  [Description]
//					_mdrv_DPRx_HDCP2SetTxData
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_HDCP2SetTxData(DPRx_ID dprx_id, BYTE ucMessageID, BYTE *pHDCPData)
{
    dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(SrcInputType);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    switch(ucMessageID)
    {
        case DP_HDCP2_MSG_ID_AKE_SEND_CERT:
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_AKE_RRX, pHDCPData);
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_AKE_RXCAPS, &pHDCPData[DP_HDCP2_AKE_RRX_SIZE]);
            break;

        case DP_HDCP2_MSG_ID_AKE_SEND_H_PRIME:
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_AKE_H_PRIME, pHDCPData);

            glDPRxInfo[dprx_id].bHDCP22TriggerShortHPD = TRUE;
            glDPRxInfo[dprx_id].u8HDCP22MsgID = DP_HDCP2_MSG_ID_AKE_SEND_H_PRIME;
            break;

        case DP_HDCP2_MSG_ID_AKE_SEND_PAIRING_INFO:
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_AKE_EKH_KM_RD, pHDCPData);

            glDPRxInfo[dprx_id].bHDCP22TriggerShortHPD = TRUE;
            glDPRxInfo[dprx_id].u8HDCP22MsgID = DP_HDCP2_MSG_ID_AKE_SEND_PAIRING_INFO;
            break;

        case DP_HDCP2_MSG_ID_LC_SEND_L_PRIME:
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_LC_L_PRIME, pHDCPData);
            break;

        case DP_HDCP2_MSG_ID_REPAUTH_SEND_RECVID_LIST:
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_RECVLIST_RXINFO, pHDCPData);
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_RECVLIST_SEQ_NUM_V, &pHDCPData[DP_HDCP2_RECVLIST_RXINFO_SIZE]);
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_RECVLIST_VPRIME, &pHDCPData[DP_HDCP2_RECVLIST_RXINFO_SIZE + DP_HDCP2_RECVLIST_SEQ_NUM_V_SIZE]);
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_RECVLIST_RECEIVER_ID_LIST, &pHDCPData[DP_HDCP2_RECVLIST_RXINFO_SIZE + DP_HDCP2_RECVLIST_SEQ_NUM_V_SIZE + DP_HDCP2_RECVLIST_VPRIME_SIZE]);

            glDPRxInfo[dprx_id].bHDCP22TriggerShortHPD = TRUE;
            glDPRxInfo[dprx_id].u8HDCP22MsgID = DP_HDCP2_MSG_ID_REPAUTH_SEND_RECVID_LIST;
            break;

        case DP_HDCP2_MSG_ID_REPAUTH_STREAM_READY:
            mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_STREAM_MPRIME, pHDCPData);
            break;

        default:
            break;
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_HDCP2Handler()
//  [Description]
//					_mdrv_DPRx_HDCP2Handler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void _mdrv_DPRx_HDCP2Handler(DPRx_ID dprx_id)
{
    static BYTE ucHDCPCStatusDelayCnt[DPRx_ID_MAX] = {0x0};
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    // HDCP22 trigger short HPD
    if(glDPRxInfo[dprx_id].bHDCP22TriggerShortHPD == TRUE)
    {
        if(glDPRxInfo[dprx_id].u8HDCP22MsgID == DP_HDCP2_MSG_ID_AKE_SEND_H_PRIME)
        {
            glDPRxInfo[dprx_id].bHDCP22TriggerShortHPD = FALSE;
            glDPRxInfo[dprx_id].u8HDCP22MsgID = DP_HDCP2_MSG_ID_NONE;

            mhal_DPRx_HDCP2SetRxStatus(dprx_id, DP_HDCP2_RXSTATUS_H_PRIME_AVAILABLE, TRUE);
            mhal_DPRx_HDCP2SetRxStatus(dprx_id, DP_HDCP2_RXSTATUS_H_PRIME_AVAILABLE, FALSE);
            mhal_DPRx_SetCPIRQ(dprx_aux_id);
            _mdrv_DPRx_ShortHPD(dprx_id);

            DP_DRV_DPRINTF("H' HPD ID#%d", dprx_id);
        }
        else if(glDPRxInfo[dprx_id].u8HDCP22MsgID == DP_HDCP2_MSG_ID_AKE_SEND_PAIRING_INFO)
        {
            if(ucHDCPCStatusDelayCnt[dprx_id] < 0x5) //patch H' not reply complete but short hpd be triggered
            {
                ucHDCPCStatusDelayCnt[dprx_id]++;
                return;
            }
            else
            {
                ucHDCPCStatusDelayCnt[dprx_id] = 0x0;
            }

            glDPRxInfo[dprx_id].bHDCP22TriggerShortHPD = FALSE;
            glDPRxInfo[dprx_id].u8HDCP22MsgID = DP_HDCP2_MSG_ID_NONE;

            mhal_DPRx_HDCP2SetRxStatus(dprx_id, DP_HDCP2_RXSTATUS_PAIRING_AVAILABLE, TRUE);
            mhal_DPRx_HDCP2SetRxStatus(dprx_id, DP_HDCP2_RXSTATUS_PAIRING_AVAILABLE, FALSE);
            mhal_DPRx_SetCPIRQ(dprx_aux_id);
            _mdrv_DPRx_ShortHPD(dprx_id);

            DP_DRV_DPRINTF("Paring HPD ID#%d", dprx_id);
        }
        else if(glDPRxInfo[dprx_id].u8HDCP22MsgID == DP_HDCP2_MSG_ID_REPAUTH_SEND_RECVID_LIST)
        {

            glDPRxInfo[dprx_id].bHDCP22TriggerShortHPD = FALSE;
            glDPRxInfo[dprx_id].u8HDCP22MsgID = DP_HDCP2_MSG_ID_NONE;

            mhal_DPRx_HDCP2SetRxStatus(dprx_id, DP_HDCP2_RXSTATUS_READY, TRUE);
            mhal_DPRx_HDCP2SetRxStatus(dprx_id, DP_HDCP2_RXSTATUS_READY, FALSE);
            mhal_DPRx_SetCPIRQ(dprx_aux_id);
            _mdrv_DPRx_ShortHPD(dprx_id);
            DP_DRV_DPRINTF("Rdy HPD ID#%d", dprx_id);
        }
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetHDCP2CallBackFunction()
//  [Description]
//					mdrv_DPRx_SetHDCP2CallBackFunction
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetHDCP2CallBackFunction(DPRx_HDCP2_CB_FUNC pHDCP2RxFunc)
{
    pmdrv_DP_HDCP2RxEventProc = pHDCP2RxFunc;

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetHDCP2ConfigRepeaterCallBackFunction()
//  [Description]
//					mdrv_DPRx_SetHDCP2ConfigRepeaterCallBackFunction
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetHDCP2ConfigRepeaterCallBackFunction(DPRX_HDCP2_Config_Repeater_CB_FUNC pHDCP2RxConfig_RepeaterFunc)
{
    pmdrv_DPRX_HDCP2_Config_Repeater_CB_FUNC = pHDCP2RxConfig_RepeaterFunc;

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_HDCP2TxEventProc()
//  [Description]
//					mdrv_DPRx_HDCP2TxEventProc
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_HDCP2TxEventProc(BYTE ucInputPort, BYTE ucMessageID, BYTE *pMessageData)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    _mdrv_DPRx_HDCP2SetTxData(dprx_id, ucMessageID, pMessageData);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_HDCP2SetCertRx()
//  [Description]
//					mdrv_DPRx_HDCP2SetCertRx
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_HDCP2SetCertRx(BYTE *pHDCP2CertRx)
{
    DPRx_ID dprx_id = DPRx_ID_0;

    mhal_DPRx_HDCP2SetTxData(dprx_id, DP_HDCP2_INFO_AKE_CERTRX, pHDCP2CertRx);

    mhal_DPRx_EnableHDCP2EventMask(dprx_id, TRUE); // Enable HDCP22 event mask
#if(DPRx_HDCP2_ISR_MODE == 0x1)
    mhal_DPRx_EnableHDCP2Interrupt(dprx_id, TRUE); // Enable HDCP22 interrupt
#endif

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_HDCP2SetRxCaps()
//  [Description]
//					mdrv_DPRx_HDCP2SetRxCaps
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_HDCP2SetRxCaps(BYTE ucInputPort, BOOL bEnable)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    mhal_DPRx_HDCP2SetRxCaps(dprx_id, bEnable);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_HDCP22RepeaterGetRxinfo()
//  [Description]
//					mdrv_DPRx_HDCP22RepeaterGetRxinfo
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_HDCP22RepeaterGetRxinfo(BYTE ucInputPort, BYTE *pRxInfo_Hbyte, BYTE *pRxInfo_Lbyte)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    mhal_DPRx_HDCP22ReadRxinfo(dprx_id, pRxInfo_Hbyte, pRxInfo_Lbyte);

    return;
}

#if (DPRx_HDCP2_ISR_MODE == 0x1)
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_HDCP2FetchMsg()
//  [Description]
//					mdrv_DPRx_HDCP2FetchMsg
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_HDCP2FetchMsg(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    if(mhal_DPRx_GetHDCP2IrqFlag(dprx_id)) // BK1106_2D[13]: dp_hdcp22_irq
    {
        // HDCP22 client 1 interrupt event
        if(mhal_DPRx_GetHDCP2AKEInitFlag(dprx_id)) // BK110B_70[1]: ake_init_irq_status
        {
            ucHDCPData[0] = DP_HDCP2_MSG_ID_AKE_INIT;

            // Reset HDCP HPD status
            glDPRxInfo[dprx_id].bHDCP22TriggerShortHPD = FALSE;
            glDPRxInfo[dprx_id].u8HDCP22MsgID = DP_HDCP2_MSG_ID_NONE;
            glDPRxInfo[dprx_id].bForceIntegrityFail = FALSE;
            glDPRxInfo[dprx_id].bHdcpStartAuth = TRUE;

            mhal_DPRx_ForceHDCP13IntegrityFail(dprx_id, FALSE);
            mhal_DPRx_ForceHDCP22IntegrityFail(dprx_id, FALSE);

            // Overread to reset RX status H' and pairing available
            mhal_DPRx_EnableHDCP2ReadDownInterrupt(dprx_id, FALSE);
            mhal_DPRx_MCUReadNonPMDPCD(dprx_id, dprx_aux_id, DP_HDCP2_DPCD_HprimeReadDone);
            mhal_DPRx_MCUReadNonPMDPCD(dprx_id, dprx_aux_id, DP_HDCP2_DPCD_PairingReadDone);
            mhal_DPRx_EnableHDCP2ReadDownInterrupt(dprx_id, TRUE);

            // Trigger repeater TX start Auth to sink

            mhal_DPRx_MCUReadNonPMDPCD(dprx_id, dprx_aux_id, DP_HDCP2_DPCD_Rxinfo); // Reset RX status ready

        }
        else if(mhal_DPRx_GetHDCP2NoStoredKmFlag(dprx_id)) // BK110B_70[2]: ake_no_stored_km_status
        {
            ucHDCPData[0] = DP_HDCP2_MSG_ID_AKE_NO_STORED_KM;
        }
        else if(mhal_DPRx_GetHDCP2StoredKmFlag(dprx_id)) // BK110B_70[3]: ake_stored_km_status
        {
            ucHDCPData[0] = DP_HDCP2_MSG_ID_AKE_STORED_KM;
        }
        else if(mhal_DPRx_GetHDCP2LCInitFlag(dprx_id)) // BK110B_70[4]: locality_check_status
        {
            ucHDCPData[0] = DP_HDCP2_MSG_ID_LC_INIT;
        }
        else if(mhal_DPRx_GetHDCP2SKEFlag(dprx_id)) // BK110B_70[5]: ske_irq
        {
            ucHDCPData[0] = DP_HDCP2_MSG_ID_SKE_SEND_EKS;
        }
        else if(mhal_DPRx_GetHDCP2HprimeReadDoneFlag(dprx_id)) // BK110B_78[8]: h_pulum_status
        {
            ucHDCPData[0] = DP_HDCP2_MSG_ID_NONE;
        }
        else if(mhal_DPRx_GetHDCP2RepAuthSendAckFlag(dprx_id)) // BK160B_79[1]: repauth_send_ack
        {
            ucHDCPData[0] = DP_HDCP2_MSG_ID_REPAUTH_SEND_ACK;
        }
        else if(mhal_DPRx_GetHDCP2RepAuthStreamManageFlag(dprx_id)) // BK160B_79[2]: repauth_stream_manage
        {
            ucHDCPData[0] = DP_HDCP2_MSG_ID_REPAUTH_STREAM_MANAGE;
        }
        else
        {
            return;
        }

        _mdrv_DPRx_HDCP2GetRxData(dprx_id, ucHDCPData[0], &ucHDCPData[1]);

        if(pmdrv_DP_HDCP2RxEventProc != NULL) // Have call back function
        {
            pmdrv_DP_HDCP2RxEventProc(0, ucHDCPData);
        }

        // Turn on mask avoid edge trigger interrupt conflict in next time
        mhal_DPRx_EnableHDCP2Interrupt(dprx_id, FALSE); // Disble HDCP22 IRQ mask
        mhal_DPRx_EnableHDCP2EventMask(dprx_id, FALSE); // Disble HDCP22 event mask

        // Turn off mask avoid edge trigger interrupt conflict in next time
        mhal_DPRx_EnableHDCP2Interrupt(dprx_id, TRUE); // Enable HDCP22 IRQ mask
        mhal_DPRx_EnableHDCP2EventMask(dprx_id, TRUE); // Enable HDCP22 event mask
    }

    return;
}
#endif
#endif

void ________TYPE_C________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetLaneSwapEnable()
//  [Description]
//					mdrv_DPRx_SetLaneSwapEnable
//  [Arguments]:
//					ubTargetLaneNumber: [1:0] for Lane0,
//										[3:2] for Lane1,
//										[5:4] for Lane2,
//										[7:6] for Lane3
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_SetLaneSwapEnable(BYTE ucInputPort, BOOL bEnable, BYTE ubTargetLaneNumber)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX) || (dprx_phy_id == DPRx_PHY_ID_MAX))
    {
        return FALSE;
    }

    glTypeC_PhyLaneSwap[dprx_id] = ubTargetLaneNumber;

    mhal_DPRx_SetPHYLaneSwapEnable(dprx_id, dprx_phy_id, bEnable, ubTargetLaneNumber);

    mhal_DPRx_Select_ACDR_Lane(dprx_phy_id, ubTargetLaneNumber & (BIT1|BIT0));

    return mhal_DPRx_SetLaneSwapEnable(dprx_id, dprx_phy_id, bEnable, ubTargetLaneNumber);
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetLanePNSwapEnable()
//  [Description]
//					mdrv_DPRx_SetLanePNSwapEnable
//  [Arguments]:
//					ubLanePNSwapSelect: BIT0 for Lane0, BIT1 for Lane1, BIT2 for Lane2, BIT3 for Lane3, only work when b4LanePNSwap = TRUE
//					ubTargetLaneNumber: [1:0] for Lane0, [3:2] for Lane1, [5:4] for Lane2 , [7:6] for Lane3
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_SetLanePNSwapEnable(BYTE ucInputPort, BOOL bEnable, BOOL bAuxPNSwap, BOOL b4LanePNSwap, BYTE ubLanePNSwapSelect)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);
    BYTE bRet = TRUE;

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return FALSE;
    }

    if(ucInputPort == Input_UsbTypeC_C4)
    {
        mhal_DPRx_SetHwHPDControlEnable(dprx_aux_id, FALSE);
    }

    if(bEnable == TRUE)
    {
		glTypeC_MacPNswap[dprx_id] = ubLanePNSwapSelect;
        mhal_DPRx_SetPHYPRBS7PNSwapEnable(dprx_phy_id, ubLanePNSwapSelect);
        mhal_DPRx_SetLanePNSwapEnable(dprx_id, b4LanePNSwap, ubLanePNSwapSelect);
        mhal_DPRx_SetAuxPNSwapEnable(dprx_aux_id, bAuxPNSwap);
    }
    else
    {
		glTypeC_MacPNswap[dprx_id] = 0;
        mhal_DPRx_SetLanePNSwapEnable(dprx_id, FALSE, ubLanePNSwapSelect);
        mhal_DPRx_SetAuxPNSwapEnable(dprx_aux_id, FALSE);
    }

    return bRet;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetTypeCInfo()
//  [Description]
//					mdrv_DPRx_SetTypeCInfo
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_SetTypeCInfo(BYTE ucInputPort, BYTE ubCCpinInfo, BYTE ubPinAssingInfo)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    glDPRxInfo[dprx_id].ubTypeC_CC = ubCCpinInfo;
    glDPRxInfo[dprx_id].ubTypeC_PinAssign = ubPinAssingInfo;

    if(ubCCpinInfo < 2)
    {
        glDPRxInfo[dprx_id].bDPcableConnent = TRUE;
    }
    else
    {
        glDPRxInfo[dprx_id].bDPcableConnent = FALSE;
    }

    return TRUE;
}
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetEQ_Current()
//  [Description]
//					mdrv_DPRx_SetEQ_Current
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_SetEQ_Current(BYTE ucInputPort,BOOL eq_current)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_phy_id == DPRx_PHY_ID_MAX))
    {
        return FALSE;
    }

    mhal_DPRx_SetEQ_Current(dprx_phy_id, eq_current);

    return TRUE;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetTypeCHPDEvent()
//  [Description]
//					mdrv_DPRx_GetTypeCHPDEvent
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetTypeCHPDEvent(BYTE ucInputPort, BYTE *ucHPDValue)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    if(_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id) != DPRx_ID_MAX)
    {
        *ucHPDValue = glubTypeCHPDCtrl[_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id)];

        return glubTriggerTypeCHPDFlag[_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id)];
    }

    return FALSE;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_ClrTypeCHPDEvent()
//  [Description]
//					mdrv_DPRx_ClrTypeCHPDEvent
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_ClrTypeCHPDEvent(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    if(_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id) != DPRx_ID_MAX)
    {
        glubTypeCHPDCtrl[_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id)] = FALSE;
        glubTriggerTypeCHPDFlag[_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id)] = FALSE;
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_GetTypeCShortHPDEvent()
//  [Description]
//					mdrv_DPRx_GetTypeCShortHPDEvent
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_GetTypeCShortHPDEvent(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    if(_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id) != DPRx_ID_MAX)
    {
        return glubTypeCShortHPD[_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id)];
    }

    return FALSE;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_ClrTypeCShortHPDEvent()
//  [Description]
//					mdrv_DPRx_ClrTypeCShortHPDEvent
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_ClrTypeCShortHPDEvent(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    if(_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id) != DPRx_ID_MAX)
    {
        glubTypeCShortHPD[_mdrv_DPRx_MSCHIP_DPRxID2TypeCPortID(dprx_id)] = FALSE;
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_TypeC_CableDisconect()
//  [Description]
//					mdrv_DPRx_TypeC_CableDisconect
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_TypeC_CableDisconect(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);

    if(dprx_id == DPRx_ID_MAX)
    {
        return;
    }

    if( _mdrv_DPRx_CTSCheck(dprx_id)) // For PHY CTS
    {
        return;
    }

    _mdrv_DPRx_CableDisconnectReset(dprx_id);

    return;
}

void ________POWER________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_IsSystemGoRealSleep()
//  [Description]
//					mdrv_DPRx_IsSystemGoRealSleep
//  [Arguments]:
//
//  [Return]:
//            		TRUE: Real PM mode, FASE: Fake sleep mode
//**************************************************************************
BOOL mdrv_DPRx_IsSystemGoRealSleep(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX) || (dprx_phy_id == DPRx_PHY_ID_MAX))
    {
        return FALSE;
    }

    if(_mdrv_DPRx_CTSCheck(dprx_id)) // For PHY CTS
    {
        return FALSE;
    }

    if(mhal_DPRx_CheckCDRLock(dprx_id, dprx_aux_id, dprx_phy_id, glDPRxInfo[dprx_id].OnlinePort) == TRUE)
    {
        return FALSE;
    }
    else if(mdrv_DPRx_AUX_N_Level(ucInputPort) && _mdrv_DPRx_CheckSquelch(dprx_id))
    {
        return FALSE;
    }

    return TRUE;
}

void ________MSCHIP________(void);
//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_MSCHIP_CableDetect()
//  [Description]
//					mdrv_DPRx_MSCHIP_CableDetect
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
BOOL mdrv_DPRx_MSCHIP_CableDetect(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);

    if(dprx_id == DPRx_ID_MAX)
    {
        return FALSE;
    }

    return glDPRxInfo[dprx_id].bDPcableConnent;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_MSCHIP_EnableDPDetect()
//  [Description]
//					mdrv_DPRx_MSCHIP_EnableDPDetect
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_MSCHIP_EnableDPDetect(BYTE ucPMMode, BOOL bEnable)
{
    DPRx_ID dprx_id = DPRx_ID_MAX;
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    DPRx_DECODER_ID dprx_decoder_id = DPRx_DECODER_ID_MAX;
    DPRx_PHY_ID dprx_phy_id = DPRx_PHY_ID_MAX;
    WORD usRegOffsetAuxByID = DP_REG_OFFSET300(dprx_id);
    UNUSED(bEnable);

    switch(ucPMMode)
    {
        case ePM_STANDBY: // DPMS
            // Switch FRO before turn off Xtal
            mdrv_DPRx_SetAuxPMClock(FALSE); // Set PM Aux clock to FRO

            for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
            {
                dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
                dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

                msWriteByte(REG_DPRX_AUX_3C_H + usRegOffsetAuxByID, 0xFF); // Clear AUX received info
                msWriteByteMask(REG_DPRX_AUX_DPCD_61_L + usRegOffsetAuxByID, 0, BIT7); // reg_pd_vcm_op
                mhal_DPRx_CableDisconectResetDPCD(dprx_id, dprx_aux_id);
                mhal_DPRx_OverWriteDPCD202_203(dprx_id, FALSE, 0x0000);
                glDPRxInfo[dprx_id].bOverWriteLockStatus = FALSE;

                // Clear fake training status need at DP offline mode
                mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, TRUE);
                _mdrv_DPRx_ClearFakeTrainingLockStatus(dprx_id);
                _mdrv_DPRx_Timer_variable_Reset();
				// Disable interrupt
				mhal_DPRx_EnableReceiverInterrupt(dprx_id, FALSE);
				mhal_DPRx_SetCDRLossLockInterrupt(dprx_id, FALSE);
                mhal_DPRx_SetInterlaneSkewLoseInterrupt(dprx_id, FALSE);
                mhal_DPRx_SetInterlaneSkewDoneInterrupt(dprx_id, FALSE);
				mhal_DPRx_SetProgrammableDPCDEnable(dprx_aux_id, FALSE);
                mhal_DPRx_EnableAuxInterrupt(dprx_aux_id, FALSE);
                mhal_DPRx_EnableDPAUXRecvInterrupt(dprx_aux_id, FALSE);
            	mhal_DPRx_EnablePHYInterrupt(dprx_phy_id, FALSE);

                #if DP_XDATA_PROGRAMMABLE_DPCD_MCCS
                    mhal_DPRx_EnableMCCSXDATAProgrammableDPCD(dprx_aux_id, TRUE);
                #endif

                if(GET_DPRx_FUNCTION_ENABLE_PORT(dprx_id))
                {
                    mhal_DPRx_PHYPowerModeSetting(ucPMMode, dprx_id, dprx_phy_id);
                }
            }
            break;

        case ePM_POWEROFF: // DC off
            #if (ENABLE_DP_DCOFF_HPD_HIGH == 0)
            // Switch FRO before turn off Xtal
            mdrv_DPRx_SetAuxPMClock(FALSE); // Set PM Aux clock to FRO
            #endif

            for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
            {
                dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);
                dprx_decoder_id = _mdrv_DPRx_MSCHIP_DPRxID2DecodeID(dprx_id);
                dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);

                glDPRxInfo[dprx_id].ucState = DPRx_STATE_STARTUP;

                if(dprx_decoder_id < DPRx_DECODER_ID_MAX)
                {
                    glDPRxDecoderInfo[dprx_decoder_id].bAudioEnable = FALSE;
                }
                mhal_DPRx_CableDisconectResetDPCD(dprx_id, dprx_aux_id);
                mhal_DPRx_OverWriteDPCD202_203(dprx_id, FALSE, 0x0000);
                glDPRxInfo[dprx_id].bOverWriteLockStatus = FALSE;

                // Clear fake training status need at DP offline mode
                mhal_DPRx_SetOffLine(dprx_id, dprx_aux_id, TRUE);
                _mdrv_DPRx_ClearFakeTrainingLockStatus(dprx_id);
                _mdrv_DPRx_Timer_variable_Reset();
				// Disable interrupt
				mhal_DPRx_EnableReceiverInterrupt(dprx_id, FALSE);
				mhal_DPRx_SetCDRLossLockInterrupt(dprx_id, FALSE);
                mhal_DPRx_SetInterlaneSkewLoseInterrupt(dprx_id, FALSE);
                mhal_DPRx_SetInterlaneSkewDoneInterrupt(dprx_id, FALSE);
				mhal_DPRx_SetProgrammableDPCDEnable(dprx_aux_id, FALSE);
                mhal_DPRx_EnableAuxInterrupt(dprx_aux_id, FALSE);
                mhal_DPRx_EnableDPAUXRecvInterrupt(dprx_aux_id, FALSE);
            	mhal_DPRx_EnablePHYInterrupt(dprx_phy_id, FALSE);

                #if DP_XDATA_PROGRAMMABLE_DPCD_MCCS
                    mhal_DPRx_EnableMCCSXDATAProgrammableDPCD(dprx_aux_id, TRUE);
                #endif

                if(GET_DPRx_FUNCTION_ENABLE_PORT(dprx_id))
                {
                    mhal_DPRx_PHYPowerModeSetting(ucPMMode, dprx_id, dprx_phy_id);
                }
            }
            break;

        default:
            break;
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_MSCHIP_DP_PMHandler()
//  [Description]
//					mdrv_DPRx_MSCHIP_DP_PMHandler
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_MSCHIP_DP_PMHandler(void)
{
    DPRx_AUX_ID dprx_aux_id = DPRx_AUX_ID_MAX;
    DPRx_ID dprx_id = DPRx_ID_MAX;
    WORD usTimeout = 0;
    WORD usRegOffsetAuxByID = 0;

    for(dprx_id = DPRx_ID_0; dprx_id < DPRx_ID_MAX; dprx_id++)
    {
        dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

        if((dprx_aux_id == DPRx_AUX_ID_MAX) || (glDPRxInfo[dprx_id].bDPcableConnent == FALSE))
        {
            continue;
        }
        usRegOffsetAuxByID = DP_REG_OFFSET300(dprx_aux_id);

        usTimeout = 500;
        while (((msReadByte(REG_DPRX_AUX_04_L+usRegOffsetAuxByID) & BIT0) != 0) && (usTimeout > 0))
        {
            mhal_DPRx_DELAY_NOP(25);
            usTimeout--;
        };

        msWriteByteMask(REG_DPRX_AUX_DPCD_57_L+usRegOffsetAuxByID,BIT3,BIT3);

        #if DP_XDATA_PROGRAMMABLE_DPCD_MCCS
        mhal_DPRx_CheckMCCSXDATAProgrammableDPCD(dprx_aux_id);
        #endif
    }

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_CheckMCCSXDATAProgrammableDPCD()
//  [Description]
//					mdrv_DPRx_CheckMCCSXDATAProgrammableDPCD
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
DPRx_MCCS_WAKEUP mdrv_DPRx_CheckMCCSWakeUpXDATAProgrammableDPCD(BYTE ucInputPort)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if(dprx_aux_id == DPRx_AUX_ID_MAX)
    {
        return DPRx_MCCS_MAX;
    }

    return mhal_DPRx_CheckMCCSWakeUpXDATAProgrammableDPCD(dprx_aux_id);
}
#endif // ENABLE_DP_INPUT

//**************************************************************************
//  [Function Name]:
//                  _mdrv_DPRx_MSCHIP_PortNumber2DPRxID()
//  [Description]
//					_mdrv_DPRx_MSCHIP_PortNumber2DPRxID
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
DPRx_ID _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(BYTE ucInputPort)
{
    if((Input_Displayport_C1 != Input_Nothing) && ((ucInputPort == Input_Displayport_C1)))
    {
        return DPRx_ID_0;
    }
    else if((Input_Displayport_C2 != Input_Nothing) && (ucInputPort == Input_Displayport_C2))
    {
        return DPRx_ID_1;
    }
    else if((Input_Displayport_C3 != Input_Nothing) && ((ucInputPort == Input_Displayport_C3)))
    {
        return DPRx_ID_2;
    }
    else if((Input_Displayport_C4 != Input_Nothing) && ((ucInputPort == Input_Displayport_C4)))
    {
        return DPRx_ID_3;
    }
    else if((Input_UsbTypeC4 != Input_Nothing) && ((ucInputPort == Input_UsbTypeC4)))
    {
        return DPRx_ID_3;
    }
    else
    {
        return DPRx_ID_MAX;
    }

    return DPRx_ID_MAX;
}

//**************************************************************************
//  [Function Name]:
//				  	_mdrv_DPRx_MSCHIP_DPRxID2AuxID()
//  [Description]
//					_mdrv_DPRx_MSCHIP_DPRxID2AuxID
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
DPRx_AUX_ID _mdrv_DPRx_MSCHIP_DPRxID2AuxID(DPRx_ID dprx_id)
{
    if(dprx_id == DPRx_ID_MAX)
    {
        return DPRx_AUX_ID_MAX;
    }

    switch(dprx_id)
    {
        case DPRx_ID_0:
            return (DPRx_AUX_ID)DPRx_C1_AUX;

        case DPRx_ID_1:
            return (DPRx_AUX_ID)DPRx_C2_AUX;

        case DPRx_ID_2:
            return (DPRx_AUX_ID)DPRx_C3_AUX;

        case DPRx_ID_3:
            return (DPRx_AUX_ID)DPRx_C4_AUX;

        default:
            return DPRx_AUX_ID_MAX;
    }

    return DPRx_AUX_ID_MAX;
}

//**************************************************************************
//  [Function Name]:
//				  	_mdrv_DPRx_MSCHIP_DPRxID2PhyID()
//  [Description]
//					_mdrv_DPRx_MSCHIP_DPRxID2PhyID
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
DPRx_PHY_ID _mdrv_DPRx_MSCHIP_DPRxID2PhyID(DPRx_ID dprx_id)
{
    if(dprx_id == DPRx_ID_MAX)
    {
        return DPRx_PHY_ID_MAX;
    }

    switch(dprx_id)
    {
        case DPRx_ID_0:
        case DPRx_ID_1:
        case DPRx_ID_2:
            return DPRx_PHY_ID_0;

        case DPRx_ID_3:
            return DPRx_PHY_ID_1;

        default:
            return DPRx_PHY_ID_MAX;
    }

    return DPRx_PHY_ID_MAX;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetPowerDownControl()
//  [Description]
//					mdrv_DPRx_SetPowerDownControl
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetPowerDownControl(BYTE ucInputPort, DP_ePM_Mode dp_pm_Mode)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_AUX_ID dprx_aux_id = _mdrv_DPRx_MSCHIP_DPRxID2AuxID(dprx_id);

    if((dprx_id == DPRx_ID_MAX) || (dprx_aux_id == DPRx_AUX_ID_MAX))
    {
        return;
    }

    mhal_DPRx_SetPowerDownControl(dprx_id, dprx_aux_id, dp_pm_Mode);

    return;
}

//**************************************************************************
//  [Function Name]:
//                  mdrv_DPRx_SetPhyPowerDownControl()
//  [Description]
//					mdrv_DPRx_SetPowerDownControl
//  [Arguments]:
//
//  [Return]:
//
//**************************************************************************
void mdrv_DPRx_SetPhyPowerDownControl(BYTE ucInputPort, DP_ePM_Mode dp_pm_Mode)
{
    DPRx_ID dprx_id = _mdrv_DPRx_MSCHIP_PortNumber2DPRxID(ucInputPort);
    DPRx_PHY_ID dprx_phy_id = _mdrv_DPRx_MSCHIP_DPRxID2PhyID(dprx_id);
    mhal_DP_PM_Mode edp_pm_mode = mhal_ePM_INVAILD;

    if((dprx_id == DPRx_ID_MAX) || (dprx_phy_id == DPRx_PHY_ID_MAX))
    {
        return;
    }

    switch(dp_pm_Mode)
    {
        case DP_ePM_POWERON:
            edp_pm_mode = mhal_ePM_POWERON;
            break;

        case DP_ePM_STANDBY:
            edp_pm_mode = mhal_ePM_STANDBY;
            break;

        case DP_ePM_POWEROFF:
            edp_pm_mode = mhal_ePM_POWEROFF;
            break;

        case DP_ePM_POWEROFF_NoUsedPort:
            edp_pm_mode = mhal_ePM_INVAILD;
            break;

        case DP_ePM_INVAILD:
            edp_pm_mode = mhal_ePM_POWERON;
            break;

            default:
            edp_pm_mode = mhal_ePM_INVAILD;
            break;
    }

    mhal_DPRx_PHYPowerModeSetting(edp_pm_mode, dprx_id, dprx_phy_id);

    return;
}
#endif // _MDRV_DPRX_C_

